# claude-flow-biomimicry.yaml
#
# Mission: Implement DOL Biomimicry Modeling Primitives
# Purpose: Model biological systems - mycelium networks, ecological dynamics, evolution
#
# Run: npx claude-flow@alpha swarm "read claude-flow-biomimicry.yaml --workflow biomimicry-full"
#
# ═══════════════════════════════════════════════════════════════════════════════
# SUMMARY: DOL as the Modeling Language for Systems of Life
#
# This workflow implements biological primitives that allow DOL to model:
# - Mycelium/Hyphal growth patterns
# - Nutrient transport and resource allocation
# - Ecosystem dynamics (predator-prey, trophic levels)
# - Evolution and speciation
# - Regenerative ecology patterns
# ═══════════════════════════════════════════════════════════════════════════════

name: biomimicry-modeling
version: 1.0.0
description: |
  Implement biological modeling primitives in DOL stdlib.
  These genes and traits encode patterns from mycelium networks,
  ecosystem dynamics, and evolutionary biology.

config:
  max_concurrent_agents: 4
  checkpoint_interval: 30m
  working_dir: ~/repos/univrs-metadol
  log_level: info

# ═══════════════════════════════════════════════════════════════════
# CONTEXT
# ═══════════════════════════════════════════════════════════════════

context:
  philosophy: |
    DOL aims to become the modeling language for ALL Systems of Life.
    By encoding biological patterns as first-class constructs, we enable:
    - Software systems that mimic natural growth and resilience
    - Understanding of human ontological co-existence
    - Regenerative computing inspired by mycelium networks
    
  biological_inspiration:
    mycelium:
      - "Hyphal tip growth follows nutrient gradients"
      - "Anastomosis enables network formation through fusion"
      - "Resource transport follows source-sink dynamics"
      - "Fruiting bodies emerge when conditions are right"
      
    ecosystems:
      - "Lotka-Volterra predator-prey dynamics"
      - "Trophic energy transfer (~10% efficiency)"
      - "Carrying capacity limits population"
      - "Keystone species stabilize systems"
      
    evolution:
      - "Speciation through reproductive isolation"
      - "Natural selection favors fitness"
      - "Genetic drift in small populations"
      - "Co-evolution between species"
      
  target_directory: examples/stdlib/biology/

# ═══════════════════════════════════════════════════════════════════
# AGENTS: MYCELIUM NETWORK PRIMITIVES
# ═══════════════════════════════════════════════════════════════════

agents:
  # ─────────────────────────────────────────────────────────────────
  # Core Biological Types
  # ─────────────────────────────────────────────────────────────────
  bio-types:
    name: Biological Types
    role: Define core biological type primitives
    instructions: |
      Create the foundational biological types for DOL.
      
      CREATE examples/stdlib/biology/types.dol:
      
      ```dol
      // ═══════════════════════════════════════════════════════════════
      // DOL Biological Types - Foundation for Life Modeling
      // ═══════════════════════════════════════════════════════════════
      
      module biology.types @ 1.0.0
      
      // ─────────────────────────────────────────────────────────────────
      // Spatial Types
      // ─────────────────────────────────────────────────────────────────
      
      /// 3D position vector
      pub gene Vec3 {
        has x: Float64
        has y: Float64
        has z: Float64
        
        fun magnitude() -> Float64 {
          return (this.x * this.x + this.y * this.y + this.z * this.z).sqrt()
        }
        
        fun normalize() -> Vec3 {
          mag = this.magnitude()
          return Vec3 { x: this.x / mag, y: this.y / mag, z: this.z / mag }
        }
        
        fun dot(other: Vec3) -> Float64 {
          return this.x * other.x + this.y * other.y + this.z * other.z
        }
        
        exegesis {
          Three-dimensional vector for spatial positioning.
          Used for hyphal growth direction, nutrient gradients, etc.
        }
      }
      
      /// Gradient field - maps positions to intensity
      pub gene Gradient<T> {
        has origin: Vec3
        has direction: Vec3
        has intensity: T
        has decay_rate: Float64
        
        fun sample_at(pos: Vec3) -> T {
          distance = (pos.x - this.origin.x).abs() +
                     (pos.y - this.origin.y).abs() +
                     (pos.z - this.origin.z).abs()
          factor = (-distance * this.decay_rate).exp()
          return this.intensity * factor
        }
        
        exegesis {
          Spatial gradient field with exponential decay.
          Models nutrient concentration, chemical signals, etc.
        }
      }
      
      // ─────────────────────────────────────────────────────────────────
      // Resource Types
      // ─────────────────────────────────────────────────────────────────
      
      /// Elemental nutrients (Redfield ratio)
      pub gene Nutrient {
        has carbon: Float64
        has nitrogen: Float64
        has phosphorus: Float64
        has water: Float64
        
        constraint non_negative {
          this.carbon >= 0.0 &&
          this.nitrogen >= 0.0 &&
          this.phosphorus >= 0.0 &&
          this.water >= 0.0
        }
        
        constraint stoichiometry {
          // Redfield ratio: C:N:P ≈ 106:16:1
          // Allow some flexibility: C/N between 6-10
          this.nitrogen > 0.0 implies (
            this.carbon / this.nitrogen >= 6.0 &&
            this.carbon / this.nitrogen <= 10.0
          )
        }
        
        fun total_mass() -> Float64 {
          return this.carbon + this.nitrogen + this.phosphorus + this.water
        }
        
        fun combine(other: Nutrient) -> Nutrient {
          return Nutrient {
            carbon: this.carbon + other.carbon,
            nitrogen: this.nitrogen + other.nitrogen,
            phosphorus: this.phosphorus + other.phosphorus,
            water: this.water + other.water
          }
        }
        
        exegesis {
          Nutrient package following ecological stoichiometry.
          The Redfield ratio (C:N:P ≈ 106:16:1) constrains valid
          nutrient compositions for biological realism.
        }
      }
      
      /// Energy quantum for trophic transfers
      pub gene Energy {
        has joules: Float64
        has quality: Float64  // 0.0 = heat, 1.0 = chemical potential
        
        constraint positive {
          this.joules >= 0.0
        }
        
        constraint quality_bounds {
          this.quality >= 0.0 && this.quality <= 1.0
        }
        
        /// Trophic transfer loses ~90% of energy
        fun trophic_transfer() -> Energy {
          return Energy {
            joules: this.joules * 0.10,
            quality: this.quality * 0.8  // Also degrades
          }
        }
        
        exegesis {
          Energy packet for ecological energy flow.
          Encodes the ~10% trophic transfer efficiency.
        }
      }
      
      // ─────────────────────────────────────────────────────────────────
      // Temporal Types
      // ─────────────────────────────────────────────────────────────────
      
      /// Geological time (for evolution tracking)
      pub gene GeoTime {
        has mya: Float64  // Millions of years ago
        
        constraint non_negative {
          this.mya >= 0.0
        }
        
        fun is_before(other: GeoTime) -> Bool {
          return this.mya > other.mya  // Larger MYA = earlier
        }
        
        exegesis {
          Geological time for evolutionary lineage tracking.
          Measured in millions of years ago (MYA).
        }
      }
      
      /// Generation counter for population dynamics
      pub gene Generation {
        has count: UInt64
        has started_at: Timestamp
        
        fun next() -> Generation {
          return Generation {
            count: this.count + 1,
            started_at: Timestamp.now()
          }
        }
        
        exegesis {
          Generation marker for tracking evolutionary time
          in population dynamics simulations.
        }
      }
      ```
      
      FILE: ~/repos/metadol/examples/stdlib/biology/types.dol

  # ─────────────────────────────────────────────────────────────────
  # Mycelium/Hyphal Traits
  # ─────────────────────────────────────────────────────────────────
  hyphal-trait:
    name: Hyphal Trait
    role: Define hyphal growth behaviors
    dependencies:
      - bio-types
    instructions: |
      Create the Hyphal trait for mycelium-like growth.
      
      CREATE examples/stdlib/biology/hyphal.dol:
      
      ```dol
      // ═══════════════════════════════════════════════════════════════
      // Hyphal Growth - Mycelium Network Primitives
      // ═══════════════════════════════════════════════════════════════
      
      module biology.hyphal @ 1.0.0
      
      use biology.types.{ Vec3, Gradient, Nutrient }
      
      /// State of a hyphal tip
      pub gene HyphalTip {
        has position: Vec3
        has direction: Vec3
        has age: Float64
        has branching_potential: Float64
        has nutrients_absorbed: Nutrient
        
        constraint unit_direction {
          this.direction.magnitude() >= 0.99 &&
          this.direction.magnitude() <= 1.01
        }
        
        constraint positive_age {
          this.age >= 0.0
        }
        
        exegesis {
          The growing tip of a fungal hypha.
          Direction is a unit vector indicating growth heading.
          Branching potential increases with nutrient absorption.
        }
      }
      
      /// Hyphal segment (between tips and branches)
      pub gene HyphalSegment {
        has start: Vec3
        has end: Vec3
        has diameter: Float64
        has transport_capacity: Float64
        
        constraint positive_diameter {
          this.diameter > 0.0
        }
        
        fun length() -> Float64 {
          dx = this.end.x - this.start.x
          dy = this.end.y - this.start.y
          dz = this.end.z - this.start.z
          return (dx * dx + dy * dy + dz * dz).sqrt()
        }
        
        exegesis {
          A tubular segment of hypha connecting nodes.
          Transport capacity determines nutrient flow rate.
        }
      }
      
      /// Trait for hyphal-like growth behavior
      pub trait Hyphal {
        /// Extend toward nutrient gradient
        is extend(gradient: Gradient<Nutrient>) -> Self
        
        /// Branch into multiple hyphae
        is branch(factor: Float64) -> List<Self>
        
        /// Fuse with another hypha (anastomosis)
        is fuse(other: Self) -> Option<Self>
        
        /// Absorb nutrients at current position
        is absorb(available: Nutrient) -> Tuple<Self, Nutrient>
        
        /// Check if ready to fruit
        is can_fruit() -> Bool
        
        // ─────────────────────────────────────────────────────────────
        // Laws (Biological Constraints)
        // ─────────────────────────────────────────────────────────────
        
        law conservation_of_mass {
          // Mass in = mass out + mass stored
          // sum(absorbed) == sum(transported) + sum(stored)
          forall self: Self.
            self.absorbed_mass() == 
              self.transported_mass() + self.stored_mass()
        }
        
        law branching_conserves_potential {
          // Branching distributes potential, doesn't create it
          forall self: Self, factor: Float64.
            sum(self.branch(factor).map(|b| b.branching_potential)) 
              <= self.branching_potential
        }
        
        law fusion_requires_compatibility {
          // Only compatible hyphae can fuse (same species/network)
          forall a: Self, b: Self.
            a.fuse(b).is_some() implies a.is_compatible(b)
        }
        
        exegesis {
          Hyphal trait encodes fungal growth behaviors:
          - Chemotropic extension toward nutrients
          - Branching to explore space
          - Anastomosis (fusion) to form networks
          - Nutrient absorption and transport
          
          These patterns apply to any network that "grows"
          toward resources: neural networks, vascular systems,
          social networks, supply chains.
        }
      }
      
      /// Default implementation for HyphalTip
      impl Hyphal for HyphalTip {
        fun extend(gradient: Gradient<Nutrient>) -> HyphalTip {
          // Sample gradient to determine turn angle
          nutrient_level = gradient.sample_at(this.position)
          
          // Bias direction toward higher concentration
          new_direction = this.direction
            .combine(gradient.direction, weight: nutrient_level.total_mass())
            .normalize()
          
          // Calculate new position
          growth_rate = 0.1 + nutrient_level.total_mass() * 0.01
          new_position = Vec3 {
            x: this.position.x + new_direction.x * growth_rate,
            y: this.position.y + new_direction.y * growth_rate,
            z: this.position.z + new_direction.z * growth_rate
          }
          
          return HyphalTip {
            position: new_position,
            direction: new_direction,
            age: this.age + 1.0,
            branching_potential: this.branching_potential + nutrient_level.total_mass() * 0.1,
            nutrients_absorbed: this.nutrients_absorbed
          }
        }
        
        fun branch(factor: Float64) -> List<HyphalTip> {
          if this.branching_potential < factor {
            return [this]  // Not enough potential
          }
          
          // Create two branches at angles
          branch_angle = 0.5  // radians
          
          left_dir = this.direction.rotate_y(branch_angle)
          right_dir = this.direction.rotate_y(-branch_angle)
          
          return [
            HyphalTip {
              position: this.position,
              direction: left_dir,
              age: 0.0,
              branching_potential: this.branching_potential / 2.0,
              nutrients_absorbed: Nutrient.zero()
            },
            HyphalTip {
              position: this.position,
              direction: right_dir,
              age: 0.0,
              branching_potential: this.branching_potential / 2.0,
              nutrients_absorbed: Nutrient.zero()
            }
          ]
        }
        
        fun fuse(other: HyphalTip) -> Option<HyphalTip> {
          // Check proximity
          distance = (this.position.x - other.position.x).abs() +
                     (this.position.y - other.position.y).abs() +
                     (this.position.z - other.position.z).abs()
          
          if distance > 0.5 {
            return None  // Too far apart
          }
          
          // Merge nutrients and potential
          return Some(HyphalTip {
            position: Vec3 {
              x: (this.position.x + other.position.x) / 2.0,
              y: (this.position.y + other.position.y) / 2.0,
              z: (this.position.z + other.position.z) / 2.0
            },
            direction: this.direction.combine(other.direction, weight: 0.5).normalize(),
            age: max(this.age, other.age),
            branching_potential: this.branching_potential + other.branching_potential,
            nutrients_absorbed: this.nutrients_absorbed.combine(other.nutrients_absorbed)
          })
        }
        
        fun absorb(available: Nutrient) -> Tuple<HyphalTip, Nutrient> {
          // Absorb up to capacity
          absorption_rate = 0.1
          absorbed = Nutrient {
            carbon: available.carbon * absorption_rate,
            nitrogen: available.nitrogen * absorption_rate,
            phosphorus: available.phosphorus * absorption_rate,
            water: available.water * absorption_rate
          }
          
          remaining = Nutrient {
            carbon: available.carbon - absorbed.carbon,
            nitrogen: available.nitrogen - absorbed.nitrogen,
            phosphorus: available.phosphorus - absorbed.phosphorus,
            water: available.water - absorbed.water
          }
          
          new_tip = HyphalTip {
            ...this,
            nutrients_absorbed: this.nutrients_absorbed.combine(absorbed)
          }
          
          return (new_tip, remaining)
        }
        
        fun can_fruit() -> Bool {
          // Fruiting requires accumulated nutrients and age
          return this.nutrients_absorbed.total_mass() > 100.0 &&
                 this.age > 10.0
        }
      }
      ```
      
      FILE: ~/repos/metadol/examples/stdlib/biology/hyphal.dol

  # ─────────────────────────────────────────────────────────────────
  # Transport Network
  # ─────────────────────────────────────────────────────────────────
  transport-trait:
    name: Transport Trait
    role: Define resource transport behavior
    dependencies:
      - bio-types
    instructions: |
      Create the Transport trait for source-sink dynamics.
      
      CREATE examples/stdlib/biology/transport.dol:
      
      ```dol
      // ═══════════════════════════════════════════════════════════════
      // Transport - Source-Sink Resource Flow
      // ═══════════════════════════════════════════════════════════════
      
      module biology.transport @ 1.0.0
      
      use biology.types.{ Nutrient, Energy }
      
      /// A node in the transport network
      pub gene TransportNode<T> {
        has id: UInt64
        has content: T
        has capacity: Float64
        has is_source: Bool
        has is_sink: Bool
        
        constraint valid_role {
          // Can be source, sink, both, or neither (relay)
          true
        }
        
        constraint within_capacity {
          this.content.total_mass() <= this.capacity
        }
        
        exegesis {
          A node in the transport network.
          Sources produce resources, sinks consume them,
          relays just pass resources through.
        }
      }
      
      /// Flow between nodes
      pub gene Flow<T> {
        has from_id: UInt64
        has to_id: UInt64
        has amount: T
        has rate: Float64  // units per time
        
        constraint positive_rate {
          this.rate > 0.0
        }
        
        exegesis {
          Directed flow of resources between nodes.
          Rate determines transport speed.
        }
      }
      
      /// Transport network trait
      pub trait Transport<T> {
        /// Move resources from source to sink
        is transport(
          source: TransportNode<T>,
          sink: TransportNode<T>,
          amount: T
        ) -> Result<Flow<T>, TransportError>
        
        /// Calculate optimal flow distribution
        is optimize_flow(nodes: List<TransportNode<T>>) -> List<Flow<T>>
        
        /// Check network connectivity
        is is_connected(a: TransportNode<T>, b: TransportNode<T>) -> Bool
        
        // ─────────────────────────────────────────────────────────────
        // Laws (Conservation Principles)
        // ─────────────────────────────────────────────────────────────
        
        law mass_conservation {
          // Total mass in network is constant (closed system)
          // Or: inflow == outflow + accumulation (open system)
          forall network: Self.
            network.total_inflow() == 
              network.total_outflow() + network.accumulation()
        }
        
        law flow_continuity {
          // Flow into a node equals flow out (for relays)
          forall node: TransportNode<T>.
            node.is_relay() implies 
              node.inflow() == node.outflow()
        }
        
        law capacity_respected {
          // Flow cannot exceed pipe capacity
          forall flow: Flow<T>, edge: Edge.
            flow.amount <= edge.capacity
        }
        
        exegesis {
          Transport trait models resource flow in networks.
          Inspired by:
          - Mycorrhizal nutrient exchange
          - Vascular plant transport
          - Economic supply chains
          - Data network routing
        }
      }
      
      /// Transport error types
      pub gene TransportError {
        type: enum {
          NotConnected { from: UInt64, to: UInt64 },
          InsufficientCapacity { available: Float64, requested: Float64 },
          SourceEmpty { node_id: UInt64 },
          SinkFull { node_id: UInt64 }
        }
        
        exegesis {
          Errors that can occur during transport operations.
        }
      }
      ```
      
      FILE: ~/repos/metadol/examples/stdlib/biology/transport.dol

  # ─────────────────────────────────────────────────────────────────
  # Ecosystem Dynamics
  # ─────────────────────────────────────────────────────────────────
  ecosystem-system:
    name: Ecosystem System
    role: Define ecosystem dynamics
    dependencies:
      - bio-types
      - transport-trait
    instructions: |
      Create the Ecosystem system with predator-prey dynamics.
      
      CREATE examples/stdlib/biology/ecosystem.dol:
      
      ```dol
      // ═══════════════════════════════════════════════════════════════
      // Ecosystem - Population Dynamics and Trophic Levels
      // ═══════════════════════════════════════════════════════════════
      
      module biology.ecosystem @ 1.0.0
      
      use biology.types.{ Energy, Nutrient, Generation }
      
      /// Species role in ecosystem
      pub gene TrophicRole {
        type: enum {
          Producer,                    // Autotrophs (plants, algae)
          PrimaryConsumer,             // Herbivores
          SecondaryConsumer,           // Carnivores eating herbivores
          TertiaryConsumer,            // Apex predators
          Decomposer                   // Fungi, bacteria
        }
        
        fun trophic_level() -> UInt8 {
          match this {
            Producer { return 1 }
            PrimaryConsumer { return 2 }
            SecondaryConsumer { return 3 }
            TertiaryConsumer { return 4 }
            Decomposer { return 0 }  // Special: recycles
          }
        }
        
        exegesis {
          Trophic role determines position in food web
          and energy transfer efficiency.
        }
      }
      
      /// Species in an ecosystem
      pub gene Species {
        has id: UInt64
        has name: String
        has role: TrophicRole
        has population: UInt64
        has birth_rate: Float64
        has death_rate: Float64
        has carrying_capacity: UInt64
        
        constraint positive_rates {
          this.birth_rate >= 0.0 && this.death_rate >= 0.0
        }
        
        constraint population_non_negative {
          this.population >= 0
        }
        
        /// Logistic growth rate
        fun growth_rate() -> Float64 {
          r = this.birth_rate - this.death_rate
          k = this.carrying_capacity as Float64
          n = this.population as Float64
          return r * n * (1.0 - n / k)
        }
        
        exegesis {
          A species in the ecosystem with population dynamics.
          Growth follows logistic model with carrying capacity.
        }
      }
      
      /// Interaction between species
      pub gene Interaction {
        has predator: UInt64  // species id
        has prey: UInt64      // species id
        has attack_rate: Float64
        has handling_time: Float64
        has conversion_efficiency: Float64
        
        constraint efficiency_bounds {
          this.conversion_efficiency > 0.0 &&
          this.conversion_efficiency <= 1.0
        }
        
        /// Holling Type II functional response
        fun predation_rate(prey_density: Float64) -> Float64 {
          return (this.attack_rate * prey_density) /
                 (1.0 + this.attack_rate * this.handling_time * prey_density)
        }
        
        exegesis {
          Predator-prey interaction with Holling Type II
          functional response (includes handling time saturation).
        }
      }
      
      /// Full ecosystem state
      pub system Ecosystem {
        uses Transport<Energy>
        uses Transport<Nutrient>
        
        state species: Map<UInt64, Species>
        state interactions: List<Interaction>
        state total_energy: Energy
        state nutrient_pool: Nutrient
        state generation: Generation
        
        // ───────────────────────â──────────────────────
        // Ecological Constraints (Laws of Nature)
        // ─────────────────────────────────────────────────────────────
        
        constraint trophic_efficiency {
          // Energy transfer between trophic levels ≈ 10%
          for level in 1..4 {
            energy_at_level = this.energy_at_trophic_leve           energy_at_next = this.energy_at_trophic_level(level + 1)
            
            energy_at_next <= energy_at_level * 0.15  // Allow up to 15%
          }
          
          exegesis {
            Lindeman's 10% law: only ~10% of energy
            transfers between trophic levels.
          }
        }
        
        constraint carrying_capacity_limit {
          // Total population limited by resources
          for sp in this.species.values() {
            sp.population <= sp.carrying_capacity * 1.1  // Allow 10% overshoot
          }
          
          exegesis {
            Carrying capacity limits population.
            Overshoot leads to population crash.
          }
        }
        
        constraint predator_prey_balance {
          // Lotka-Volterra inspired: predators need prey
          for interaction in this.interactions {
            predator = this.species.get(interaction.predator)
            prey = this.species.get(interaction.prey)
            
            // Predators decline if prey is scarce
            predator.population > 0 implies prey.population > 0
          }
          
          exegesis {
            Predators cannot persist without prey.
            Models predator-prey dependency.
          }
        }
        
        constraint decomposer_recycling {
          // Decomposers recycle nutrients back to producers
          decomposer_count = this.species.values()
            .filter(|s| s.role == TrophicRole.Decomposer)
            .map(|s| s.population)
            .sum()
          
          decomposer_count > 0 implies 
            this.nutrient_pool.total_mass() > 0
          
          exegesis {
            Decomposers are essential for nutrient cycling.
            Without them, nutrients become locked in dead matter.
          }
        }
        
        // ─────────────────────────────────────────────────────────────
        // Ecoctions
        // ─────────────────────────────────────────────────────────────
        
        /// Advance ecosystem by one time step (Lotka-Volterra)
        fun tick() -> Self {
          new_species = Map.new()
          
          for (id, sp) in this.species {
            // Calculate population change
            growth = sp.growth_rate()
            
            // Add predation           predation_loss = 0.0
            predation_gain = 0.0
            
            for interaction in this.interactions {
              if interaction.prey == id {
                predator = this.species.get(interaction.predator)
                predation_loss += interaction.predation_rate(sp.population as Float64) 
                                  * predator.population as Float64
              }
              if interaction.predator == id {
                prey = this.species.get(interaction.prey)
                consumed = interaction.predation_rate(prey.population as Float64)
                           * sp.population as Float64
                predation_gain += consumed * interaction.conversion_efficiency
              }
            }
            
            // Update population
            delta = growth - predation_loss + predation_gain
            new_pop = max(0, (sp.population as Float64 + delta) as UInt64)
            
            new_species.insert(id, Species { ...sp, population: new_pop })
          }
          
          return Ecosystem {
            ...this,
            species: new_species,
            generation: this.generation.next()
          }
        }
        
        /// Calculate energy at a trophic level
        fun energy_at_trophic_level(level: UInt8) -> Float64 {
          return this.species.values()
            .filter(|s| s.role.trophic_level() == level)
            .map(|s| s.population as Float64 * 1.0)  // Energy per individual
            .sum()
        }
        
        /// Check if ecosystem is stable (attractor reached)
        fun is_stable(tolerance: Float64) -> Bool {
          // Run one tick and compare
          next = this.tick()
          
          for (id, sp) in this.species {
            next_sp = next.species.get(id)
            change = ((next_sp.population as Float64) - (sp.population as Float64)).abs()
            if change / (sp.population as Float64 + 1.0) > tolerance {
              return false
            }
          }
          
          return true
        }
        
        /// Add a keystone species (stabilizes ecosystem)
        fun add_keystone(species: Species) -> Self {
          // Keystone species have outsized effects
          return Ecosystem {
            ...this,
            species: this.species.insert(species.id, species)
          }
        }
        
        exegesis {
          Ecosystem models population dynamics using:
          - Lotka-Volterra predator-prey equations
          - Logistic growth with carrying capacity
          - Holling Type II functional response
          - Trophic energy transfer (10% rule)
          
          This is the foundation for modeling any system of
          interacting populations: biological, economic, social.
        }
      }
      ```
      
      FILE: ~/repos/metadol/examples/stdlib/biology/ecosystem.dol

  # ───────────────────────────────────────────────────────────â# Evolution Primitives
  # ─────────────────────────────────────────────────────────────────
  evolution-types:
    name: Evolution Types
    role: Define evolution and speciation primitives
    dependencies:
      - bio-types
    instructions: |
      Create evolution primitives using DOL's evolves keyword.
      
      CREATE examples/stdlib/biology/evolution.dol:
      
    ```dol
      // ═══════════════════════════════════════════════════════════════
      // Evolution - Speciation and Lineage Tracking
      // ═══════════════════════════════════════════════════════════════
      
      module biology.evolution @ 1.0.0
      
 logy.types.{ GeoTime, Generation }
      
      /// Genetic trait (simplified)
      pub gene Trait {
        has name: String
        has value: Float64
        has heritability: Float64  // 0.0 - 1.0
        has mutation_rate: Float64
        
        constraint heritability_bounds {
          this.heritability >= 0.0 && this.heritability <= 1.0
        }
        
        constraint mutation_rate_bounds {
          this.mutation_rate >= 0.0 && this.mutation_rate <= 1.0
        }
        
        /// Inherit trait with possible mutation
        fun inherit(parent_value: Float64) -> Trait {
          // Heritability determines how much of parent value is kept
          inherited = parent_value * this.heritability
          
          // Mutation adds variance
          mutation = if random() < this.mutation_rate {
            (random() - 0.5) * 0.1  // Small random change
          } else {
            0.0
          }
          
          return Trait {
            ...this,
            value: inherited + mutation
          }
        }
        
        exegesis {
          A heritable trait subject to mutation.
          Heritability determines parent-offspring correlation.
        }
      }
      
      /// Genome (collection of traits)
      pub gene Genome {
        has traits: Map<String, Trait>
        has fitness: Float64
        
        constraint positive_fitness {
          this.fitness >= 0.0
        }
        
        /// Calculate fitness from traits (placeholder)
        fun calculate_fitness(environment: Environment) -> Float64 {
          // Fitness is environment-dependent
          total = 0.0
          for (name, trait) in this.traits {
            optimal = environment.optimal_values.get(name).unwrap_or(0.5)
            distance = (trait.value - optimal).abs()
            total += 1.0 - distance  // Closer to optimal = higher fitness
          }
          return total / this.traits.len() as Float64
        }
        
        /// Sexual reproduction (recombination)
        fun recombine(other: Genome) -> Genome {
          new_traits = Map.new()
          for (name, trait) in this.traits {
            other_trait = other.traits.get(name)
            // 50% chance to inherit from each parent
            chosen = if random() < 0.5 { trait } else { other_trait }
            // Then possibly mutate
            new_traits.insert(name, chosen.inherit(chosen.value))
          }
          return Genome { traits: new_traits, fitness: 0.0 }
        }
        
        exegesis {
          A genome as a collection of heritable traits.
          Fitness is calculated relative to environment.
        }
      }
      
      /// Species lineage for tracking evolution
      pub gene Lineage {
        has ancestor_id: Option<UInt64>
        has divergence_time: GeoTime
        has innovations: List<String>  // Key evolutionary innovations
        
        exegesis {
          Tracks evolutionary lineage and innovations.
          Used for phylogenetic reconstruction.
        }
      }
      
      /// Trait for entities that can evolve
      pub trait Evolvable {
        /// Mutate traits
        is mutate(rate: Float64) -> Self
        
        /// Reproduce with recombination
        is reproduce(other: Self) -> Self
        
        /// Calculate fitness in environment
        is fitness(env: Environment) -> Float64
        
        /// Check if speciation should occur
        is should_speciate(population: List<Self>) -> Bool
        
        law fitness_inheritance {
          // Offspring fitness correlates with parent fitness
          // (but not perfectly due to recombination and mutation)
          forall p1: Self, p2: Self.
            offspring = p1.reproduce(p2).
            offspring.fitness(env) is_correlated_with 
              (p1.fitness(env) + p2.fitness(env)) / 2.0
        }
        
        law speciation_requires_isolation {
          // Speciation requires some form of isolation
          forall population: List<Self>.
            self.should_speciate(population) implies
              (reproductive_isolation(self, population) > threshold)
        }
        
        exegesis {
          Evolvable trait for entities subject to evolution.
          Combines mutation, recombination, and selection.
        }
      }
      
      // ─────────────────────────────────────────────────────────────────
      // Using DOL's evolves keyword for speciation
      // ─────────────────────────────────────────────────────────────────
      
      /// Base organism
      pub gene Organism {
        has species_id: UInt64
        has genome: Genome
        has lineage: Lineage
        has generation: Generation
        
        exegesis {
          Base organism type from which species evolve.
        }
      }
      
      /// Prokaryote evolved from Organism
      ves Organism > Prokaryote @ 3.5Gya {
        removed eukaryotic_features
        
        added cell_wall: CellWall
        added circular_chromosome: Bool = true
        
        constraint no_nucleus {
          // Prokaryotes lack membrane-bound nucleus
          not this.has_nucleus
        }
        
        migrate from Organism {
          return Prokaryote {
            species_id: old.species_id,
            genome: old.genome,
            lineage: Lineage {
              ancestor_id: Some(old.species_id),
              divergence_time: GeoTime { mya: 3500.0 },
              innovations: ["cell_wall", "circular_chromosome"]
            },
            generation: old.generation,
            cell_wall: CellWall.default(),
            circular_chromosome: true
          }
        }
        
        exegesis {
          Prokaryotes: first cellular life forms.
          Evolved ~3.5 billion years ago.
          Lack membrane-bound organelles.
        }
      }
      
      /// Eukaryote evolved from Organism (via endosymbiosis)
      evolves Organism > Eukaryote @ 2.0Gya {
        added nucleus: Nucleus
        added mitochondria: List<Mitochondrion>
        added endomembrane_system: Bool = true
        
        constraint has_nucleus {
          this.nucleus is not null
        }
        
        constraint has_mitochondria {
          // All eukaryotes have mitochondria (or remnants)
          this.mitochondria.len() >= 1
        }
        
        migrate from Organism {
          return Eukaryote {
            species_id: old.species_id,
            genome: old.genome,
            lineage: Lineage {
              ancestor_id: Some(old.species_id),
              divergence_time: GeoTime { mya: 2000.0 },
              innovations: ["nucleus", "mitochondria", "endosymbiosis"]
            },
            generation: old.generation,
            nucleus: Nucleus.default(),
            mitochondria: [Mitochondrion.default()],
            endomembrane_system: true
          }
        }
        
        exegesis {
          Eukaryotes: complex cells with membrane-bound organelles.
          Evolved ~2 billion years ago via endosymbiosis.
          Mitochondria were once free-living bacteria.
        }
      }
      
      /// Fungi evolved from Eukaryote
      evolves Eukaryote > Fungus @ 1.0Gya {
        added chitin_cell_wall: Bool = true
        added hyphal_growth: Bool = true
        
        removed chloroplasts
        
        constraint heterotrophic {
          // Fungi are heterotrophs (cannot photosynthesize)
          not this.can_photosynthesize
        }
        
        migrate from Eukaryote {
          return Fungus {
            ...old,
            lineage: Lineage {
              ancestor_id: Some(old.species_id),
              divergence_time: GeoTime { mya: 1000.0 },
              innovations: ["chitin_wall", "hyphal_growth", "heterotrophy"]
            },
            chitin_cell_wall: true,
            hyphal_growth: true
          }
        }
        
        exegesis {
          Fungi: heterotrophic eukaryotes with chitin cell walls.
          Evolved ~1 billion years ago.
          Include yeasts, molds, and mushrooms.
        }
      }
      ```
      
      FILE: ~/repos/metadol/examples/stdlib/biology/evolution.dol

  # ─────────────────────────────────────────────────────────────────
  # Mycelium Network System
  # ───────────────────────────────────────────────────────────────
  mycelium-system:
    name: Mycelium Network System
    role: Complete mycelium network simulation
    dependencies:
      - hyphal-trait
      - transport-trait
      - evolution-types
    instructions: |
      Create complete mycelium network system combining all primitives.
      
      CREATE examples/stdlib/biology/mycelium.dol:
      
      ```dol
      // ═â════════════════════════════════════════════════════════════
      // Mycelium Network - Complete Fungal Network Simulation
      // ═══════════════════════════════════════════════════════════════
      
      module biology.mycelium @ 1.0.0
      
      use biols.{ Vec3, Gradient, Nutrient, Energy }
      use biology.hyphal.{ Hyphal, HyphalTip, HyphalSegment }
      use biology.transport.{ Transport, TransportNode, Flow }
      use biology.evolution.{ Evolvable, Fungus }
      
      /// Node in mycelium network
      pub gene MyceliumNode {
        has id: UInt64
        has position: Vec3
        has tips: List<HyphalTip>
        has stored_nutrients: Nutrient
        has connections: List<UInt64>  // Connected node IDs
        
        fun is_branching_point() -> Bool {
          return this.connections.len() > 2
        }
        
        fun is_tip() -> Bool {
          return this.connections.len() == 1
        }
        
        exegesis {
          A node in the mycelium network graph.
          Can be a tip (edge), relay (path), or junction (branch).
        }
      }
      
      /// Complete mycelium network
      pub system MyceliumNetwork {
        uses Hyphal
        uses Transport<Nutrient>
        uses Evolvable
        
        state nodes: Map<UInt64, MyceliumNode>
        state edges: List<HyphalSegment>
        state next_id: UInt64
        state total_biomass: Float64
        state generation: UInt64
        
        // ─────────────────────────────────────────────────────────────
        // Network Constraints
        // ───────────────────────────────────â───────────────────────
        
        constraint network_connected {
          // Network must be fully connected
          forall node1, node2 in this.nodes.values().
            exists_path(node1, node2)
        }
        
        constraint biomass_conservation {
          // Total biomass equals sum of node biomass
          this.total_biomass == 
            sum(this.nodes.values().map(|n| n.stored_nutrients.total_mass()))
        }
        
        constraint transport_capacity {
          // Transport limited by edge diameter
          forall edge in this.edges.
            edge.transport_capacity <= edge.diameter * 10.0
        }
        
        // ─────────────────────────────────────────────────────────────
        // Network Growth Functions
        // ─────────────────────────────────────────────────
        
        /// Initialize network from spore
        pub fun from_spore(position: Vec3) -> MyceliumNetwork {
          initial_tip = HyphalTip {
            position: position,
            direction: Vec3 { x: 0.0, y: 0.0, z: 1.0 },
            age: 0.0,
            branching_potential: 1.0,
            nutrients_absorbed: Nutrient.zero()
          }
          
          initial_node = MyceliumNode {
            id: 0,
            position: position,
            tips: [initial_tip],
            stored_nutrients: Nutrient.zero(),
            connections: []
          }
          
          return MyceliumNetwork {
            nodes: Map.from([(0, initial_node)]),
            edges: [],
            next_id: 1,
            total_biomass: 0.0,
            generation: 0
          }
        }
        
        /// Grow network one time step
        pub fun grow(nutrient_field: Gradient<Nutrient>) -> MyceliumNetwork {
          new_nodes = Map.new()
          new_edges = this.edges.clone()
          mut next_id = this.next_id
          
          for (id, node) in this.nodes {
            new_tips = []
            
            for tip in node.tips {
              // Extend tip toward nutrients
              extended = tip.extend(nutrient_field)
              
              // Check for branching
              if extended.branching_potential > 2.0 {
                branches = extended.branch(2.0)
                for branch in branches {
                  new_tips.push(branch)
                  // Create new node at branch point
                  new_node = MyceliumNode {
                    id: next_id,
                    position: branch.position,
                    tips: [branch],
                    stored_nutrients: Nutrient.zero(),
                    connections: [id]
                  }
                  new_nodes.insert(next_id, new_node)
                  
                  // Add edge
                  new_edges.push(HyphalSegment {
                    start: node.position,
                    end: branch.position,
                    diameter: 0.1,
                    transport_capacity: 1.0
                  })
                  
                  next_id += 1
                }
              } else {
                new_tips.push(extended)
              }
            }
            
            // Check for anastomosis (fusion)
            for other_id in this.find_nearby_nodes(node.position, 0.5) {
              if other_id != id && not node.connections.contains(other_id) {
                // Fuse networks
                node.connections.push(other_id)
                other_node = this.nodes.get(other_id)
                other_node.connections.push(id)
              }
            }
            
            new_nodes.insert(id, MyceliumNode {
              ...node,
              tips: new_tips
            })
          }
          
          return MyceliumNetwork {
            nodes: new_nodes,
            edges: new_edges,
            next_id: next_id,
            total_biomass: this.calculate_biomass(),
            generation: this.generation + 1
          }
        }
        
        /// Find nodes within distance
        fun find_nearby_nodes(pos: Vec3, max_dist: Float64) -> List<UInt64> {
          result = []
          for (id, node) in this.nodes {
            dx = pos.x - node.position.x
            dy = pos.y - node.position.y
            dz = pos.z - node.position.z
            dist = (dx * dx + dy * dy + dz * dz).sqrt()
            if dist <= max_dist {
              result.push(id)
            }
          }
          return result
        }
        
        /// Calculate total network biomass
        fun calculate_biomass() -> Float64 {
          node_mass = sum(this.nodes.values().map(|n| n.stored_nutrients.total_mass()))
          edge_mass = sum(this.edges.map(|e| e.length() * e.diameter * 0.1))
          return node_mass + edge_mass
        }
        
        /// Check if network is ready to fruit
        pub fun can_fruit() -> Bool {
          // Fruiting requires sufficient biomass and network complexity
          return this.total_biomass > 100.0 &&
                 this.nodes.len() > 50 &&
                 this.has_enough_branching_points()
        }
        
        fun has_enough_branching_points() -> Bool {
          branch_count = this.nodes.values()
            .filter(|n| n.is_branching_point())
            .len()
          return branch_count > 10
        }
        
        /// Visualize network as DOT graph
        pub fun to_dot() -> String {
          mut output = "digraph Mycelium {\n"
          
          for (id, node) in this.nodes {
            label = if node.is_tip() { "tip" } 
                   else if node.is_branching_point() { "branch" }
                   else { "relay" }
            output += "  " + id.to_string() + " [label=\"" + label + "\"];\n"
          }
          
          for edge in this.edges {
            // Find node IDs from positions (simplified)
            output += "  /* edge */\n"
          }
          
          output += "}\n"
          return output
        }
        
        exegesis {
          Complete mycelium network simulation.
          
          Biological behaviors modeled:
          - Hyphal tip extension toward nutrients
          - Branching at high-nutrient locations
          - Anastomosis (network fusion)
          - Nutrient transport through network
          - Fruiting body formation
          
          Applications:
          - Understanding fungal ecology
          - Bio-inspired network design
          - Distributed system architecture
          - Resource allocation algorithms
        }
      }
      ```
      
      FILE: ~/repos/metadol/examples/stdlib/biology/mycelium.dol

  # ─────────────────────────────────────────────────────────────────
  # Module Index and Tests
  # ──────────────────â──────────────────────────────────────
  bio-index:
    name: Biology Module Index
    role: Create module index and documentation
    dependencies:
      - mycelium-system
      - ecosystem-system
    instructions: |
      Create the biology module index.
      
      CREATE examples/stdlib/biology/mod.dol:
      
      ```dol
      // ═══════════════════════════════â══════════════════
      // DOL Biology Module - Modeling Systems of Life
      // ═══════════════════════════════════════════════════════════════
      
      module biology @ 1.0.0
      
      // Re-export all biology modules
      pub use types.*
      pub use hyphal.*
      pub use transport.*
      pub use ecosystem.*
      pub use evoluti
      pub use mycelium.*
      
      exegesis {
        The DOL Biology module provides primitives for modeling
        biological systems, inspired by mycelium networks and
        ecological dynamics.
        
        # Core Concepts
        
        ## Types (biology.types)
        - Vec3: Spatial positioning
        - Gradient<T>: Spatial fields
        - Nutrient: Elemental resources (C, N, P, H2O)
        - Energy: Trophic energy with quality
        - GeoTime: Geological time scale
        
        ## Hyphal Growth (biology.hyphal)
        - HyphalTip: Growing tip of hypha
        - HyphalSegment: Network edge
        - Hyphal trait: Growth behaviors
        
        ## Transport (biology.transport)
        - TransportNode<T>: Network node
        - Flow<T>: Resource flow
        - Transport<T> trait: Source-sink dynamics
        
        ## Ecosystem (biology.ecosystem)
        - Species: Population with dynamics
        - Interaction: Predator-prey
        - Ecosystem system: Full simulation
        
        ## Evolution (biology.evolution)
        - Trait: Heritable characteristic
        - Genome: Collection of traits
        - Evolvable trait: Evolution mechanics
        - evolves declarations: Speciation
        
        ## Mycelium Network (biology.mycelium)
        - MyceliumNode: Network node
        - MyceliumNetwork: Complete simulation
        
        # Usage
        
        ```dol
        use biology.{ MyceliumNetwork, Gradient, Nutrient }
        
        // Create network from spore
        network = MyceliumNetwork.from_spore(Vec3.origin())
        
        // Define nutrient field
        nutrients = Gradient<Nutrient> {
          origin: Vec3 { x: 10.0, y: 0.0, z: 0.0 },
          direction: Vec3 { x: -1.0, y: 0.0, z: 0.0 },
          intensity: Nutrient { carbon: 100.0, nitrogen: 10.0, phosphorus: 1.0, water: 50.0 },
          decay_rate: 0.1
        }
        
        // Grow network for 100 steps
        for _ in 0..100 {
          network = network.grow(nutrients)
        }
        
        // Check if ready to fruit
        if network.can_fruit() {
          println("Ready to produce mushrooms!")
        }
        ```
        
        # Philosophy
        
        DOL Biology enables modeling of living systems with:
        - Ontological precision (what things ARE)
        - Behavioral composition (what things DO)
        - Constraint validation (what things MUST satisfy)
        - Evolutionary tracking (how things CHANGE)
        
        This foundation supports understanding human ontological
        co-existence and building regenerative computing systems.
      }
      ```
      
      FILE: ~/repos/metadol/examples/stdlib/biology/mod.dol

  bio-tests:
    name: Biology Tests
    role: Write tests for biology module
    dependencies:
      - bio-index
    instructions: |
      Create comprehensive tests for the biology module.
      
      CREATE tests/biology_tests.rs:
      
      ```rust
      //! Tests for DOL biology module
      
      use metadol::parse;
      
      #[test]
      fn test_parse_nutrient_gene() {
          let source = include_str!("../examples/stdlib/biology/types.dol");
          let result = parse(source);
          assert!(result.is_ok(), "Failed to parse types.dol: {:?}", result.err());
      }
      
      #[test]
      fn test_parse_hyphal_trait() {
          let source = include_str!("../examples/stdlib/biology/hyphal.dol");
          let result = parse(source);
          assert!(result.is_ok(), "Failed to parse hyphal.dol: {:?}", result.err());
      }
      
      #[test]
      fn test_parse_transport_trait() {
          let source = include_str!("../examples/stdlib/biology/transport.dol");
          let result = parse(source);
          assert!(result.is_ok(), "Failed to parse transport.dol: {:?}", result.err());
      }
      
      #[test]
      fn test_parse_ecosystem_system() {
          let source = include_str!("../examples/stdlib/biology/ecosystem.dol");
          let result = parse(source);
          assert!(result.is_ok(), "Failed to parse ecosystem.dol: {:?}", result.err());
      }
      
      #[test]
      fn test_parse_evolution() {
          let source = include_str!("../examples/stdlib/biology/evolution.dol");
          let result = parse(source);
          assert!(result.is_ok(), "Failed to parse evolution.dol: {:?}", result.err());
      }
      
      #[test]
      fn test_parse_mycelium_network() {
          let source = include_str!("../examples/stdlib/biology/mycelium.dol");
          let result = parse(source);
          assert!(result.is_ok(), "Failed to parse mycelium.dol: {:?}", result.err());
      }
      
      #[test]
      fn test_nutrient_constraint() {
          let source = r#"
              gene TestNutrient {
                  has carbon: Float64 = 70.0
                  has nitrogen: Float64 = 10.0
                  has phosphorus: Float64 = 1.0
                  has water: Float64 = 20.0
                  
                  constraint stoichiometry {
                      // C:N ratio between 6-10
                      this.carbon / this.nitrogen >= 6.0 &&
                      this.carbon / this.nitrogen <= 10.0
                  }
              }
          "#;
          let result = parse(source);
          assert!(result.is_ok());
      }
      
      #[test]
      fn test_evolves_syntax() {
          let source = r#"
              gene Organism {
                  has id: UInt64
              }
              
              evolves Organism > Prokaryote @ 3.5Gya {
                  added cell_wall: Bool = true
                  
                  migrate from Organism {
                      return Prokaryote {
                          id: old.id,
                          cell_wall: true
                      }
                  }
              }
          "#;
          let result = parse(source);
          assert!(result.is_ok(), "Failed to parse evolves: {:?}", result.err());
      }
      
      #[test]
      fn test_ecosystem_constraints() {
          let source = r#"
              system TestEcosystem {
                  state population: UInt64
                  state carrying_capacity: UInt64
                  
                  constraint population_limit {
                      this.population <= this.carrying_capacity
                  }
              }
          "#;
          let result = parse(source);
          assert!(result.is_ok());
      }
      ```
      
      FILE: ~/repos/metadol/tests/biology_tests.rs

# ══════════════════════════════â══════════════════════
# WORKFLOWS
# ═══════════════════════════════════════════════════════════════════

workflows:
  biomimicry-full:
    name: Full Biomimicry Implementation
    description: Implement all biological modeling primitives
    stages:
      - name: foundation
        description: Core biological types
        agen          - bio-types
          
      - name: growth-patterns
        description: Hyphal growth and transport
        agents:
          - hyphal-trait
          - transport-trait
        depends_on:
          - foundation
          
      - name: dynamics
        description: Ecosystem and evolution
        agents:
          - ecosystem-system
          - evolution-types
        depends_on:
          - foundation
          
      - name: integration
        description: Complete mycelium network
        agents:
          - mycelium-system
        depends_on:
          - growth-patterns
          - dynamics
          
      - name: finalize
        description: Index and tests
        agents:
          - bio-index
          - bio-tests
        depends_on:
          - integration

  types-only:
    name: Types Only
    stages:
      - name: types
        agents: [bio-types]

  mycelium-only:
    name: Mycelium Network Only
    stages:
      - name: mycelium
        agents: [bio-types, hyphal-trait, transport-trait, mycelium-system]

  ecosystem-only:
    name: Ecosystem Only
    stages:
      - name: ecosystem
        agents: [bio-types, ecosystem-system]

# ═══════════════════════════════════════════════════════════════════
# CHECKPOINTS
# ═══════════════════════════════════════════════════════════════

checkpoints:
  types-complete:
    trigger: file_exists
    path: examples/stdlib/biology/types.dol
    message: "Biological types defined"

  traits-complete:
    trigger: file_exists
    path: examples/stdlib/biology/hyphal.dol
    message: "Hyphal and transport traits defined"

  systems-complete:
    trigger: file_exists
    path: examples/stdlib/biology/mycelium.dol
    message: "Mycelium network system complete"

  tests-pass:
    trigger: command_success
    command: "cargo test biology"
    message: "All biology tests passing"

  biomimicry-complete:
    trigger: all_checkpoints
    checkpoints:
      - types-complete
      - traits-complete
      - systems-complete
      - tests-pass
    message: |
      ═══════════════════════════════════════════════════════════════
      BIOMIMICRY MODELING COMPLETE
      
      Implemented:
iological types (Vec3, Nutrient, Energy, GeoTime)
      - Hyphal trait for mycelium growth
      - Transport trait for source-sink dynamics
      - Ecosystem system with Lotka-Volterra dynamics
      - Evolution primitives using DOL's evolves keyword
      - Complete MyceliumNetwork simulation
      
      DOL can now model:
      - Mycelium/fungal networks
      - Ecosystem population dynamics
      - Evolutionary speciation
      - Resource transport networks
      - Regenerative ecological patterns
      
      "From ontology to ecology, from specification to life."
      ═══════════════════════════════════════════════════════════════
