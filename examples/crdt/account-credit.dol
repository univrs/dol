// DOL CRDT Example: Mutual Credit Account with Escrow
// Demonstrates: pn_counter strategy and escrow pattern for strong consistency

gen account.mutual_credit {
  // Immutable identity
  @crdt(immutable)
  id: Uuid

  @crdt(immutable)
  owner: Identity

  @crdt(immutable)
  created_at: Timestamp

  // PN-Counter: Positive-Negative Counter for numeric operations
  // confirmed_balance: Strong consistency via BFT reconciliation
  @crdt(pn_counter, min_value=0)
  confirmed_balance: Int

  // local_escrow: Pre-allocated for offline spending (LWW for simplicity)
  @crdt(lww, min_value=0)
  local_escrow: Int

  // pending_credits: Eventually consistent incoming credits
  @crdt(pn_counter)
  pending_credits: Int

  // Transaction history (OR-Set for add-wins)
  @crdt(or_set)
  transaction_history: Set<TransactionRef>

  // Reputation tier determines escrow allocation limits
  @crdt(lww)
  reputation_tier: ReputationTier

  // Statistics (PN-Counters for additive metrics)
  @crdt(pn_counter, min_value=0)
  total_sent: Int

  @crdt(pn_counter, min_value=0)
  total_received: Int
}

gen transfer.mutual_credit {
  @crdt(immutable)
  id: Uuid

  @crdt(immutable)
  from: AccountId

  @crdt(immutable)
  to: AccountId

  @crdt(immutable)
  amount: Int

  @crdt(immutable)
  timestamp: Timestamp

  @crdt(lww)
  status: TransferStatus  // pending | confirmed | rejected
}

constraint account.solvency {
  confirmed_balance always >= 0
  local_escrow always >= 0
  local_escrow always <= confirmed_balance
}

constraint account.double_spend_prevention {
  account never spends_more_than local_escrow
  all transactions are atomic
}

constraint transfer.immutability {
  transfer never changes from
  transfer never changes to
  transfer never changes amount
}

docs {
  Mutual credit account demonstrating PN-Counter CRDT and the escrow pattern
  for achieving strong consistency under eventual consistency architecture.

  **PN-Counter Strategy (confirmed_balance, pending_credits):**

  - Each actor maintains separate increment/decrement counters
  - Value = sum(all increments) - sum(all decrements)
  - Merge: Take pointwise maximum of each actor's counters
  - Commutative, associative, idempotent → Strong Eventual Consistency

  **Architecture:**

  1. **confirmed_balance** (Strong Consistency Layer):
     - Maintained by BFT committee (3f+1 nodes, tolerates f Byzantine faults)
     - Updated during periodic reconciliation
     - Source of truth for escrow allocation

  2. **local_escrow** (Offline Operation Layer):
     - Pre-allocated from confirmed_balance
     - Enables immediate offline spending (no network required)
     - Spend operations decrement escrow (local check only)
     - Prevents double-spend via local allocation limit

  3. **pending_credits** (Eventually Consistent Layer):
     - Incoming credits from other accounts
     - Merged via PN-Counter CRDT (no coordination)
     - Converted to confirmed_balance during BFT reconciliation

  **Double-Spend Prevention:**

  Problem: In pure CRDT, concurrent spends can overdraft account:
    Replica A: balance=100, spend 80 → balance=20
    Replica B: balance=100, spend 70 → balance=30
    After merge: balance=-50 ❌

  Solution: Escrow allocation
    1. BFT committee allocates escrow to each device (e.g., 50 each)
    2. Local spend: Check (amount <= local_escrow) → reject if false
    3. Deduct from escrow immediately (no coordination)
    4. Periodic reconciliation: BFT confirms all escrows, allocates new

  Invariant: sum(all_escrows) <= confirmed_balance (maintained by BFT)
  Local check: spend <= local_escrow
  Therefore: total_spent <= confirmed_balance (no double-spend)

  **Example Operations:**

  // Create account (online, requires BFT)
  let account = create_account(user_id, initial_balance=100);

  // Allocate escrow (online, requires BFT consensus)
  bft.allocate_escrow(account.id, device_a=50, device_b=50);

  // Spend offline on device A (immediate, no network)
  if account.local_escrow >= 40 {
      account.spend_from_escrow(40);  // ✅ Succeeds
      account.local_escrow -= 40;     // Now 10 remaining
  }

  // Concurrent spend offline on device B (immediate, no network)
  if account.local_escrow >= 50 {
      account.spend_from_escrow(50);  // ✅ Succeeds
      account.local_escrow -= 50;     // Now 0 remaining
  }

  // Attempt overdraft on device A (immediate rejection)
  if account.local_escrow >= 20 {
      account.spend_from_escrow(20);  // ❌ Rejected (10 < 20)
  }

  // Receive credit from another account (CRDT merge, no coordination)
  account.pending_credits += 50;  // PN-Counter increment

  // Periodic BFT reconciliation (online)
  if online && time_for_reconciliation() {
      let result = bft.reconcile([account.id]);
      if result.confirmed {
          // Commit pending credits to confirmed balance
          account.confirmed_balance += account.pending_credits;
          account.pending_credits = 0;

          // Allocate fresh escrow based on reputation tier
          let new_escrow = calculate_escrow(
              account.confirmed_balance,
              account.reputation_tier
          );
          account.local_escrow = new_escrow;
      }
  }

  **Constraint Enforcement:**

  - Solvency (confirmed_balance >= 0): Category B (eventually consistent)
    - May be temporarily violated during network partition
    - BFT reconciliation resolves violations
    - Reputation tier lowered if violations persist

  - Double-spend prevention: Category C (strong consistency via escrow)
    - Prevented by escrow allocation (local check before spend)
    - BFT verifies escrow validity during reconciliation
    - Mathematical proof: total_spent <= sum(escrows) <= confirmed_balance

  **Reputation Tier System:**

  - `tier1` (trusted): Escrow = 80% of confirmed_balance
  - `tier2` (good): Escrow = 50% of confirmed_balance
  - `tier3` (new): Escrow = 20% of confirmed_balance
  - `tier4` (flagged): Escrow = 0% (all operations require BFT approval)

  Reputation increases with:
  - Consistent reconciliation participation
  - Accurate credit repayment
  - Low overdraft attempts

  Reputation decreases with:
  - Overdraft attempts beyond escrow
  - Delayed reconciliation
  - Double-spend detection (Byzantine behavior)

  **Performance:**

  - Local spend: < 1ms (no network)
  - CRDT merge (pending_credits): < 10ms
  - BFT reconciliation: < 5 seconds for confirmation
  - Escrow reallocation: Once per reconciliation cycle (e.g., daily)

  This architecture achieves:
  - Offline operation (spend from escrow with no network)
  - Strong consistency (double-spend prevention via escrow)
  - Eventual consistency (CRDT for pending credits)
  - Byzantine fault tolerance (BFT for critical operations)
}
