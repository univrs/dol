// DOL CRDT Example: Application Configuration
// Demonstrates: mv_register (Multi-Value Register) strategy

gen config.app {
  @crdt(immutable)
  app_id: Uuid

  @crdt(immutable)
  version: Version

  // MV-Register: Keeps all concurrent values until explicitly resolved
  @crdt(mv_register)
  theme: Theme  // light | dark | auto | custom

  @crdt(mv_register)
  language: Language

  @crdt(mv_register)
  timezone: Timezone

  // LWW for simple preferences
  @crdt(lww)
  notifications_enabled: Bool

  @crdt(lww)
  sync_enabled: Bool

  // OR-Set for feature flags
  @crdt(or_set)
  enabled_features: Set<FeatureFlag>

  // PN-Counter for usage metrics
  @crdt(pn_counter, min_value=0)
  launch_count: Int
}

gen theme.custom {
  @crdt(immutable)
  id: Uuid

  @crdt(lww)
  name: String

  @crdt(mv_register)
  primary_color: Color

  @crdt(mv_register)
  secondary_color: Color

  @crdt(mv_register)
  background_color: Color

  @crdt(mv_register)
  font_family: String
}

gen merge_policy.theme {
  strategy: MergeStrategy  // ai_suggest | user_choose | latest | union
}

constraint config.theme_consistency {
  theme is valid_theme
  custom_theme has all_colors_defined
}

docs {
  Application configuration demonstrating MV-Register (Multi-Value Register)
  CRDT strategy for detecting and resolving concurrent conflicts.

  **MV-Register Strategy:**

  Unlike LWW (which loses concurrent updates), MV-Register keeps ALL
  concurrent values until explicitly resolved by application logic.

  **Data Structure:**

  ```rust
  struct MVRegister<T> {
      values: Map<VectorClock, T>,
  }
  ```

  Each value associated with vector clock tracking causality.

  **Merge Algorithm:**

  1. Union all (clock, value) pairs from both replicas
  2. Remove causally dominated values:
     - If clock1 ≤ clock2 (all components ≤), remove (clock1, value1)
  3. Keep only maximal (non-dominated) values

  **Example: Concurrent Theme Changes**

  Initial state (both replicas):
  ```
  theme = "light" @ [A:1, B:1, C:1]
  ```

  Concurrent operations:
  - User A (on device A): Set theme = "dark"
    ```
    VectorClock: [A:2, B:1, C:1]
    value: "dark"
    ```

  - User B (on device B): Set theme = "custom_ocean"
    ```
    VectorClock: [A:1, B:2, C:1]
    value: "custom_ocean"
    ```

  Neither clock dominates the other (A:2 > A:1 but B:1 < B:2), so both
  values are concurrent.

  After merge:
  ```
  theme = MVRegister {
      [A:2, B:1, C:1]: "dark",
      [A:1, B:2, C:1]: "custom_ocean"
  }
  ```

  **Conflict detected!** Application must resolve.

  **Resolution Strategies:**

  1. **User Choose**: Prompt user to pick one
     ```
     UI: "Theme conflict detected. Choose:
          • Dark (set on Desktop at 2:45 PM)
          • Custom Ocean (set on Mobile at 2:47 PM)"
     ```

  2. **Latest Timestamp**: Use wall-clock time (not causal)
     ```
     Prefer value with latest timestamp.
     Note: Requires synchronized clocks (less reliable than causal).
     ```

  3. **AI Suggest**: Machine learning predicts preference
     ```
     Analyze user's recent theme choices, time of day, device type.
     Suggest most likely intended theme.
     ```

  4. **Union**: Combine values if possible
     ```
     For colors: Blend both colors
     For strings: Concatenate or create variant
     Not always meaningful (e.g., theme names)
     ```

  5. **Default to Known Value**: Use system default
     ```
     If conflict unresolvable, revert to "light" theme.
     ```

  **Example: Resolution with AI Suggest**

  ```rust
  let config = ConfigApp::load();

  if let Conflict::Detected(values) = config.theme.get() {
      // MV-Register detected multiple concurrent values
      let suggestions = ai_resolver.suggest(&values, &context);

      match suggestions.confidence {
          High => {
              // Auto-resolve with AI suggestion
              config.theme.resolve(suggestions.preferred_value);
          }
          Medium | Low => {
              // Ask user to confirm
              ui.show_conflict_dialog(values, suggestions);
          }
      }
  } else {
      // No conflict, single value
      let theme = config.theme.get().unwrap();
      apply_theme(theme);
  }
  ```

  **Context for AI Resolution:**

  ```rust
  struct ResolutionContext {
      user_history: Vec<ThemeChoice>,  // Past theme preferences
      time_of_day: TimeOfDay,          // Light theme during day?
      device_type: DeviceType,         // Desktop vs mobile preferences?
      location: Location,              // Indoor vs outdoor (ambient light)?
  }
  ```

  **Example: Custom Theme Conflicts**

  Concurrent color changes to custom theme:

  ```
  Replica A: Set primary_color = "blue"   @ [A:5, B:3]
  Replica B: Set primary_color = "green"  @ [A:4, B:4]

  After merge:
  primary_color = MVRegister {
      [A:5, B:3]: "blue",
      [A:4, B:4]: "green"
  }
  ```

  Resolution: Blend colors
  ```
  blended_color = blend(blue, green) = teal
  config.theme.primary_color.resolve(teal)
  ```

  User sees teal theme, can adjust if not desired.

  **Use Cases for MV-Register:**

  1. **Configuration Conflicts**: User changes settings on multiple devices
  2. **Preference Synchronization**: Detect divergent preferences
  3. **Schema Flexibility**: Allow multiple interpretations during migration
  4. **Debugging**: Inspect all concurrent operations for troubleshooting

  **When NOT to Use MV-Register:**

  - High-frequency updates: Conflict detection overhead
  - Clear winner semantics: Use LWW instead
  - Collaborative editing: Use Peritext or RGA (more specialized)

  **Performance Considerations:**

  - Space: O(k) where k = number of concurrent values
  - Merge: O(k²) (pairwise clock comparison to find dominated values)
  - Query: O(k) (return all maximal values)

  Typical k is small (1-3 values), so overhead acceptable.

  **Garbage Collection:**

  After resolution:
  ```rust
  config.theme.resolve("dark");  // User chose "dark"
  ```

  MVRegister discards other values, keeps only resolved value with new
  vector clock dominating all previous clocks:
  ```
  theme = "dark" @ [A:6, B:5, C:3]
  ```

  This becomes new causal baseline for future operations.

  **Comparison with LWW:**

  LWW (Last-Write-Wins):
  - Loses concurrent values (only keeps latest by timestamp)
  - Simple, efficient, no conflicts
  - Use for: Single-valued fields where losing updates is acceptable

  MV-Register:
  - Keeps all concurrent values (detects conflicts)
  - Requires resolution logic
  - Use for: Critical settings where user should choose

  **Integration with DOL Constraints:**

  MV-Register fits Category B (eventually-consistent constraints):

  ```
  constraint config.theme_consistency {
      theme is valid_theme
  }
  ```

  During conflict:
  - Constraint may be temporarily "ambiguous" (multiple values)
  - After resolution, constraint checked on resolved value
  - If resolution violates constraint, reject and prompt user

  **Example: Theme Validation**

  ```rust
  let themes = config.theme.get_all();  // Get all concurrent values

  // Validate each concurrent value
  for theme in themes {
      if !is_valid_theme(theme) {
          // Remove invalid value
          config.theme.discard(theme);
      }
  }

  // If only one valid value remains, auto-resolve
  if config.theme.get_all().len() == 1 {
      config.theme.resolve(config.theme.get_all()[0]);
  }
  ```

  **Offline Behavior:**

  1. User A changes theme to "dark" on laptop (offline)
  2. User B changes theme to "custom" on phone (offline)
  3. Both devices come online, sync
  4. MV-Register detects conflict
  5. Application resolves (AI suggest or user prompt)
  6. Resolved value syncs to both devices

  No data loss, user always in control.

  **Formal Properties:**

  - **Commutativity**: merge(A, B) = merge(B, A)
  - **Associativity**: merge(merge(A, B), C) = merge(A, merge(B, C))
  - **Idempotency**: merge(A, A) = A
  - **Causality Preservation**: Dominated values discarded
  - **Strong Eventual Consistency**: All replicas converge to same set of
    maximal values

  MV-Register is a CvRDT (Convergent Replicated Data Type).
}
