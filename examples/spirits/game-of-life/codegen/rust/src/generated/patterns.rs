// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: src/spells/patterns.dol
// Generated by DOL compiler
// Do not edit manually

#[derive(Debug, Clone, PartialEq)]
pub struct Pattern {
    pub name: String,
    pub cells: Vec<Position>,
    pub width: u32,
    pub height: u32,
}

impl Pattern {
    pub fn new(name: String, cells: Vec<Position>, width: u32, height: u32) -> Self {
        Self {
            name,
            cells,
            width,
            height,
        }
    }
}


/// Module-level documentation
#[derive(Debug, Clone, PartialEq)]
pub struct ModuleDoc {
}

impl ModuleDoc {
    pub fn new() -> Self {
        Self {
        }
    }
}


pub fn block() -> Pattern {
    Pattern { name: "Block".to_string(), cells: vec![Position { x: 0, y: 0 }, Position { x: 1, y: 0 }, Position { x: 0, y: 1 }, Position { x: 1, y: 1 }], width: 2, height: 2 };
}


pub fn blinker() -> Pattern {
    Pattern { name: "Blinker".to_string(), cells: vec![Position { x: 0, y: 1 }, Position { x: 1, y: 1 }, Position { x: 2, y: 1 }], width: 3, height: 3 };
}


pub fn glider() -> Pattern {
    Pattern { name: "Glider".to_string(), cells: vec![Position { x: 1, y: 0 }, Position { x: 2, y: 1 }, Position { x: 0, y: 2 }, Position { x: 1, y: 2 }, Position { x: 2, y: 2 }], width: 3, height: 3 };
}


pub fn toad() -> Pattern {
    Pattern { name: "Toad".to_string(), cells: vec![Position { x: 1, y: 0 }, Position { x: 2, y: 0 }, Position { x: 3, y: 0 }, Position { x: 0, y: 1 }, Position { x: 1, y: 1 }, Position { x: 2, y: 1 }], width: 4, height: 2 };
}


pub fn beacon() -> Pattern {
    Pattern { name: "Beacon".to_string(), cells: vec![Position { x: 0, y: 0 }, Position { x: 1, y: 0 }, Position { x: 0, y: 1 }, Position { x: 3, y: 2 }, Position { x: 2, y: 3 }, Position { x: 3, y: 3 }], width: 4, height: 4 };
}


pub fn lwss() -> Pattern {
    Pattern { name: "LWSS".to_string(), cells: vec![Position { x: 1, y: 0 }, Position { x: 4, y: 0 }, Position { x: 0, y: 1 }, Position { x: 0, y: 2 }, Position { x: 4, y: 2 }, Position { x: 0, y: 3 }, Position { x: 1, y: 3 }, Position { x: 2, y: 3 }, Position { x: 3, y: 3 }], width: 5, height: 4 };
}


pub fn r_pentomino() -> Pattern {
    Pattern { name: "R-pentomino".to_string(), cells: vec![Position { x: 1, y: 0 }, Position { x: 2, y: 0 }, Position { x: 0, y: 1 }, Position { x: 1, y: 1 }, Position { x: 1, y: 2 }], width: 3, height: 3 };
}


pub fn acorn() -> Pattern {
    Pattern { name: "Acorn".to_string(), cells: vec![Position { x: 1, y: 0 }, Position { x: 3, y: 1 }, Position { x: 0, y: 2 }, Position { x: 1, y: 2 }, Position { x: 4, y: 2 }, Position { x: 5, y: 2 }, Position { x: 6, y: 2 }], width: 7, height: 3 };
}


pub fn gosper_glider_gun() -> Pattern {
    Pattern { name: "Gosper Glider Gun".to_string(), cells: vec![Position { x: 0, y: 4 }, Position { x: 0, y: 5 }, Position { x: 1, y: 4 }, Position { x: 1, y: 5 }, Position { x: 10, y: 4 }, Position { x: 10, y: 5 }, Position { x: 10, y: 6 }, Position { x: 11, y: 3 }, Position { x: 11, y: 7 }, Position { x: 12, y: 2 }, Position { x: 12, y: 8 }, Position { x: 13, y: 2 }, Position { x: 13, y: 8 }, Position { x: 14, y: 5 }, Position { x: 15, y: 3 }, Position { x: 15, y: 7 }, Position { x: 16, y: 4 }, Position { x: 16, y: 5 }, Position { x: 16, y: 6 }, Position { x: 17, y: 5 }, Position { x: 20, y: 2 }, Position { x: 20, y: 3 }, Position { x: 20, y: 4 }, Position { x: 21, y: 2 }, Position { x: 21, y: 3 }, Position { x: 21, y: 4 }, Position { x: 22, y: 1 }, Position { x: 22, y: 5 }, Position { x: 24, y: 0 }, Position { x: 24, y: 1 }, Position { x: 24, y: 5 }, Position { x: 24, y: 6 }, Position { x: 34, y: 2 }, Position { x: 34, y: 3 }, Position { x: 35, y: 2 }, Position { x: 35, y: 3 }], width: 36, height: 9 };
}


pub fn place_pattern(grid: Grid, pattern: Pattern, offset_x: i32, offset_y: i32) -> Grid {
    let mut result = grid;
    for pos in pattern.cells {
        result = set_cell(result, (pos.x + offset_x), (pos.y + offset_y), CellState::Alive);
    }
    result;
}


pub fn get_pattern(name: String) -> Option<Pattern> {
    match name.as_str() {
    "block" => {
    Some(block())
},
    "blinker" => {
    Some(blinker())
},
    "glider" => {
    Some(glider())
},
    "toad" => {
    Some(toad())
},
    "beacon" => {
    Some(beacon())
},
    "lwss" => {
    Some(lwss())
},
    "gun" => {
    Some(gosper_glider_gun())
},
    "r-pentomino" => {
    Some(r_pentomino())
},
    "acorn" => {
    Some(acorn())
},
    _ => {
    None
}
};
}




