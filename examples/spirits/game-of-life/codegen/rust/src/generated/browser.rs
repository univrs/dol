// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: /home/ardeshir/repos/univrs-dol/examples/spirits/game-of-life/src/effects/browser.dol
// Generated by DOL compiler
// Do not edit manually

use std::cell::RefCell;

thread_local! {
    static GRID: RefCell<Option<Grid>> = RefCell::new(None);
    static CONFIG: RefCell<GridConfig> = RefCell::new(GridConfig { width: 100, height: 100, wrap_edges: true });
}

/// Module-level documentation
#[derive(Debug, Clone, PartialEq)]
pub struct ModuleDoc {
}

impl ModuleDoc {
    pub fn new() -> Self {
        Self {
        }
    }
}


#[wasm_bindgen]
pub fn init(width: u32, height: u32, wrap: bool) {
    CONFIG.with(|__v| *__v.borrow_mut() = GridConfig { width: width, height: height, wrap_edges: wrap });
    GRID.with(|__v| *__v.borrow_mut() = Some(create_grid(CONFIG.with(|__v| __v.borrow().clone()))));
}


#[wasm_bindgen]
pub fn reset() {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    GRID.with(|__v| *__v.borrow_mut() = Some(clear(grid)));
},
    None => {
}
};
}


#[wasm_bindgen]
pub fn step() -> u64 {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    let mut next = tick(grid);
    GRID.with(|__v| *__v.borrow_mut() = Some(next));
    next.generation
},
    None => {
    0
}
};
}


#[wasm_bindgen]
pub fn set_cell_state(x: i32, y: i32, alive: bool) {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    GRID.with(|__v| *__v.borrow_mut() = Some(set_cell(grid, x, y, if alive {
    CellState::Alive
} else {
    CellState::Dead
})));
},
    None => {
}
};
}


#[wasm_bindgen]
pub fn toggle_cell(x: i32, y: i32) {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    match spells::grid_ops::get_cell(grid, x, y) {
    Some(cell) => {
    let mut new_state = if (cell.state == CellState::Alive) {
    CellState::Dead
} else {
    CellState::Alive
};
    GRID.with(|__v| *__v.borrow_mut() = Some(set_cell(grid, x, y, new_state)));
},
    None => {
}
}
},
    None => {
}
};
}


#[wasm_bindgen]
pub fn load_pattern(name: String, x: i32, y: i32) -> bool {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    match get_pattern(name) {
    Some(pattern) => {
    GRID.with(|__v| *__v.borrow_mut() = Some(place_pattern(grid, pattern, x, y)));
    true
},
    None => {
    false
}
}
},
    None => {
    false
}
};
}


#[wasm_bindgen]
pub fn randomize_grid(density: f64) {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    GRID.with(|__v| *__v.borrow_mut() = Some(spells::grid_ops::randomize(grid, density)));
},
    None => {
}
};
}


#[wasm_bindgen]
pub fn get_generation() -> u64 {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    grid.generation
},
    None => {
    0
}
};
}


#[wasm_bindgen]
pub fn get_width() -> u32 {
    CONFIG.with(|__v| __v.borrow().width);
}


#[wasm_bindgen]
pub fn get_height() -> u32 {
    CONFIG.with(|__v| __v.borrow().height);
}


#[wasm_bindgen]
pub fn get_alive_count() -> u64 {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    genes::grid::alive_count(grid)
},
    None => {
    0
}
};
}


#[wasm_bindgen]
pub fn get_cells() -> Vec<u8> {
    match GRID.with(|__v| __v.borrow().clone()) {
    Some(grid) => {
    map(|c| { if (c.state == CellState::Alive) {
    1
} else {
    0
} })(grid.cells)
},
    None => {
    vec![]
}
};
}




