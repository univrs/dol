// Generated by dol-codegen from Metal DOL declarations
// Do not edit manually - regenerate from source .dol files

// Source: src/spells/grid_ops.dol
// Generated by DOL compiler
// Do not edit manually

/// Module-level documentation
#[derive(Debug, Clone, PartialEq)]
pub struct ModuleDoc {
}

impl ModuleDoc {
    pub fn new() -> Self {
        Self {
        }
    }
}


pub fn create_grid(config: GridConfig) -> Grid {
    let mut cells: Vec<Cell> = vec![];
    for y in (0 .. config.height) {
        for x in (0 .. config.width) {
            cells = cells.push(dead_cell(x as i32, y as i32));
        }
    }
    Grid { width: config.width, height: config.height, cells: cells, generation: 0, wrap_edges: config.wrap_edges };
}


pub fn wrap_coord(v: i32, max: u32) -> i32 {
    (((v % max as i32) + max as i32) % max as i32);
}


pub fn to_index(grid: Grid, x: i32, y: i32) -> Option<u64> {
    let mut ax = if grid.wrap_edges {
    wrap_coord(x, grid.width)
} else {
    x
};
    let mut ay = if grid.wrap_edges {
    wrap_coord(y, grid.height)
} else {
    y
};
    if ((ax < 0) || ((ay < 0) || ((ax >= grid.width as i32) || (ay >= grid.height as i32)))) {
    None
} else {
    Some(((ay as u64 * grid.width as u64) + ax as u64))
};
}


pub fn get_cell(grid: Grid, x: i32, y: i32) -> Option<Cell> {
    match to_index(grid, x, y) {
    Some(idx) => {
    Some(grid.cells(idx))
},
    None => {
    None
}
};
}


pub fn set_cell(grid: Grid, x: i32, y: i32, state: CellState) -> Grid {
    match to_index(grid, x, y) {
    Some(idx) => {
    let mut new_cells = grid::cells::update(idx, |c| { Cell { pos: c.pos, state: state, neighbors: c.neighbors } });
    Grid { width: grid.width, height: grid.height, cells: new_cells, generation: grid.generation, wrap_edges: grid.wrap_edges }
},
    None => {
    grid
}
};
}


pub fn count_neighbors(grid: Grid, x: i32, y: i32) -> u8 {
    let mut count: u8 = 0;
    for dx in (-1 .. 2) {
        for dy in (-1 .. 2) {
            if ((dx != 0) || (dy != 0)) {
    match get_cell(grid, (x + dx), (y + dy)) {
    Some(cell) => {
    if (cell.state == CellState::Alive) {
    count = (count + 1);
};
},
    None => {
}
}
};
        }
    }
    count;
}


pub fn tick(grid: Grid) -> Grid {
    let mut with_neighbors = map(|c| { Cell { pos: c.pos, state: c.state, neighbors: count_neighbors(grid, c::pos::x, c::pos::y) } })(grid.cells);
    let mut next_cells = map(|c| { Cell { pos: c.pos, state: next_state(c), neighbors: 0 } })(with_neighbors);
    Grid { width: grid.width, height: grid.height, cells: next_cells, generation: (grid.generation + 1), wrap_edges: grid.wrap_edges };
}


pub fn clear(grid: Grid) -> Grid {
    let mut new_cells = map(|c| { Cell { pos: c.pos, state: CellState::Dead, neighbors: 0 } })(grid.cells);
    Grid { width: grid.width, height: grid.height, cells: new_cells, generation: 0, wrap_edges: grid.wrap_edges };
}


pub fn randomize(grid: Grid, density: f64) -> Grid {
    let mut seed = ((grid.generation * 12345) + 67890);
    let mut new_cells = map(|c| { {
    seed = (((seed * 1103515245) + 12345) % 2147483648);
    let mut random = (seed as f64 / 2147483648.0);
    Cell { pos: c.pos, state: if (random < density) {
    CellState::Alive
} else {
    CellState::Dead
}, neighbors: 0 }
} })(grid.cells);
    Grid { width: grid.width, height: grid.height, cells: new_cells, generation: 0, wrap_edges: grid.wrap_edges };
}




