// =============================================================================
// Chemistry Spirit - Molecular Structures Module
// DOL v0.9.0
// =============================================================================

module chemistry.molecules @ 0.9.0

docs {
    Molecular structures module providing atom, bond, and molecule types.

    This module models:
    - Atoms with charges and bonding
    - Chemical bonds (single, double, triple, ionic)
    - Molecular structures with 3D geometry
    - Orbital hybridization and electron distribution
    - Molecular properties (polarity, aromaticity, etc.)

    All calculations use SI units unless otherwise specified.
}

use local::lib::AVOGADRO
use local::lib::BOHR_RADIUS
use local::elements::Element
use local::elements::is_metal
use local::elements::electronegativity

// =============================================================================
// CORE TYPES
// =============================================================================

docs {
    3D position vector in Angstroms.
}

pub gen Position3D {
    has x: f64
    has y: f64
    has z: f64
}

docs {
    Atomic orbital with quantum numbers and electron occupancy.

    Properties:
    - n: Principal quantum number (shell)
    - l: Angular momentum quantum number (subshell: s=0, p=1, d=2, f=3)
    - ml: Magnetic quantum number (-l to +l)
    - orbital_type: string representation (1s, 2p, 3d, etc.)
    - energy: Orbital energy (eV)
    - electrons: Number of electrons in orbital (0, 1, or 2)
}

pub gen Orbital {
    has n: u8
    has l: u8
    has ml: i8
    has orbital_type: string
    has energy: f64
    has electrons: u8
    has is_bonding: bool
    has is_antibonding: bool
}

docs {
    Hybridization state of an atom in a molecule.
}

pub gen Hybridization {
    has orbital_type: string
    has geometry: string
    has bond_angle: f64
    has sigma_orbitals: u8
    has pi_orbitals: u8
    has lone_pairs: u8
}

docs {
    Atom in a molecular context with charge and bonding information.

    Properties:
    - element: The chemical element
    - charge: Formal charge on the atom
    - position: 3D position in the molecule
    - bonds: Indices of bonds this atom participates in
    - hybridization: sp, sp2, sp3, etc.
    - lone_pairs: Number of lone electron pairs
    - is_chiral_center: Whether this is a stereogenic center
}

pub gen Atom {
    has element: Element
    has charge: i8
    has position: Position3D
    has bond_indices: Vec<u32>
    has hybridization: Hybridization
    has lone_pairs: u8
    has is_chiral_center: bool
    has partial_charge: f64
}

docs {
    Bond type enumeration.
}

pub gen BondType {
    has order: u8
    has name: string
    has is_aromatic: bool
}

docs {
    Create a single bond.
}

pub fun single_bond() -> BondType {
    return BondType { order: 1, name: "single", is_aromatic: false }
}

docs {
    Create a double bond.
}

pub fun double_bond() -> BondType {
    return BondType { order: 2, name: "double", is_aromatic: false }
}

docs {
    Create a triple bond.
}

pub fun triple_bond() -> BondType {
    return BondType { order: 3, name: "triple", is_aromatic: false }
}

docs {
    Create an aromatic bond.
}

pub fun aromatic_bond() -> BondType {
    return BondType { order: 1, name: "aromatic", is_aromatic: true }
}

docs {
    Chemical bond between two atoms.

    Properties:
    - atom1_idx: Index of first atom
    - atom2_idx: Index of second atom
    - bond_type: Single, double, triple, or aromatic
    - length: Bond length in Angstroms
    - energy: Bond dissociation energy in kJ/mol
    - dipole: Bond dipole moment (Debye)
    - is_rotatable: Whether rotation around bond is free
}

pub gen Bond {
    has atom1_idx: u32
    has atom2_idx: u32
    has bond_type: BondType
    has length: f64
    has energy: f64
    has dipole: f64
    has is_rotatable: bool
}

docs {
    Molecular orbital resulting from atomic orbital combinations.
}

pub gen MolecularOrbital {
    has name: string
    has energy: f64
    has electrons: u8
    has is_bonding: bool
    has is_antibonding: bool
    has is_nonbonding: bool
    has contributing_atoms: Vec<u32>
}

docs {
    Ring structure in a molecule.
}

pub gen Ring {
    has atom_indices: Vec<u32>
    has size: u8
    has is_aromatic: bool
    has is_heterocyclic: bool
    has heteroatoms: Vec<string>
}

docs {
    Complete molecule with atoms, bonds, and properties.

    Properties:
    - atoms: All atoms in the molecule
    - bonds: All bonds in the molecule
    - formula: Molecular formula (e.g., "C6H12O6")
    - name: IUPAC or common name
    - molecular_weight: Total molecular weight (g/mol)
    - charge: Net molecular charge
    - spin_multiplicity: 2S+1 (1 for singlet, 2 for doublet, etc.)
    - dipole_moment: Total dipole moment (Debye)
    - rings: Ring structures in the molecule
}

pub gen Molecule {
    has atoms: Vec<Atom>
    has bonds: Vec<Bond>
    has formula: string
    has name: string
    has molecular_weight: f64
    has charge: i32
    has spin_multiplicity: u8
    has dipole_moment: f64
    has rings: Vec<Ring>
    has smiles: string
}

docs {
    Functional group in organic chemistry.
}

pub gen FunctionalGroup {
    has name: string
    has smarts: string
    has atom_indices: Vec<u32>
    has category: string
}

// =============================================================================
// TRAITS
// =============================================================================

docs {
    Polar molecules have uneven charge distribution.
    This results in a net dipole moment.
}

pub trait Polar {
    docs {
        Calculate the total dipole moment (Debye).
    }

    fun dipole_moment() -> f64

    docs {
        Get the dipole vector components.
    }

    fun dipole_vector() -> Position3D

    docs {
        Check if molecule is polar (dipole > threshold).
    }

    fun is_polar() -> bool

    docs {
        Calculate solubility in polar solvents (qualitative).
    }

    fun polar_solubility() -> string
}

docs {
    Aromatic molecules exhibit resonance stabilization.
    Follows Huckel's rule: 4n+2 pi electrons in cyclic, planar system.
}

pub trait Aromatic {
    docs {
        Check if the molecule satisfies Huckel's rule.
    }

    fun satisfies_huckel_rule() -> bool

    docs {
        Get the number of pi electrons in aromatic system.
    }

    fun pi_electron_count() -> u32

    docs {
        Get all resonance structures.
    }

    fun resonance_structures() -> Vec<Molecule>

    docs {
        Calculate resonance stabilization energy (kJ/mol).
    }

    fun resonance_energy() -> f64

    docs {
        Check if the ring system is planar.
    }

    fun is_planar() -> bool
}

docs {
    Chiral molecules have non-superimposable mirror images.
}

pub trait Chiral {
    docs {
        Check if the molecule is chiral.
    }

    fun is_chiral() -> bool

    docs {
        Get all stereocenters in the molecule.
    }

    fun stereocenters() -> Vec<u32>

    docs {
        Get R/S configuration at each stereocenter.
    }

    fun configurations() -> Vec<string>

    docs {
        Get the enantiomer (mirror image).
    }

    fun enantiomer() -> Molecule

    docs {
        Calculate optical rotation.
    }

    fun optical_rotation() -> f64
}

docs {
    Molecules that can act as acids (proton donors).
}

pub trait Acidic {
    docs {
        Get the pKa value.
    }

    fun pka() -> f64

    docs {
        Get the acidic proton indices.
    }

    fun acidic_protons() -> Vec<u32>

    docs {
        Get the conjugate base.
    }

    fun conjugate_base() -> Molecule
}

docs {
    Molecules that can act as bases (proton acceptors).
}

pub trait Basic {
    docs {
        Get the pKb value.
    }

    fun pkb() -> f64

    docs {
        Get the basic sites (lone pair locations).
    }

    fun basic_sites() -> Vec<u32>

    docs {
        Get the conjugate acid.
    }

    fun conjugate_acid() -> Molecule
}

docs {
    Molecules that can be oxidized.
}

pub trait Oxidizable {
    docs {
        Get standard oxidation potential (V).
    }

    fun oxidation_potential() -> f64

    docs {
        Get the oxidized form.
    }

    fun oxidized_form() -> Molecule

    docs {
        Get the number of electrons lost.
    }

    fun electrons_lost() -> u8
}

docs {
    Molecules that can be reduced.
}

pub trait Reducible {
    docs {
        Get standard reduction potential (V).
    }

    fun reduction_potential() -> f64

    docs {
        Get the reduced form.
    }

    fun reduced_form() -> Molecule

    docs {
        Get the number of electrons gained.
    }

    fun electrons_gained() -> u8
}

docs {
    Coordination complexes with central metal and ligands.
}

pub trait CoordinationComplex {
    docs {
        Get the central metal atom.
    }

    fun central_metal() -> Atom

    docs {
        Get all ligands.
    }

    fun ligands() -> Vec<Molecule>

    docs {
        Get coordination number.
    }

    fun coordination_number() -> u8

    docs {
        Get coordination geometry (octahedral, tetrahedral, etc.).
    }

    fun geometry() -> string

    docs {
        Calculate crystal field splitting energy.
    }

    fun crystal_field_splitting() -> f64
}

// =============================================================================
// RULES
// =============================================================================

docs {
    Valence Rule: Atoms form bonds according to their valence.
    Total bonds + lone pairs = expected coordination.
}

pub rule valence_rule {
    each Atom {
        bond_count(this) + this.lone_pairs * 2 <= valence_electrons(this.element)
    }
}

docs {
    Octet Rule: Main group elements tend toward 8 valence electrons.
}

pub rule molecular_octet {
    each Atom where is_main_group(this.element) {
        total_valence_electrons(this) == 8 || is_exception(this)
    }
}

docs {
    Huckel's Rule: Aromatic compounds have 4n+2 pi electrons.
}

pub rule huckel_rule {
    each Ring where this.is_aromatic {
        exists n: u32 such that pi_electrons(this) == 4 * n + 2
    }
}

docs {
    Charge Conservation: Total atomic charges equal molecular charge.
}

pub rule charge_conservation {
    each Molecule {
        sum(atom.charge for atom in this.atoms) == this.charge
    }
}

docs {
    Bond Order Rule: Bond order determines bond properties.
}

pub rule bond_order_properties {
    each Bond {
        higher_order implies shorter_length && stronger_bond
    }
}

docs {
    Electronegativity Rule: Bond dipole points toward more electronegative atom.
}

pub rule electronegativity_dipole {
    each Bond {
        this.dipole points from less_electronegative to more_electronegative
    }
}

// =============================================================================
// PURE FUNCTIONS - Creation
// =============================================================================

docs {
    Create a default 3D position at origin.
}

pub fun origin() -> Position3D {
    return Position3D { x: 0.0, y: 0.0, z: 0.0 }
}

docs {
    Create a 3D position.
}

pub fun position(x: f64, y: f64, z: f64) -> Position3D {
    return Position3D { x: x, y: y, z: z }
}

docs {
    Create sp3 hybridization (tetrahedral).
}

pub fun sp3() -> Hybridization {
    return Hybridization {
        orbital_type: "sp3",
        geometry: "tetrahedral",
        bond_angle: 109.5,
        sigma_orbitals: 4,
        pi_orbitals: 0,
        lone_pairs: 0
    }
}

docs {
    Create sp2 hybridization (trigonal planar).
}

pub fun sp2() -> Hybridization {
    return Hybridization {
        orbital_type: "sp2",
        geometry: "trigonal planar",
        bond_angle: 120.0,
        sigma_orbitals: 3,
        pi_orbitals: 1,
        lone_pairs: 0
    }
}

docs {
    Create sp hybridization (linear).
}

pub fun sp() -> Hybridization {
    return Hybridization {
        orbital_type: "sp",
        geometry: "linear",
        bond_angle: 180.0,
        sigma_orbitals: 2,
        pi_orbitals: 2,
        lone_pairs: 0
    }
}

docs {
    Create an atom in a molecular context.
}

pub fun new_atom(element: Element, charge: i8, position: Position3D) -> Atom {
    return Atom {
        element: element,
        charge: charge,
        position: position,
        bond_indices: Vec::new(),
        hybridization: sp3(),
        lone_pairs: 0,
        is_chiral_center: false,
        partial_charge: 0.0
    }
}

docs {
    Create a bond between two atoms.
}

pub fun new_bond(atom1_idx: u32, atom2_idx: u32, bond_type: BondType) -> Bond {
    return Bond {
        atom1_idx: atom1_idx,
        atom2_idx: atom2_idx,
        bond_type: bond_type,
        length: 0.0,
        energy: 0.0,
        dipole: 0.0,
        is_rotatable: bond_type.order == 1 && !bond_type.is_aromatic
    }
}

docs {
    Create an empty molecule.
}

pub fun new_molecule(name: string) -> Molecule {
    return Molecule {
        atoms: Vec::new(),
        bonds: Vec::new(),
        formula: "",
        name: name,
        molecular_weight: 0.0,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 0.0,
        rings: Vec::new(),
        smiles: ""
    }
}

docs {
    Add an atom to a molecule.
}

pub fun add_atom(molecule: Molecule, atom: Atom) -> Molecule {
    let mut atoms = molecule.atoms
    atoms.push(atom)

    return Molecule {
        atoms: atoms,
        bonds: molecule.bonds,
        formula: molecule.formula,
        name: molecule.name,
        molecular_weight: molecule.molecular_weight + atom.element.atomic_mass,
        charge: molecule.charge + (atom.charge as i32),
        spin_multiplicity: molecule.spin_multiplicity,
        dipole_moment: molecule.dipole_moment,
        rings: molecule.rings,
        smiles: molecule.smiles
    }
}

docs {
    Add a bond to a molecule.
}

pub fun add_bond(molecule: Molecule, bond: Bond) -> Molecule {
    let mut bonds = molecule.bonds
    bonds.push(bond)

    return Molecule {
        atoms: molecule.atoms,
        bonds: bonds,
        formula: molecule.formula,
        name: molecule.name,
        molecular_weight: molecule.molecular_weight,
        charge: molecule.charge,
        spin_multiplicity: molecule.spin_multiplicity,
        dipole_moment: molecule.dipole_moment,
        rings: molecule.rings,
        smiles: molecule.smiles
    }
}

// =============================================================================
// PURE FUNCTIONS - Calculations
// =============================================================================

docs {
    Calculate the distance between two positions in Angstroms.
}

pub fun distance(p1: Position3D, p2: Position3D) -> f64 {
    let dx = p2.x - p1.x
    let dy = p2.y - p1.y
    let dz = p2.z - p1.z
    return (dx * dx + dy * dy + dz * dz)
}

docs {
    Calculate molecular weight from atoms.
}

pub fun molecular_weight(molecule: Molecule) -> f64 {
    let mut total = 0.0
    for atom in molecule.atoms {
        total = total + atom.element.atomic_mass
    }
    return total
}

docs {
    Calculate the number of atoms of each element.
}

pub fun atom_counts(molecule: Molecule) -> Vec<(string, u32)> {
    let mut counts: Vec<(string, u32)> = Vec::new()

    for atom in molecule.atoms {
        let symbol = atom.element.symbol
        let mut found = false

        for i in 0..counts.len() {
            if counts[i].0 == symbol {
                counts[i].1 = counts[i].1 + 1
                found = true
            }
        }

        if !found {
            counts.push((symbol, 1))
        }
    }

    return counts
}

docs {
    Generate molecular formula from atom counts.
}

pub fun molecular_formula(molecule: Molecule) -> string {
    let counts = atom_counts(molecule)
    let mut formula = ""

    for (symbol, count) in counts {
        formula = formula + symbol
        if count > 1 {
            formula = formula + count.to_string()
        }
    }

    return formula
}

docs {
    Calculate bond length using covalent radii (Angstroms).
}

pub fun calculate_bond_length(atom1: Atom, atom2: Atom, bond_type: BondType) -> f64 {
    let r1 = atom1.element.covalent_radius / 100.0
    let r2 = atom2.element.covalent_radius / 100.0
    let base_length = r1 + r2

    // Shorten for higher bond orders
    let order_factor = match bond_type.order {
        1 => 1.0,
        2 => 0.87,
        3 => 0.78,
        _ => 1.0
    }

    return base_length * order_factor
}

docs {
    Estimate bond dissociation energy (kJ/mol).
    Uses empirical bond energy tables.
}

pub fun estimate_bond_energy(atom1: Atom, atom2: Atom, bond_type: BondType) -> f64 {
    let s1 = atom1.element.symbol
    let s2 = atom2.element.symbol

    // Common bond energies (kJ/mol)
    if (s1 == "C" && s2 == "C") || (s1 == "C" && s2 == "C") {
        return match bond_type.order {
            1 => 347.0,
            2 => 614.0,
            3 => 839.0,
            _ => 347.0
        }
    }

    if (s1 == "C" && s2 == "H") || (s1 == "H" && s2 == "C") {
        return 413.0
    }

    if (s1 == "C" && s2 == "O") || (s1 == "O" && s2 == "C") {
        return match bond_type.order {
            1 => 358.0,
            2 => 799.0,
            _ => 358.0
        }
    }

    if (s1 == "O" && s2 == "H") || (s1 == "H" && s2 == "O") {
        return 463.0
    }

    if (s1 == "N" && s2 == "H") || (s1 == "H" && s2 == "N") {
        return 391.0
    }

    if (s1 == "C" && s2 == "N") || (s1 == "N" && s2 == "C") {
        return match bond_type.order {
            1 => 305.0,
            2 => 615.0,
            3 => 891.0,
            _ => 305.0
        }
    }

    // Default estimate based on electronegativities
    return 250.0
}

docs {
    Calculate bond dipole moment (Debye).
    Dipole = charge_separation * distance
}

pub fun calculate_bond_dipole(atom1: Atom, atom2: Atom, bond_length: f64) -> f64 {
    let en1 = match atom1.element.electronegativity {
        Some(val) => val,
        None => 2.0
    }

    let en2 = match atom2.element.electronegativity {
        Some(val) => val,
        None => 2.0
    }

    let en_diff = en2 - en1

    // Empirical formula: dipole ~ 0.5 * electronegativity_diff * bond_length
    return 0.5 * en_diff * bond_length
}

docs {
    Determine hybridization from bond count and lone pairs.
}

pub fun determine_hybridization(bond_count: u8, lone_pairs: u8) -> Hybridization {
    let steric_number = bond_count + lone_pairs

    match steric_number {
        2 => {
            return Hybridization {
                orbital_type: "sp",
                geometry: "linear",
                bond_angle: 180.0,
                sigma_orbitals: 2,
                pi_orbitals: 2,
                lone_pairs: lone_pairs
            }
        },
        3 => {
            let geometry = if lone_pairs == 0 { "trigonal planar" }
                          else if lone_pairs == 1 { "bent" }
                          else { "linear" }
            return Hybridization {
                orbital_type: "sp2",
                geometry: geometry,
                bond_angle: 120.0,
                sigma_orbitals: 3,
                pi_orbitals: 1,
                lone_pairs: lone_pairs
            }
        },
        4 => {
            let geometry = if lone_pairs == 0 { "tetrahedral" }
                          else if lone_pairs == 1 { "trigonal pyramidal" }
                          else if lone_pairs == 2 { "bent" }
                          else { "linear" }
            let angle = if lone_pairs == 0 { 109.5 }
                       else if lone_pairs == 1 { 107.0 }
                       else { 104.5 }
            return Hybridization {
                orbital_type: "sp3",
                geometry: geometry,
                bond_angle: angle,
                sigma_orbitals: 4,
                pi_orbitals: 0,
                lone_pairs: lone_pairs
            }
        },
        5 => {
            return Hybridization {
                orbital_type: "sp3d",
                geometry: "trigonal bipyramidal",
                bond_angle: 90.0,
                sigma_orbitals: 5,
                pi_orbitals: 0,
                lone_pairs: lone_pairs
            }
        },
        6 => {
            return Hybridization {
                orbital_type: "sp3d2",
                geometry: "octahedral",
                bond_angle: 90.0,
                sigma_orbitals: 6,
                pi_orbitals: 0,
                lone_pairs: lone_pairs
            }
        },
        _ => {
            return sp3()
        }
    }
}

docs {
    Calculate total dipole moment of molecule (vector sum of bond dipoles).
}

pub fun calculate_dipole_moment(molecule: Molecule) -> f64 {
    let mut dx = 0.0
    let mut dy = 0.0
    let mut dz = 0.0

    for bond in molecule.bonds {
        let atom1 = molecule.atoms[bond.atom1_idx as usize]
        let atom2 = molecule.atoms[bond.atom2_idx as usize]

        let en1 = match atom1.element.electronegativity {
            Some(val) => val,
            None => 2.0
        }

        let en2 = match atom2.element.electronegativity {
            Some(val) => val,
            None => 2.0
        }

        let en_diff = en2 - en1
        let mag = en_diff * bond.length * 0.5

        // Direction from atom1 to atom2
        let rx = atom2.position.x - atom1.position.x
        let ry = atom2.position.y - atom1.position.y
        let rz = atom2.position.z - atom1.position.z
        let r_mag = (rx * rx + ry * ry + rz * rz)

        if r_mag > 0.0001 {
            dx = dx + mag * rx / r_mag
            dy = dy + mag * ry / r_mag
            dz = dz + mag * rz / r_mag
        }
    }

    return (dx * dx + dy * dy + dz * dz)
}

docs {
    Check if molecule contains aromatic ring.
}

pub fun is_aromatic(molecule: Molecule) -> bool {
    for ring in molecule.rings {
        if ring.is_aromatic {
            return true
        }
    }
    return false
}

docs {
    Count pi electrons in a ring.
}

pub fun ring_pi_electrons(molecule: Molecule, ring: Ring) -> u32 {
    let mut pi_count: u32 = 0

    for idx in ring.atom_indices {
        let atom = molecule.atoms[idx as usize]

        // Check hybridization for unhybridized p orbital
        if atom.hybridization.orbital_type == "sp2" {
            pi_count = pi_count + 1
        }

        // Lone pairs can contribute to aromaticity
        if atom.element.symbol == "N" || atom.element.symbol == "O" {
            if atom.lone_pairs > 0 && atom.hybridization.orbital_type == "sp2" {
                pi_count = pi_count + 2
            }
        }
    }

    // Count double bonds in ring
    for bond in molecule.bonds {
        let a1_in = ring.atom_indices.contains(bond.atom1_idx)
        let a2_in = ring.atom_indices.contains(bond.atom2_idx)

        if a1_in && a2_in && bond.bond_type.order == 2 {
            pi_count = pi_count + 2
        }
    }

    return pi_count
}

docs {
    Check Huckel's rule: 4n+2 pi electrons.
}

pub fun satisfies_huckel(pi_electrons: u32) -> bool {
    // Check if pi_electrons = 4n + 2 for some n >= 0
    if pi_electrons < 2 {
        return false
    }

    let adjusted = pi_electrons - 2
    return adjusted % 4 == 0
}

docs {
    Calculate degree of unsaturation (DBE).
    DBE = (2C + 2 + N - H - X) / 2
}

pub fun degree_of_unsaturation(c_count: u32, h_count: u32, n_count: u32, x_count: u32) -> f64 {
    let numerator = 2 * c_count + 2 + n_count - h_count - x_count
    return (numerator as f64) / 2.0
}

docs {
    Identify functional groups in molecule.
}

pub fun identify_functional_groups(molecule: Molecule) -> Vec<FunctionalGroup> {
    let mut groups: Vec<FunctionalGroup> = Vec::new()

    // This is a simplified implementation
    // A full implementation would use SMARTS pattern matching

    return groups
}

// =============================================================================
// COMMON MOLECULES
// =============================================================================

docs {
    Create water molecule (H2O).
}

pub fun water() -> Molecule {
    return Molecule {
        atoms: Vec::new(),  // Would be populated with actual atoms
        bonds: Vec::new(),
        formula: "H2O",
        name: "Water",
        molecular_weight: 18.015,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 1.85,
        rings: Vec::new(),
        smiles: "O"
    }
}

docs {
    Create methane molecule (CH4).
}

pub fun methane() -> Molecule {
    return Molecule {
        atoms: Vec::new(),
        bonds: Vec::new(),
        formula: "CH4",
        name: "Methane",
        molecular_weight: 16.043,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 0.0,
        rings: Vec::new(),
        smiles: "C"
    }
}

docs {
    Create ammonia molecule (NH3).
}

pub fun ammonia() -> Molecule {
    return Molecule {
        atoms: Vec::new(),
        bonds: Vec::new(),
        formula: "NH3",
        name: "Ammonia",
        molecular_weight: 17.031,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 1.47,
        rings: Vec::new(),
        smiles: "N"
    }
}

docs {
    Create carbon dioxide molecule (CO2).
}

pub fun carbon_dioxide() -> Molecule {
    return Molecule {
        atoms: Vec::new(),
        bonds: Vec::new(),
        formula: "CO2",
        name: "Carbon dioxide",
        molecular_weight: 44.01,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 0.0,
        rings: Vec::new(),
        smiles: "O=C=O"
    }
}

docs {
    Create benzene molecule (C6H6).
}

pub fun benzene() -> Molecule {
    return Molecule {
        atoms: Vec::new(),
        bonds: Vec::new(),
        formula: "C6H6",
        name: "Benzene",
        molecular_weight: 78.114,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 0.0,
        rings: vec![Ring {
            atom_indices: vec![0, 1, 2, 3, 4, 5],
            size: 6,
            is_aromatic: true,
            is_heterocyclic: false,
            heteroatoms: Vec::new()
        }],
        smiles: "c1ccccc1"
    }
}

docs {
    Create ethanol molecule (C2H5OH).
}

pub fun ethanol() -> Molecule {
    return Molecule {
        atoms: Vec::new(),
        bonds: Vec::new(),
        formula: "C2H6O",
        name: "Ethanol",
        molecular_weight: 46.069,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 1.69,
        rings: Vec::new(),
        smiles: "CCO"
    }
}

docs {
    Create glucose molecule (C6H12O6).
}

pub fun glucose() -> Molecule {
    return Molecule {
        atoms: Vec::new(),
        bonds: Vec::new(),
        formula: "C6H12O6",
        name: "Glucose",
        molecular_weight: 180.156,
        charge: 0,
        spin_multiplicity: 1,
        dipole_moment: 3.5,
        rings: Vec::new(),
        smiles: "OC[C@H]1OC(O)[C@H](O)[C@@H](O)[C@@H]1O"
    }
}

// =============================================================================
// EVOLUTION
// =============================================================================

docs {
    Evolution adding SMILES parser and generator.
}

evo smiles_support @ 0.9.1 > 0.9.0 {
    adds fun parse_smiles(smiles: string) -> Molecule
    adds fun generate_smiles(molecule: Molecule) -> string
    adds fun canonical_smiles(molecule: Molecule) -> string
    because "SMILES notation essential for cheminformatics"
}

docs {
    Evolution adding 3D structure generation.
}

evo structure_3d @ 0.9.2 > 0.9.1 {
    adds fun generate_3d_coordinates(molecule: Molecule) -> Molecule
    adds fun optimize_geometry(molecule: Molecule) -> Molecule
    adds fun minimize_energy(molecule: Molecule) -> Molecule
    adds fun calculate_rmsd(mol1: Molecule, mol2: Molecule) -> f64
    because "3D structure essential for molecular modeling"
}

docs {
    Evolution adding molecular orbital calculations.
}

evo molecular_orbitals @ 0.9.3 > 0.9.2 {
    adds fun calculate_homo(molecule: Molecule) -> MolecularOrbital
    adds fun calculate_lumo(molecule: Molecule) -> MolecularOrbital
    adds fun homo_lumo_gap(molecule: Molecule) -> f64
    adds fun molecular_orbital_diagram(molecule: Molecule) -> Vec<MolecularOrbital>
    because "MO theory essential for understanding reactivity"
}
