// ═══════════════════════════════════════════════════════════════
// Ecosystem - Population Dynamics and Trophic Levels
// ═══════════════════════════════════════════════════════════════

module biology.ecosystem @ 1.0.0

use biology.types.{ Energy, Nutrient, Generation }

/// Species role in ecosystem
pub gen TrophicRole {
  type: enum {
    Producer,
    PrimaryConsumer,
    SecondaryConsumer,
    TertiaryConsumer,
    Decomposer
  }

  fun trophic_level() -> u8 {
    match this {
      Producer { return 1 }
      PrimaryConsumer { return 2 }
      SecondaryConsumer { return 3 }
      TertiaryConsumer { return 4 }
      Decomposer { return 0 }
    }
  }

  docs {
    Trophic role determines position in food web
    and energy transfer efficiency.
  }
}

/// Species in an ecosystem
pub gen Species {
  has id: u64
  has name: string
  has role: TrophicRole
  has population: u64
  has birth_rate: f64
  has death_rate: f64
  has carrying_capacity: u64

  rule positive_rates {
    this.birth_rate >= 0.0 && this.death_rate >= 0.0
  }

  rule population_non_negative {
    this.population >= 0
  }

  fun growth_rate() -> f64 {
    r = this.birth_rate - this.death_rate
    k = this.carrying_capacity as f64
    n = this.population as f64
    return r * n * (1.0 - n / k)
  }

  docs {
    A species in the ecosystem with population dynamics.
    Growth follows logistic model with carrying capacity.
  }
}

/// Interaction between species
pub gen Interaction {
  has predator: u64
  has prey: u64
  has attack_rate: f64
  has handling_time: f64
  has conversion_efficiency: f64

  rule efficiency_bounds {
    this.conversion_efficiency > 0.0 &&
    this.conversion_efficiency <= 1.0
  }

  fun predation_rate(prey_density: f64) -> f64 {
    return (this.attack_rate * prey_density) /
           (1.0 + this.attack_rate * this.handling_time * prey_density)
  }

  docs {
    Predator-prey interaction with Holling Type II
    functional response (includes handling time saturation).
  }
}

/// Full ecosystem state
pub system Ecosystem {
  uses Transport<Energy>
  uses Transport<Nutrient>

  state species: Map<u64, Species>
  state interactions: Vec<Interaction>
  state total_energy: Energy
  state nutrient_pool: Nutrient
  state generation: Generation

  rule trophic_efficiency {
    for level in 1..4 {
      energy_at_level = this.energy_at_trophic_level(level)
      energy_at_next = this.energy_at_trophic_level(level + 1)

      energy_at_next <= energy_at_level * 0.15
    }

    docs {
      Lindeman's 10% law: only ~10% of energy
      transfers between trophic levels.
    }
  }

  rule carrying_capacity_limit {
    for sp in this.species.values() {
      sp.population <= sp.carrying_capacity * 1.1
    }

    docs {
      Carrying capacity limits population.
      Overshoot leads to population crash.
    }
  }

  rule predator_prey_balance {
    for interaction in this.interactions {
      predator = this.species.get(interaction.predator)
      prey = this.species.get(interaction.prey)

      predator.population > 0 implies prey.population > 0
    }

    docs {
      Predators cannot persist without prey.
    }
  }

  rule decomposer_recycling {
    decomposer_count = this.species.values()
      .filter(|s| s.role == TrophicRole.Decomposer)
      .map(|s| s.population)
      .sum()

    decomposer_count > 0 implies
      this.nutrient_pool.total_mass() > 0

    docs {
      Decomposers are essential for nutrient cycling.
    }
  }

  fun tick() -> Self {
    new_species = Map.new()

    for (id, sp) in this.species {
      growth = sp.growth_rate()

      predation_loss = 0.0
      predation_gain = 0.0

      for interaction in this.interactions {
        if interaction.prey == id {
          predator = this.species.get(interaction.predator)
          predation_loss += interaction.predation_rate(sp.population as f64)
                            * predator.population as f64
        }
        if interaction.predator == id {
          prey = this.species.get(interaction.prey)
          consumed = interaction.predation_rate(prey.population as f64)
                     * sp.population as f64
          predation_gain += consumed * interaction.conversion_efficiency
        }
      }

      delta = growth - predation_loss + predation_gain
      new_pop = max(0, (sp.population as f64 + delta) as u64)

      new_species.insert(id, Species { ...sp, population: new_pop })
    }

    return Ecosystem {
      ...this,
      species: new_species,
      generation: this.generation.next()
    }
  }

  fun energy_at_trophic_level(level: u8) -> f64 {
    return this.species.values()
      .filter(|s| s.role.trophic_level() == level)
      .map(|s| s.population as f64 * 1.0)
      .sum()
  }

  fun is_stable(tolerance: f64) -> bool {
    next = this.tick()

    for (id, sp) in this.species {
      next_sp = next.species.get(id)
      change = ((next_sp.population as f64) - (sp.population as f64)).abs()
      if change / (sp.population as f64 + 1.0) > tolerance {
        return false
      }
    }

    return true
  }

  fun add_keystone(species: Species) -> Self {
    return Ecosystem {
      ...this,
      species: this.species.insert(species.id, species)
    }
  }

  docs {
    Ecosystem models population dynamics using:
    - Lotka-Volterra predator-prey equations
    - Logistic growth with carrying capacity
    - Holling Type II functional response
    - Trophic energy transfer (10% rule)

    This is the foundation for modeling any system of
    interacting populations: biological, economic, social.
  }
}
