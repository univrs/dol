module dol.bootstrap @ 0.8.0
docs {
    Bootstrap types for DOL self-hosting compiler.
    These types are used in parser/typechecker but not defined as genes.
}

// Module declaration wrapper
pub genModuleDecl {
    name: string
    version: Option<string>
    span: Span
}

// Use statement wrapper
pub genUseStmt {
    path: string
    items: List<string>
    span: Span
}

// Gene member enum
pub genGeneMember {
    type: enum {
        Field { decl: FieldDecl }
        Method { decl: MethodDecl }
        TypeAlias { decl: TypeAlias }
    }
}

// Field declaration wrapper
pub genFieldDecl {
    name: string
    ty: TypeExpr
    default: Option<Expr>
    is_pub: bool
    span: Span
}

// Trait member enum
pub genTraitMember {
    type: enum {
        Required { decl: MethodDecl }
        Provided { decl: MethodDecl }
        Associated { decl: TypeAlias }
    }
}

// Method declaration wrapper
pub genMethodDecl {
    name: string
    params: List<Param>
    return_type: Option<TypeExpr>
    body: Option<Block>
    is_pub: bool
    is_sex: bool
    span: Span
}

// Type alias
pub genTypeAlias {
    name: string
    ty: TypeExpr
    span: Span
}

// Associated type
pub genAssociatedType {
    name: string
    bounds: List<TypeExpr>
    span: Span
}

// Variable declaration statement wrapper
pub genVarDecl {
    name: string
    ty: Option<TypeExpr>
    value: Option<Expr>
    is_pub: bool
    is_sex: bool
    span: Span
}

// Extern declaration wrapper
pub genExternDecl {
    name: string
    ty: TypeExpr
    is_pub: bool
    span: Span
}

// Version constraint
pub genVersionConstraint {
    op: string
    version: string
}

// Requires statement
pub genRequiresStmt {
    module_name: string
    version: Option<VersionConstraint>
    span: Span
}

// System statement enum
pub genSystemStmt {
    type: enum {
        Requires { stmt: RequiresStmt }
        Uses { name: string }
        Manages { name: string }
    }
}

// Migration kind enum
pub genMigrationKind {
    type: enum {
        Added
        Removed
        Renamed { new_name: string }
        Changed { description: string }
    }
}

// Migration statement
pub genMigrationStmt {
    field_name: string
    kind: MigrationKind
    span: Span
}

// Exegesis block
pub genExegesisBlock {
    content: string
    span: Span
}

// Where clause
pub genWhereClause {
    predicates: List<WherePredicate>
    span: Span
}

// Statement wrappers for parser results
pub genLetStmt {
    pattern: string
    ty: Option<TypeExpr>
    value: Expr
    is_mut: bool
    span: Span
}

pub genVarStmt {
    name: string
    ty: Option<TypeExpr>
    value: Option<Expr>
    is_mut: bool
    span: Span
}

pub genConstStmt {
    name: string
    ty: Option<TypeExpr>
    value: Expr
    span: Span
}

pub genReturnStmt {
    value: Option<Expr>
    span: Span
}

pub genIfStmt {
    condition: Expr
    then_block: Block
    else_branch: Option<ElseBranch>
    span: Span
}

pub genMatchStmt {
    scrutinee: Expr
    arms: List<MatchArm>
    span: Span
}

pub genArmBody {
    type: enum {
        Block { block: Box<Block> }
        Expr { expr: Expr }
    }
}

pub genLiteralPattern {
    type: enum {
        Int { value: i64 }
        Float { value: f64 }
        String { value: string }
        Bool { value: bool }
    }
}

pub genForStmt {
    pattern: string
    iter: Expr
    body: Block
    span: Span
}

pub genWhileStmt {
    cond: Expr
    body: Block
    span: Span
}

pub genLoopStmt {
    label: Option<string>
    body: Block
    span: Span
}

pub genBreakStmt {
    label: Option<string>
    value: Option<Expr>
    span: Span
}

pub genContinueStmt {
    label: Option<string>
    span: Span
}

pub genSexBlock {
    body: Block
    span: Span
}

// Additional statement types
pub genAssignStmt {
    target: Expr
    value: Expr
    span: Span
}

pub genExprStmt {
    expr: Expr
    span: Span
}

// Expression wrappers for parser results
pub genBinaryExpr {
    left: Box<Expr>
    op: BinOp
    right: Box<Expr>
    span: Span
}

pub genUnaryExpr {
    op: UnaryOp
    operand: Box<Expr>
    span: Span
}

pub genQuoteExpr {
    inner: Box<Expr>
    span: Span
}

pub genIdiomExpr {
    operand: Box<Expr>
    idiom: string
    span: Span
}

pub genArrayExpr {
    elements: List<Expr>
    span: Span
}

pub genThisExpr {
    span: Span
}

pub genIdentExpr {
    name: string
    span: Span
}

pub genCallExpr {
    callee: Box<Expr>
    args: List<CallArg>
    span: Span
}

pub genMethodCallExpr {
    receiver: Box<Expr>
    method: string
    args: List<CallArg>
    span: Span
}

pub genFieldExpr {
    object: Box<Expr>
    field: string
    span: Span
}

pub genIndexExpr {
    object: Box<Expr>
    index: Box<Expr>
    span: Span
}

pub genStructExpr {
    name: string
    fields: List<StructField>
    span: Span
}

pub genArg {
    name: Option<string>
    value: Expr
    span: Span
}

pub genStructField {
    name: string
    value: Expr
    span: Span
}

pub genLambdaBody {
    type: enum {
        Block { block: Box<Block> }
        Expr { expr: Box<Expr> }
    }
}

pub genLambdaExpr {
    params: List<LambdaParam>
    body: Box<LambdaBody>
    return_type: Option<TypeExpr>
    span: Span
}

pub genIfExpr {
    cond: Box<Expr>
    then_block: Box<Expr>
    else_branch: Option<Box<Expr>>
    span: Span
}

pub genMatchExpr {
    scrutinee: Box<Expr>
    arms: List<MatchArm>
    span: Span
}

// Expression type discriminator
pub genExprType {
    type: enum {
        Binary
        Unary
        Quote
        Idiom
        Array
        This
        Ident
        Call
        MethodCall
        Field
        Index
        Struct
        Lambda
        If
        Match
        Literal
    }
}

// Wrapper-based Stmt enum for parser compatibility
// This shadows the ast.dol Stmt to allow Stmt::Let(LetStmt::new(...)) pattern
pub genStmtWrapper {
    type: enum {
        Let { stmt: LetStmt }
        Var { stmt: VarStmt }
        Assign { stmt: AssignStmt }
        Expr { stmt: ExprStmt }
        Return { stmt: ReturnStmt }
        If { stmt: IfStmt }
        While { stmt: WhileStmt }
        For { stmt: ForStmt }
        Loop { stmt: LoopStmt }
        Break { stmt: BreakStmt }
        Continue { stmt: ContinueStmt }
        Match { stmt: MatchStmt }
        Block { block: Box<Block> }
        Sex { stmt: SexBlock }
    }
}

// Wrapper-based Expr enum for parser compatibility
pub genExprWrapper {
    type: enum {
        Binary { expr: BinaryExpr }
        Unary { expr: UnaryExpr }
        Quote { expr: QuoteExpr }
        Idiom { expr: IdiomExpr }
        Array { expr: ArrayExpr }
        This { expr: ThisExpr }
        Ident { expr: IdentExpr }
        Call { expr: CallExpr }
        MethodCall { expr: MethodCallExpr }
        Field { expr: FieldExpr }
        Index { expr: IndexExpr }
        Struct { expr: StructExpr }
        Lambda { expr: LambdaExpr }
        If { expr: IfExpr }
        Match { expr: MatchExpr }
    }
}
