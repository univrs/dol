module dol.ast @ 0.8.0

use dol.token.Span

docs {
    Abstract Syntax Tree definitions for DOL.

    These types represent the complete parsed structure of DOL source code.
    All AST nodes include a `span` field for source location tracking,
    enabling precise error reporting and IDE integration.

    The AST hierarchy:
    - DolFile: Top-level container for all declarations
    - Decl: Enumeration of declaration types (Gene, Trait, System, etc.)
    - TypeExpr: Type expressions (primitives, generics, functions, tuples)
    - Expr: Expressions (literals, operators, calls, meta-programming)
    - Stmt: Statements (let, assign, control flow)
    - Block: Scoped sequence of statements with optional trailing expression
}

// =============================================================================
// TOP-LEVEL FILE STRUCTURE
// =============================================================================

docs {
    A DOL file consists of an ordered list of declarations.
    Each file represents a single module.
}

/// Top-level AST node representing an entire DOL source file
pub gen DolFile {
    has declarations: List<Decl>
    has span: Span
}

// =============================================================================
// DECLARATIONS
// =============================================================================

docs {
    Declarations are the top-level constructs in DOL.
    Each declaration introduces a new named entity into the namespace.
}

/// Enumeration of all declaration types
pub gen Decl {
    type: enum {
        /// Module declaration: `module foo.bar @ 1.0.0`
        Module { name: string, version: Option<string> },

        /// Use declaration: `use foo.bar.{ Baz, Qux }`
        Use { path: List<string>, items: List<string> },

        /// Gene declaration (struct-like with constraints)
        Gene { decl: GeneDecl },

        /// Trait declaration (interface with laws)
        Trait { decl: TraitDecl },

        /// System declaration (stateful component)
        System { decl: SystemDecl },

        /// Constraint declaration
        Constraint { decl: ConstraintDecl },

        /// Evolution declaration (schema migration)
        Evolves { decl: EvolvesDecl },

        /// Standalone function declaration
        Function { decl: FunctionDecl }
    }
    has span: Span
}

// =============================================================================
// GENE DECLARATION
// =============================================================================

docs {
    A gene is DOL's primary data structure, similar to a struct but with
    built-in support for constraints, methods, and optional enum types.
}

/// Gene declaration with fields, methods, constraints, and exegesis
pub gen GeneDecl {
    has name: string
    has is_pub: bool = false
    has type_params: List<TypeParam> = []
    has type_def: Option<TypeExpr>
    has fields: List<Field>
    has methods: List<FunctionDecl>
    has constraints: List<ConstraintDecl>
    has exegesis: Option<string>
    has span: Span
}

docs {
    A field is a named component of a gene with optional default value.
}

/// Field within a gene
pub gen Field {
    has name: string
    has ty: TypeExpr
    has default_value: Option<Expr>
    has is_pub: bool = false
    has span: Span
}

docs {
    A type parameter for generic types, optionally bounded.
}

/// Type parameter with optional bounds
pub gen TypeParam {
    has name: string
    has bounds: List<string> = []
    has span: Span
}

// =============================================================================
// TRAIT DECLARATION
// =============================================================================

docs {
    A trait defines a contract with required methods, provided methods,
    and laws that implementations must satisfy.
}

/// Trait declaration with methods and laws
pub gen TraitDecl {
    has name: string
    has is_pub: bool = false
    has type_params: List<TypeParam> = []
    has super_traits: List<string> = []
    has required_methods: List<MethodSig>
    has provided_methods: List<FunctionDecl>
    has laws: List<LawDecl>
    has exegesis: Option<string>
    has span: Span
}

docs {
    A method signature declares a method without providing an implementation.
}

/// Method signature (declaration without body)
pub gen MethodSig {
    has name: string
    has type_params: List<TypeParam> = []
    has params: List<Param>
    has return_type: TypeExpr
    has span: Span
}

docs {
    A law is a property that must hold for all valid implementations.
}

/// Law declaration expressing invariants
pub gen LawDecl {
    has name: string
    has type_params: List<TypeParam> = []
    has params: List<Param> = []
    has body: Expr
    has exegesis: Option<string>
    has span: Span
}

// =============================================================================
// SYSTEM DECLARATION
// =============================================================================

docs {
    A system is a stateful component that encapsulates state transitions
    and side effects, similar to actors or services.
}

/// System declaration with state and side-effectful functions
pub gen SystemDecl {
    has name: string
    has is_pub: bool = false
    has type_params: List<TypeParam> = []
    has uses: List<string>
    has states: List<Field>
    has functions: List<FunctionDecl>
    has constraints: List<ConstraintDecl>
    has exegesis: Option<string>
    has span: Span
}

// =============================================================================
// CONSTRAINT & EVOLVES DECLARATIONS
// =============================================================================

docs {
    A constraint is a boolean predicate that must always hold.
    Constraints enable runtime validation and compile-time verification.
}

/// Constraint declaration
pub gen ConstraintDecl {
    has name: string
    has params: List<Param> = []
    has body: Expr
    has exegesis: Option<string>
    has span: Span
}

docs {
    Evolution declarations describe schema migrations between versions.
}

/// Evolution declaration for schema migrations
pub gen EvolvesDecl {
    has from_type: string
    has from_version: string
    has to_type: string
    has to_version: string
    has changes: List<Change>
    has migrate: Option<Block>
    has exegesis: Option<string>
    has span: Span
}

docs {
    A change describes a single modification in an evolution.
}

/// Change specification in evolution
pub gen Change {
    type: enum {
        /// Field added
        Added { name: string, ty: TypeExpr, default_value: Option<Expr> },
        /// Field removed
        Removed { name: string },
        /// Field type changed
        Changed { name: string, from: TypeExpr, to: TypeExpr },
        /// Field renamed
        Renamed { old_name: string, new_name: string }
    }
    has span: Span
}

// =============================================================================
// FUNCTION DECLARATION
// =============================================================================

docs {
    A function declaration includes pure functions and side-effectful functions.
    Side effects are marked with `sex` (side effect execution).
}

/// Function declaration
pub gen FunctionDecl {
    has name: string
    has is_pub: bool = false
    has is_sex: bool = false
    has is_extern: bool = false
    has type_params: List<TypeParam> = []
    has params: List<Param>
    has return_type: TypeExpr
    has body: Option<Block>
    has where_clause: List<WherePredicate> = []
    has exegesis: Option<string>
    has span: Span
}

docs {
    A parameter is a named, typed input to a function.
}

/// Function parameter
pub gen Param {
    has name: string
    has ty: TypeExpr
    has default_value: Option<Expr>
    has is_variadic: bool = false
    has span: Span
}

docs {
    A where predicate constrains type parameters.
}

/// Where clause predicate
pub gen WherePredicate {
    has type_name: string
    has bounds: List<string>
    has span: Span
}

// =============================================================================
// TYPE EXPRESSIONS
// =============================================================================

docs {
    Type expressions represent types in DOL source code.
    They range from primitive types to complex generic and function types.
}

/// Type expression enumeration
pub gen TypeExpr {
    type: enum {
        // ═══════════════════════════════════════════════════════════════
        // Primitive Types
        // ═══════════════════════════════════════════════════════════════

        /// Signed integers
        Int8, Int16, Int32, Int64,

        /// Unsigned integers
        UInt8, UInt16, UInt32, UInt64,

        /// Floating point
        Float32, Float64,

        /// Boolean
        Bool,

        /// String (UTF-8)
        String,

        /// Character (Unicode scalar)
        Char,

        /// Unit/Void type
        Void,

        /// Self type (within method context)
        SelfType,

        /// Never type (for functions that never return)
        Never,

        // ═══════════════════════════════════════════════════════════════
        // Compound Types
        // ═══════════════════════════════════════════════════════════════

        /// Named type reference: `Foo`, `Bar.Baz`
        Named { path: List<string> },

        /// Generic type application: `List<T>`, `Map<K, V>`
        Generic { name: string, args: List<TypeExpr> },

        /// Function type: `(A, B) -> C`
        Function { params: List<TypeExpr>, ret: Box<TypeExpr> },

        /// Tuple type: `(A, B, C)`
        Tuple { elements: List<TypeExpr> },

        /// Array type: `[T; N]`
        Array { element: Box<TypeExpr>, size: Option<u64> },

        /// Optional type: `T?`
        Optional { inner: Box<TypeExpr> },

        /// Reference type: `&T`, `&mut T`
        Reference { inner: Box<TypeExpr>, is_mut: bool },

        /// Pointer type: `*T`, `*mut T`
        Pointer { inner: Box<TypeExpr>, is_mut: bool },

        // ═══════════════════════════════════════════════════════════════
        // Enum Type Definition
        // ═══════════════════════════════════════════════════════════════

        /// Inline enum definition: `enum { Foo, Bar { x: Int } }`
        Enum { variants: List<EnumVariant> },

        // ═══════════════════════════════════════════════════════════════
        // Higher-Kinded Types
        // ═══════════════════════════════════════════════════════════════

        /// Higher-kinded type: `F<_>`
        HigherKinded { name: string, arity: u32 },

        /// Type-level application
        TypeApp { constructor: Box<TypeExpr>, arg: Box<TypeExpr> },

        // ═══════════════════════════════════════════════════════════════
        // Inference & Error
        // ═══════════════════════════════════════════════════════════════

        /// Inferred type (placeholder for type inference)
        Infer,

        /// Error type (used during error recovery)
        Error
    }
    has span: Span
}

docs {
    An enum variant is a single case in an enumeration.
}

/// Enum variant
pub gen EnumVariant {
    has name: string
    has fields: List<Field> = []
    has span: Span
}

// =============================================================================
// EXPRESSIONS
// =============================================================================

docs {
    Expressions are the computational core of DOL.
    They produce values and can be composed in complex ways.
}

/// Adding Missing Types

// ═══════════════════════════════════════════════════════════════════
// EXPRESSION HELPER TYPES
// These are referenced by Expr enum variants but need explicit definitions
// ═══════════════════════════════════════════════════════════════════

/// This expression - self-reference in method context
pub gen ThisExpr {
    has span: Span

    docs {
        Represents the 'this' keyword within a method body,
        referring to the current instance.
    }
}

/// Binary expression - two operands with an operator
pub gen BinaryExpr {
    has op: BinOp
    has left: Box<Expr>
    has right: Box<Expr>
    has span: Span

    docs {
        Binary operations like addition, comparison, logical and/or.
        The operator determines how left and right operands combine.
    }
}

/// Unary expression - single operand with prefix/postfix operator
pub gen UnaryExpr {
    has op: UnaryOp
    has operand: Box<Expr>
    has span: Span

    docs {
        Unary operations like negation, logical not, dereference.
    }
}

/// Function call expression
pub gen CallExpr {
    has callee: Box<Expr>
    has args: List<CallArg>
    has span: Span

    docs {
        Function or method call with arguments.
        Callee is the function being called.
    }
}

/// Method call expression - receiver.method(args)
pub gen MethodCallExpr {
    has receiver: Box<Expr>
    has method: string
    has args: List<CallArg>
    has span: Span

    docs {
        Method invocation on a receiver object.
    }
}

/// Field access expression - expr.field
pub gen FieldExpr {
    has object: Box<Expr>
    has field: string
    has span: Span

    docs {
        Accessing a field on a struct or object.
    }
}

/// Index expression - expr[index]
pub gen IndexExpr {
    has object: Box<Expr>
    has index: Box<Expr>
    has span: Span

    docs {
        Array or collection indexing.
    }
}

/// Struct literal expression - TypeName { field: value, ... }
pub gen StructExpr {
    has name: string
    has fields: List<FieldInit>
    has span: Span

    docs {
        Struct instantiation with field initializers.
    }
}

/// Array literal expression - [a, b, c]
pub gen ArrayExpr {
    has elements: List<Expr>
    has span: Span

    docs {
        Array literal with inline elements.
    }
}

/// Lambda/closure expression - |params| body or |params| { block }
pub gen LambdaExpr {
    has params: List<LambdaParam>
    has body: Box<Expr>
    has return_type: Option<TypeExpr>
    has span: Span

    docs {
        Anonymous function with captured environment.
    }
}

/// If expression - if cond { then } else { else }
pub gen IfExpr {
    has condition: Box<Expr>
    has then_branch: Box<Block>
    has else_branch: Option<Box<Expr>>
    has span: Span

    docs {
        Conditional expression that evaluates to a value.
    }
}

/// Match expression - match expr { arms }
pub gen MatchExpr {
    has scrutinee: Box<Expr>
    has arms: List<MatchArm>
    has span: Span

    docs {
        Pattern matching expression.
    }
}

/// Quote expression - 'expr for AST capture
pub gen QuoteExpr {
    has expr: Box<Expr>
    has span: Span

    docs {
        Quoted expression for metaprogramming.
    }
}

// ═══════════════════════════════════════════════════════════════════
// STATEMENT HELPER TYPES
// These are referenced by Stmt enum variants but need explicit definitions
// ═══════════════════════════════════════════════════════════════════

/// Let binding statement - let name: Type = value
pub gen LetStmt {
    has name: string
    has ty: Option<TypeExpr>
    has value: Option<Expr>
    has span: Span

    docs {
        Immutable variable binding.
    }
}

/// Var statement - var name: Type = value
pub gen VarStmt {
    has name: string
    has ty: Option<TypeExpr>
    has value: Option<Expr>
    has span: Span

    docs {
        Mutable variable binding.
    }
}

/// Const statement - const NAME: Type = value
pub gen ConstStmt {
    has name: string
    has ty: Option<TypeExpr>
    has value: Expr
    has span: Span

    docs {
        Compile-time constant definition.
    }
}

/// Assignment statement - target = value
pub gen AssignStmt {
    has target: Expr
    has value: Expr
    has span: Span

    docs {
        Assignment to a mutable location.
    }
}

/// Expression statement - expr;
pub gen ExprStmt {
    has expr: Expr
    has span: Span

    docs {
        Expression evaluated for side effects.
    }
}

/// Return statement - return expr
pub gen ReturnStmt {
    has value: Option<Expr>
    has span: Span

    docs {
        Early return from function.
    }
}

/// Break statement - break or break value
pub gen BreakStmt {
    has value: Option<Expr>
    has label: Option<string>
    has span: Span

    docs {
        Exit from loop, optionally with value.
    }
}

/// Continue statement - continue or continue 'label
pub gen ContinueStmt {
    has label: Option<string>
    has span: Span

    docs {
        Skip to next loop iteration.
    }
}

/// For statement - for item in iter { body }
pub gen ForStmt {
    has binding: string
    has iter: Expr
    has body: Block
    has span: Span

    docs {
        Iteration over a collection.
    }
}

/// While statement - while cond { body }
pub gen WhileStmt {
    has condition: Expr
    has body: Block
    has span: Span

    docs {
        Conditional loop.
    }
}

/// Loop statement - loop { body }
pub gen LoopStmt {
    has body: Block
    has label: Option<string>
    has span: Span

    docs {
        Infinite loop (exit with break).
    }
}

/// Match statement (non-expression form)
pub gen MatchStmt {
    has scrutinee: Expr
    has arms: List<MatchArm>
    has span: Span

    docs {
        Pattern matching as a statement.
    }
}
/// END OF Missing


/// Expression enumeration
pub gen Expr {
    type: enum {
        // ═══════════════════════════════════════════════════════════════
        // Literals
        // ═══════════════════════════════════════════════════════════════

        /// Integer literal: `42`, `-17`, `0xFF`
        IntLit { value: i64, suffix: Option<string> },

        /// Unsigned integer literal
        UIntLit { value: u64, suffix: Option<string> },

        /// Float literal: `3.14`, `1e-6`
        FloatLit { value: f64, suffix: Option<string> },

        /// String literal: `"hello"`
        StringLit { value: string, is_raw: bool },

        /// Character literal: `'a'`
        CharLit { value: char },

        /// Boolean literal: `true`, `false`
        BoolLit { value: bool },

        /// Null/None literal
        NullLit,

        // ═══════════════════════════════════════════════════════════════
        // Identifiers & Paths
        // ═══════════════════════════════════════════════════════════════

        /// Simple identifier: `foo`
        Ident { name: string },

        /// Qualified path: `foo.bar.baz`
        Path { segments: List<string> },

        /// This reference (within method context)
        This(ThisExpr),

        // ═══════════════════════════════════════════════════════════════
        // Operators
        // ═══════════════════════════════════════════════════════════════

        /// Binary operation: `a + b`, `x && y`
        Binary(BinaryExpr),

        /// Unary operation: `-x`, `!y`, `*p`
        Unary(UnaryExpr),

        // ═══════════════════════════════════════════════════════════════
        // Function Calls & Access
        // ═══════════════════════════════════════════════════════════════

        /// Function call: `foo(a, b)`
        Call(CallExpr),

        /// Method call: `x.foo(a, b)`
        MethodCall(MethodCallExpr),

        /// Field access: `x.foo`
        FieldAccess(FieldExpr),

        /// Index access: `a[i]`
        Index(IndexExpr),

        /// Range expression: `a..b`, `a..=b`, `..b`, `a..`
        Range { start: Option<Box<Expr>>, end: Option<Box<Expr>>, inclusive: bool },

        // ═══════════════════════════════════════════════════════════════
        // Constructors
        // ═══════════════════════════════════════════════════════════════

        /// Struct/gene construction: `Foo { x: 1, y: 2 }`
        Struct(StructExpr),

        /// Tuple construction: `(a, b, c)`
        TupleLit { elements: List<Expr> },

        /// Array literal: `[1, 2, 3]`
        ArrayLit(ArrayExpr),

        /// Array repeat: `[0; 100]`
        ArrayRepeat { element: Box<Expr>, count: Box<Expr> },

        // ═══════════════════════════════════════════════════════════════
        // Closures & Functions
        // ═══════════════════════════════════════════════════════════════

        /// Lambda/closure: `|x, y| x + y`
        Lambda(LambdaExpr),

        /// Block lambda: `|x| { let y = x * 2; y + 1 }`
        BlockLambda { params: List<LambdaParam>, body: Box<Block>, is_sex: bool },

        // ═══════════════════════════════════════════════════════════════
        // Control Flow Expressions
        // ═══════════════════════════════════════════════════════════════

        /// If expression: `if cond { a } else { b }`
        If(IfExpr),

        /// Match expression: `match x { A => 1, B => 2 }`
        Match(MatchExpr),

        /// Block expression: `{ stmt1; stmt2; expr }`
        Block { block: Box<Block> },

        // ═══════════════════════════════════════════════════════════════
        // Type Operations
        // ═══════════════════════════════════════════════════════════════

        /// Type cast: `x as T`
        Cast { expr: Box<Expr>, ty: TypeExpr },

        /// Type ascription: `x: T`
        Ascription { expr: Box<Expr>, ty: TypeExpr },

        /// Sizeof: `sizeof<T>`
        SizeOf { ty: TypeExpr },

        // ═══════════════════════════════════════════════════════════════
        // Meta-Programming Operations
        // ═══════════════════════════════════════════════════════════════

        /// Quote (AST capture): `'expr`
        Quote(QuoteExpr),

        /// Eval (AST execution): `!expr`
        Eval { inner: Box<Expr> },

        /// Quasi-quote (templating): `` `expr ``
        QuasiQuote { inner: Box<Expr> },

        /// Unquote (splice): `~expr`
        Unquote { inner: Box<Expr> },

        /// Reflection (type info): `?T`
        Reflect { ty: TypeExpr },

        /// Idiom brackets (applicative): `[| f x y |]`
        IdiomBracket { exprs: List<Expr> },

        /// Macro invocation: `#macro_name!(args)`
        MacroCall { name: string, bang: bool, args: List<Expr> },

        // ═══════════════════════════════════════════════════════════════
        // Error Recovery
        // ═══════════════════════════════════════════════════════════════

        /// Error expression (used during parsing errors)
        Error { message: string }
    }
    has span: Span
}

docs {
    A call argument may be positional or named.
}

/// Function call argument
pub gen CallArg {
    has name: Option<string>
    has value: Expr
    has span: Span
}

docs {
    A field initializer in struct construction.
}

/// Field initialization in struct literal
pub gen FieldInit {
    has name: string
    has value: Expr
    has span: Span
}

docs {
    A lambda parameter may have optional type annotation.
}

/// Lambda parameter
pub gen LambdaParam {
    has name: string
    has ty: Option<TypeExpr>
    has span: Span
}

docs {
    An else branch can be another if or a block.
}

/// Else branch in if expression
pub gen ElseBranch {
    type: enum {
        /// Else if: `else if cond { ... }`
        ElseIf { cond: Expr, then_block: Block, else_branch: Option<Box<ElseBranch>> },
        /// Final else: `else { ... }`
        Else { block: Block }
    }
    has span: Span
}

// =============================================================================
// OPERATORS
// =============================================================================

docs {
    Binary operators for two-operand expressions.
}

/// Binary operator enumeration
pub gen BinOp {
    type: enum {
        // Arithmetic
        Add,        // +
        Sub,        // -
        Mul,        // *
        Div,        // /
        Mod,        // %
        Pow,        // **

        // Comparison
        Eq,         // ==
        Ne,         // !=
        Lt,         // <
        Le,         // <=
        Gt,         // >
        Ge,         // >=

        // Logical
        And,        // &&
        Or,         // ||

        // Bitwise
        BitAnd,     // &
        BitOr,      // |
        BitXor,     // ^
        Shl,        // <<
        Shr,        // >>

        // Composition (functional)
        Pipe,       // |>  (forward pipe)
        Compose,    // >>  (forward compose)
        BackPipe,   // <|  (backward pipe)
        BackCompose,// <<  (backward compose)
        Apply,      // @   (apply)
        Bind,       // :=  (bind)
        Map,        // <$> (functor map)
        Ap,         // <*> (applicative apply)
        FlatMap,    // >>= (monadic bind)

        // Other
        Concat,     // ++
        Implies,    // =>
        Assign      // =
    }
}

docs {
    Unary operators for single-operand expressions.
}

/// Unary operator enumeration
pub gen UnaryOp {
    type: enum {
        Neg,        // -x  (numeric negation)
        Not,        // !x  (logical/bitwise not)
        Deref,      // *x  (dereference)
        Ref,        // &x  (reference)
        RefMut,     // &mut x
        Quote,      // 'x  (quote)
        Eval,       // !x  (eval in meta context)
        Reflect,    // ?T  (reflection)
        Try,        // x?  (try operator)
        Await       // x.await
    }
}

// =============================================================================
// PATTERN MATCHING
// =============================================================================

docs {
    Match arms connect patterns to expressions.
}

/// Match arm: `pattern [if guard] => body`
pub gen MatchArm {
    has pattern: Pattern
    has guard: Option<Expr>
    has body: Expr
    has span: Span
}

docs {
    Patterns destructure values and bind variables.
}

/// Pattern enumeration
pub gen Pattern {
    type: enum {
        /// Wildcard pattern: `_`
        Wildcard,

        /// Identifier pattern (binding): `x`, `mut x`
        Ident { name: string, is_mut: bool, binding: BindingMode },

        /// Literal pattern: `42`, `"hello"`, `true`
        Literal { value: Expr },

        /// Tuple pattern: `(a, b, c)`
        Tuple { elements: List<Pattern> },

        /// Array pattern: `[a, b, c]`, `[head, ..tail]`
        Array { elements: List<Pattern>, rest: Option<string> },

        /// Struct pattern: `Foo { x, y: z }`
        Struct { name: string, fields: List<FieldPattern>, rest: bool },

        /// Enum variant pattern: `Some(x)`, `None`
        Variant { path: List<string>, fields: List<Pattern> },

        /// Or pattern: `A | B | C`
        Or { patterns: List<Pattern> },

        /// Range pattern: `0..10`, `'a'..='z'`
        Range { start: Option<Expr>, end: Option<Expr>, inclusive: bool },

        /// Reference pattern: `&x`, `&mut x`
        Ref { pattern: Box<Pattern>, is_mut: bool },

        /// At pattern: `x @ Some(_)`
        At { name: string, pattern: Box<Pattern> },

        /// Parenthesized pattern: `(pattern)`
        Paren { inner: Box<Pattern> }
    }
    has span: Span
}

docs {
    A field pattern in struct destructuring.
}

/// Field pattern in struct matching
pub gen FieldPattern {
    has name: string
    has pattern: Option<Pattern>
    has span: Span
}

docs {
    Binding mode controls how pattern variables are bound.
}

/// Binding mode for pattern variables
pub gen BindingMode {
    type: enum {
        ByValue,
        ByRef,
        ByRefMut
    }
}

// =============================================================================
// STATEMENTS
// =============================================================================

docs {
    Statements are executed for their effects.
    Unlike expressions, statements do not produce values.
}

/// Statement enumeration - uses wrapper types for parser compatibility
pub gen Stmt {
    type: enum {
        /// Let binding: `let x = expr`, `let x: T = expr`
        Let(LetStmt),

        /// Variable declaration: `var x = expr`
        Var(VarStmt),

        /// Const declaration: `const X = expr`
        Const(ConstStmt),

        /// Assignment: `x = expr`, `a[i] = expr`
        Assign(AssignStmt),

        /// Expression statement: `expr;`
        Expr(ExprStmt),

        /// Return statement: `return expr`, `return`
        Return(ReturnStmt),

        /// Break statement: `break`, `break value`
        Break(BreakStmt),

        /// Continue statement: `continue`, `continue 'label`
        Continue(ContinueStmt),

        /// For loop: `for x in iter { body }`
        For(ForStmt),

        /// While loop: `while cond { body }`
        While(WhileStmt),

        /// Infinite loop: `loop { body }`
        Loop(LoopStmt),

        /// Labeled block: `'label: { ... }`
        Labeled { label: string, block: Block },

        /// Item statement (local declaration)
        Item { decl: Box<Decl> },

        /// Match statement
        Match(MatchStmt),

        /// Empty statement: `;`
        Empty
    }
    has span: Span
}

// =============================================================================
// BLOCKS
// =============================================================================

docs {
    A block is a sequence of statements with an optional trailing expression.
    The trailing expression (without semicolon) becomes the block's value.
}

/// Block with statements and optional final expression
pub gen Block {
    has stmts: List<Stmt>
    has expr: Option<Expr>
    has span: Span
}

// =============================================================================
// VISIBILITY
// =============================================================================

docs {
    Visibility controls access to declarations.
}

/// Visibility specifier
pub gen Visibility {
    type: enum {
        /// Private (default)
        Private,
        /// Public: `pub`
        Public,
        /// Crate-public: `pub(crate)`
        Crate,
        /// Module-public: `pub(super)`, `pub(in path)`
        Restricted { path: List<string> }
    }
    has span: Span
}

// =============================================================================
// ATTRIBUTES
// =============================================================================

docs {
    Attributes provide metadata for declarations.
}

/// Attribute on a declaration
pub gen Attribute {
    has name: string
    has args: List<AttrArg>
    has span: Span
}

docs {
    An attribute argument can be a simple value or key-value pair.
}

/// Attribute argument
pub gen AttrArg {
    type: enum {
        /// Simple value: `#[attr(value)]`
        Value { value: Expr },
        /// Key-value: `#[attr(key = value)]`
        KeyValue { key: string, value: Expr },
        /// Nested attribute: `#[attr(nested(...))]`
        Nested { attr: Attribute }
    }
    has span: Span
}

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

docs {
    Helper functions for working with AST nodes.
}

/// Create a simple identifier expression
pub fun ident(name: string, span: Span) -> Expr {
    return Expr {
        type: Expr.Ident { name: name },
        span: span
    }
}

/// Create an integer literal expression
pub fun int_lit(value: i64, span: Span) -> Expr {
    return Expr {
        type: Expr.IntLit { value: value, suffix: None },
        span: span
    }
}

/// Create a string literal expression
pub fun string_lit(value: string, span: Span) -> Expr {
    return Expr {
        type: Expr.StringLit { value: value, is_raw: false },
        span: span
    }
}

/// Create a boolean literal expression
pub fun bool_lit(value: bool, span: Span) -> Expr {
    return Expr {
        type: Expr.BoolLit { value: value },
        span: span
    }
}

/// Create a binary operation expression
pub fun binary(op: BinOp, left: Expr, right: Expr, span: Span) -> Expr {
    return Expr {
        type: Expr.Binary {
            op: op,
            left: Box.new(left),
            right: Box.new(right)
        },
        span: span
    }
}

/// Create a function call expression
pub fun call(callee: Expr, args: List<Expr>, span: Span) -> Expr {
    // Use the function's span for all args since Expr doesn't have a direct span accessor
    let call_args = args.map(|arg| CallArg { name: None, value: arg, span: span.clone() })
    return Expr {
        type: Expr.Call {
            callee: Box.new(callee),
            args: call_args
        },
        span: span
    }
}

/// Create an empty block
pub fun empty_block(span: Span) -> Block {
    return Block {
        stmts: [],
        expr: None,
        span: span
    }
}

/// Create a block with a single expression
pub fun expr_block(expr: Expr, span: Span) -> Block {
    return Block {
        stmts: [],
        expr: Some(expr),
        span: span
    }
}

/// Check if a type expression is a primitive type
pub fun is_primitive(ty: TypeExpr) -> bool {
    match ty.type {
        Int8 { return true }
        Int16 { return true }
        Int32 { return true }
        Int64 { return true }
        UInt8 { return true }
        UInt16 { return true }
        UInt32 { return true }
        UInt64 { return true }
        Float32 { return true }
        Float64 { return true }
        Bool { return true }
        String { return true }
        Char { return true }
        Void { return true }
        _ { return false }
    }
}

/// Get the name of a type expression (if it has one)
pub fun type_name(ty: TypeExpr) -> Option<string> {
    match ty.type {
        Named { path } {
            if path.length() > 0 {
                return Some(path[path.length() - 1].clone())
            }
            return None
        }
        Generic { name, args: _ } {
            return Some(name)
        }
        _ {
            return None
        }
    }
}
