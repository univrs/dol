//! Python Code Generation
//!
//! This module generates idiomatic Python code from DOL declarations.
//! Features:
//! - Dataclass generation from Gen declarations
//! - Type hints (PEP 484)
//! - Pydantic model support
//! - Docstrings

use crate::{CodegenContext, Result};
use dol::ast::{Declaration, DolFile, Gen, HasField, Statement, TypeExpr};
use heck::{ToPascalCase, ToSnakeCase};
use std::fmt::Write;

pub const GENERATOR_NAME: &str = "Python";

/// Generate Python code from a DOL file
pub fn generate(file: &DolFile, context: &CodegenContext) -> Result<String> {
    let mut output = String::new();

    // Generate header
    writeln!(
        output,
        "# Generated by DOL {} Code Generator",
        GENERATOR_NAME
    )
    .unwrap();
    writeln!(output, "# Do not edit manually\n").unwrap();

    // Generate imports
    generate_imports(&mut output, file, context)?;

    // Generate declarations
    for decl in &file.declarations {
        generate_declaration(&mut output, decl, context)?;
    }

    Ok(output)
}

/// Generate imports
fn generate_imports(output: &mut String, file: &DolFile, _context: &CodegenContext) -> Result<()> {
    writeln!(output, "from dataclasses import dataclass").unwrap();
    writeln!(output, "from typing import List, Optional, Dict, Set, Tuple, Any\n").unwrap();

    // Generate use declarations from file
    for use_decl in &file.uses {
        let path = use_decl.path.join(".");
        writeln!(output, "from {} import *", path).unwrap();
    }

    if !file.uses.is_empty() {
        writeln!(output).unwrap();
    }

    Ok(())
}

/// Generate code for a declaration
fn generate_declaration(
    output: &mut String,
    decl: &Declaration,
    context: &CodegenContext,
) -> Result<()> {
    match decl {
        Declaration::Gene(gen) => generate_gen(output, gen, context),
        Declaration::Trait(trait_) => {
            // Generate trait as a Python Protocol
            if context.include_docs && !trait_.exegesis.is_empty() {
                writeln!(output, "\"\"\"").unwrap();
                writeln!(output, "{}", trait_.exegesis).unwrap();
                writeln!(output, "\"\"\"").unwrap();
            }
            let trait_name = trait_.name.to_pascal_case();
            writeln!(output, "class {}:", trait_name).unwrap();
            writeln!(output, "    pass\n").unwrap();
            Ok(())
        }
        _ => Ok(()),
    }
}

/// Generate code for a Gen declaration
fn generate_gen(output: &mut String, gen: &Gen, context: &CodegenContext) -> Result<()> {
    let class_name = gen.name.to_pascal_case();

    // Generate docstring
    if context.include_docs && !gen.exegesis.is_empty() {
        writeln!(output, "\"\"\"").unwrap();
        writeln!(output, "{}", gen.exegesis).unwrap();
        writeln!(output, "\"\"\"").unwrap();
    }

    // Generate dataclass decorator
    writeln!(output, "@dataclass").unwrap();

    // Generate class declaration
    writeln!(output, "class {}:", class_name).unwrap();

    // Generate docstring if not already added
    if context.include_docs && !gen.exegesis.is_empty() {
        writeln!(output, "    \"\"\"{}\"\"\"", gen.exegesis).unwrap();
    }

    // Generate fields
    let mut has_fields = false;
    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            generate_field(output, field.as_ref(), context)?;
            has_fields = true;
        }
    }

    // If no fields, add pass
    if !has_fields {
        writeln!(output, "    pass").unwrap();
    }

    writeln!(output).unwrap();

    Ok(())
}

/// Generate a field
fn generate_field(output: &mut String, field: &HasField, _context: &CodegenContext) -> Result<()> {
    let field_name = field.name.to_snake_case();
    let field_type = map_type_expr(&field.type_);

    // Add CRDT annotation as a comment if present
    if let Some(crdt) = &field.crdt_annotation {
        writeln!(
            output,
            "    # CRDT strategy: {}",
            crdt.strategy.as_str()
        )
        .unwrap();
    }

    // Add personal data annotation
    if field.personal {
        writeln!(output, "    # Personal data (GDPR sensitive)").unwrap();
    }

    // Add default value if present
    if field.default.is_some() {
        writeln!(output, "    {}: {} = None", field_name, field_type).unwrap();
    } else {
        writeln!(output, "    {}: {}", field_name, field_type).unwrap();
    }

    Ok(())
}

/// Map DOL type expression to Python type
fn map_type_expr(type_expr: &TypeExpr) -> String {
    match type_expr {
        TypeExpr::Named(name) => match name.as_str() {
            "String" => "str".to_string(),
            "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128"
            | "Int32" | "Int64" => "int".to_string(),
            "f32" | "f64" | "Float32" | "Float64" => "float".to_string(),
            "bool" | "Bool" => "bool".to_string(),
            other => other.to_pascal_case(),
        },
        TypeExpr::Generic { name, args } => {
            let arg_strs: Vec<_> = args.iter().map(map_type_expr).collect();
            match name.as_str() {
                "Vec" | "List" => format!("List[{}]", arg_strs[0]),
                "Option" => format!("Optional[{}]", arg_strs[0]),
                "Result" => format!("Result[{}]", arg_strs.join(", ")),
                "Map" | "HashMap" => format!("Dict[{}]", arg_strs.join(", ")),
                "Set" | "HashSet" => format!("Set[{}]", arg_strs[0]),
                other => format!("{}[{}]", other.to_pascal_case(), arg_strs.join(", ")),
            }
        }
        TypeExpr::Function { params, return_type } => {
            let param_strs: Vec<_> = params.iter().map(map_type_expr).collect();
            let ret_str = map_type_expr(return_type);
            format!("Callable[[{}], {}]", param_strs.join(", "), ret_str)
        }
        TypeExpr::Tuple(types) => {
            let type_strs: Vec<_> = types.iter().map(map_type_expr).collect();
            format!("Tuple[{}]", type_strs.join(", "))
        }
        TypeExpr::Never => "NoReturn".to_string(),
        TypeExpr::Enum { .. } => "Enum".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dol::ast::{Span, Visibility};

    #[test]
    fn test_type_mapping() {
        let string_type = TypeExpr::Named("String".to_string());
        assert_eq!(map_type_expr(&string_type), "str");

        let vec_type = TypeExpr::Generic {
            name: "Vec".to_string(),
            args: vec![TypeExpr::Named("i32".to_string())],
        };
        assert_eq!(map_type_expr(&vec_type), "List[int]");
    }

    #[test]
    fn test_generate_simple_gen() {
        let gen = Gen {
            visibility: Visibility::Public,
            name: "Point".to_string(),
            extends: None,
            statements: vec![],
            exegesis: "A 2D point".to_string(),
            span: Span::default(),
        };

        let file = DolFile {
            module: None,
            uses: vec![],
            declarations: vec![Declaration::Gene(gen)],
        };

        let context = CodegenContext::new(crate::Target::Python);
        let code = generate(&file, &context).unwrap();

        assert!(code.contains("@dataclass"));
        assert!(code.contains("class Point:"));
        assert!(code.contains("A 2D point"));
    }
}
