//! WebAssembly Interface Types (WIT) Code Generation
//!
//! This module generates WIT definitions from DOL declarations.
//! Features:
//! - Record types from Gen declarations
//! - Interface definitions
//! - Component model support

use crate::{CodegenContext, Result};
use dol::ast::{Declaration, DolFile, Gen, HasField, Statement, TypeExpr};
use heck::{ToKebabCase, ToSnakeCase};
use std::fmt::Write;

pub const GENERATOR_NAME: &str = "WIT";

/// Generate WIT code from a DOL file
pub fn generate(file: &DolFile, context: &CodegenContext) -> Result<String> {
    let mut output = String::new();

    // Generate header
    writeln!(
        output,
        "// Generated by DOL {} Code Generator",
        GENERATOR_NAME
    )
    .unwrap();
    writeln!(output, "// Do not edit manually\n").unwrap();

    // Get package name
    let package_name = context
        .module_name
        .as_deref()
        .unwrap_or("generated")
        .to_kebab_case();

    // Generate package declaration
    writeln!(output, "package {}:types;\n", package_name).unwrap();

    // Generate world
    writeln!(output, "world {} {{", package_name).unwrap();

    // Generate imports
    for use_decl in &file.uses {
        let path = use_decl.path.join(":");
        writeln!(output, "  import {};", path).unwrap();
    }

    if !file.uses.is_empty() {
        writeln!(output).unwrap();
    }

    // Generate type exports
    for decl in &file.declarations {
        if let Declaration::Gene(_) = decl {
            let type_name = decl.name().to_kebab_case();
            writeln!(output, "  export {}: func() -> {};", type_name, type_name).unwrap();
        }
    }

    writeln!(output, "}}\n").unwrap();

    // Generate type declarations
    for decl in &file.declarations {
        generate_declaration(&mut output, decl, context)?;
    }

    Ok(output)
}

/// Generate code for a declaration
fn generate_declaration(
    output: &mut String,
    decl: &Declaration,
    context: &CodegenContext,
) -> Result<()> {
    match decl {
        Declaration::Gene(gen) => generate_gen(output, gen, context),
        Declaration::Trait(trait_) => {
            // Generate trait as a WIT interface
            let trait_name = trait_.name.to_kebab_case();
            if context.include_docs && !trait_.exegesis.is_empty() {
                writeln!(output, "/// {}", trait_.exegesis).unwrap();
            }
            writeln!(output, "interface {} {{}}\n", trait_name).unwrap();
            Ok(())
        }
        _ => Ok(()),
    }
}

/// Generate code for a Gen declaration
fn generate_gen(output: &mut String, gen: &Gen, context: &CodegenContext) -> Result<()> {
    let record_name = gen.name.to_kebab_case();

    // Generate documentation
    if context.include_docs && !gen.exegesis.is_empty() {
        writeln!(output, "/// {}", gen.exegesis).unwrap();
    }

    // Generate record declaration
    writeln!(output, "record {} {{", record_name).unwrap();

    // Generate fields
    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            generate_field(output, field.as_ref(), context)?;
        }
    }

    writeln!(output, "}}\n").unwrap();

    Ok(())
}

/// Generate a field
fn generate_field(output: &mut String, field: &HasField, _context: &CodegenContext) -> Result<()> {
    let field_name = field.name.to_kebab_case();
    let field_type = map_type_expr(&field.type_);

    // Add CRDT annotation as a comment if present
    if let Some(crdt) = &field.crdt_annotation {
        writeln!(
            output,
            "  /// CRDT strategy: {}",
            crdt.strategy.as_str()
        )
        .unwrap();
    }

    writeln!(output, "  {}: {},", field_name, field_type).unwrap();

    Ok(())
}

/// Map DOL type expression to WIT type
fn map_type_expr(type_expr: &TypeExpr) -> String {
    match type_expr {
        TypeExpr::Named(name) => match name.as_str() {
            "String" => "string".to_string(),
            "i8" => "s8".to_string(),
            "i16" => "s16".to_string(),
            "i32" | "Int32" => "s32".to_string(),
            "i64" | "Int64" => "s64".to_string(),
            "u8" => "u8".to_string(),
            "u16" => "u16".to_string(),
            "u32" => "u32".to_string(),
            "u64" => "u64".to_string(),
            "f32" | "Float32" => "f32".to_string(),
            "f64" | "Float64" => "f64".to_string(),
            "bool" | "Bool" => "bool".to_string(),
            other => other.to_kebab_case(),
        },
        TypeExpr::Generic { name, args } => {
            let arg_strs: Vec<_> = args.iter().map(map_type_expr).collect();
            match name.as_str() {
                "Vec" | "List" => format!("list<{}>", arg_strs[0]),
                "Option" => format!("option<{}>", arg_strs[0]),
                "Result" => format!("result<{}>", arg_strs.join(", ")),
                other => format!("{}<{}>", other.to_kebab_case(), arg_strs.join(", ")),
            }
        }
        TypeExpr::Tuple(types) => {
            let type_strs: Vec<_> = types.iter().map(map_type_expr).collect();
            format!("tuple<{}>", type_strs.join(", "))
        }
        _ => "u8".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dol::ast::{Span, Visibility};

    #[test]
    fn test_type_mapping() {
        let string_type = TypeExpr::Named("String".to_string());
        assert_eq!(map_type_expr(&string_type), "string");

        let vec_type = TypeExpr::Generic {
            name: "Vec".to_string(),
            args: vec![TypeExpr::Named("i32".to_string())],
        };
        assert_eq!(map_type_expr(&vec_type), "list<s32>");
    }

    #[test]
    fn test_generate_simple_gen() {
        let gen = Gen {
            visibility: Visibility::Public,
            name: "Point".to_string(),
            extends: None,
            statements: vec![],
            exegesis: "A 2D point".to_string(),
            span: Span::default(),
        };

        let file = DolFile {
            module: None,
            uses: vec![],
            declarations: vec![Declaration::Gene(gen)],
        };

        let context = CodegenContext::new(crate::Target::Wit);
        let code = generate(&file, &context).unwrap();

        assert!(code.contains("record point"));
        assert!(code.contains("/// A 2D point"));
    }
}
