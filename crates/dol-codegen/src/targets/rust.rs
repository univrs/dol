//! Rust Code Generation
//!
//! This module generates idiomatic Rust code from DOL declarations.
//! Features:
//! - Struct generation from Gen declarations
//! - Trait implementations
//! - Builder pattern support
//! - Serde support
//! - CRDT integration

use crate::{CodegenContext, CodegenError, Result};
use dol::ast::{Declaration, DolFile, Gen, HasField, Statement, TypeExpr};
use heck::{ToPascalCase, ToSnakeCase};
use std::fmt::Write;

pub const GENERATOR_NAME: &str = "Rust";

/// Generate Rust code from a DOL file
pub fn generate(file: &DolFile, context: &CodegenContext) -> Result<String> {
    let mut output = String::new();

    // Generate header
    writeln!(
        output,
        "// Generated by DOL {} Code Generator",
        GENERATOR_NAME
    )
    .unwrap();
    writeln!(output, "// Do not edit manually\n").unwrap();

    // Generate imports
    generate_imports(&mut output, file, context)?;

    // Generate declarations
    for decl in &file.declarations {
        generate_declaration(&mut output, decl, context)?;
    }

    Ok(output)
}

/// Generate imports
fn generate_imports(output: &mut String, file: &DolFile, context: &CodegenContext) -> Result<()> {
    if context.derive_serde {
        writeln!(output, "use serde::{{Serialize, Deserialize}};\n").unwrap();
    }

    // Generate use declarations from file
    for use_decl in &file.uses {
        let path = use_decl.path.join("::");
        writeln!(output, "use {};", path).unwrap();
    }

    if !file.uses.is_empty() {
        writeln!(output).unwrap();
    }

    Ok(())
}

/// Generate code for a declaration
fn generate_declaration(
    output: &mut String,
    decl: &Declaration,
    context: &CodegenContext,
) -> Result<()> {
    match decl {
        Declaration::Gene(gen) => generate_gen(output, gen, context),
        Declaration::Trait(trait_) => {
            // Generate trait as a Rust trait
            if context.include_docs && !trait_.exegesis.is_empty() {
                writeln!(output, "/// {}", trait_.exegesis).unwrap();
            }
            let trait_name = trait_.name.to_pascal_case();
            writeln!(output, "pub trait {} {{}}\n", trait_name).unwrap();
            Ok(())
        }
        _ => Ok(()),
    }
}

/// Generate code for a Gen declaration
fn generate_gen(output: &mut String, gen: &Gen, context: &CodegenContext) -> Result<()> {
    let struct_name = gen.name.to_pascal_case();

    // Generate documentation
    if context.include_docs && !gen.exegesis.is_empty() {
        writeln!(output, "/// {}", gen.exegesis).unwrap();
    }

    // Generate derives
    let mut derives = vec!["Debug", "Clone", "PartialEq"];
    if context.derive_serde {
        derives.push("Serialize");
        derives.push("Deserialize");
    }
    writeln!(output, "#[derive({})]", derives.join(", ")).unwrap();

    // Generate struct declaration
    writeln!(output, "pub struct {} {{", struct_name).unwrap();

    // Generate fields
    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            generate_field(output, field.as_ref(), context)?;
        }
    }

    writeln!(output, "}}\n").unwrap();

    // Generate impl block
    generate_impl(output, gen, context)?;

    // Generate builder pattern if requested
    if context.generate_builders {
        generate_builder(output, gen, context)?;
    }

    Ok(())
}

/// Generate a field
fn generate_field(output: &mut String, field: &HasField, context: &CodegenContext) -> Result<()> {
    let field_name = field.name.to_snake_case();
    let field_type = map_type_expr(&field.type_);

    // Add CRDT annotation as a comment if present
    if let Some(crdt) = &field.crdt_annotation {
        writeln!(
            output,
            "    /// CRDT strategy: {}",
            crdt.strategy.as_str()
        )
        .unwrap();
    }

    // Add personal data annotation
    if field.personal {
        writeln!(output, "    /// Personal data (GDPR sensitive)").unwrap();
    }

    writeln!(output, "    pub {}: {},", field_name, field_type).unwrap();

    Ok(())
}

/// Generate impl block
fn generate_impl(output: &mut String, gen: &Gen, _context: &CodegenContext) -> Result<()> {
    let struct_name = gen.name.to_pascal_case();

    writeln!(output, "impl {} {{", struct_name).unwrap();

    // Generate new() constructor
    writeln!(output, "    /// Create a new instance").unwrap();
    write!(output, "    pub fn new(").unwrap();

    // Collect fields
    let fields: Vec<&HasField> = gen
        .statements
        .iter()
        .filter_map(|stmt| {
            if let Statement::HasField(field) = stmt {
                Some(field.as_ref())
            } else {
                None
            }
        })
        .collect();

    // Generate parameters
    for (i, field) in fields.iter().enumerate() {
        let field_name = field.name.to_snake_case();
        let field_type = map_type_expr(&field.type_);
        write!(output, "{}: {}", field_name, field_type).unwrap();
        if i < fields.len() - 1 {
            write!(output, ", ").unwrap();
        }
    }

    writeln!(output, ") -> Self {{").unwrap();
    writeln!(output, "        Self {{").unwrap();

    // Generate field assignments
    for field in &fields {
        let field_name = field.name.to_snake_case();
        writeln!(output, "            {},", field_name).unwrap();
    }

    writeln!(output, "        }}").unwrap();
    writeln!(output, "    }}").unwrap();

    writeln!(output, "}}\n").unwrap();

    Ok(())
}

/// Generate builder pattern
fn generate_builder(output: &mut String, gen: &Gen, context: &CodegenContext) -> Result<()> {
    let struct_name = gen.name.to_pascal_case();
    let builder_name = format!("{}Builder", struct_name);

    // Generate builder struct
    writeln!(output, "/// Builder for {}", struct_name).unwrap();
    writeln!(output, "#[derive(Default)]").unwrap();
    writeln!(output, "pub struct {} {{", builder_name).unwrap();

    // Generate optional fields
    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            let field_name = field.name.to_snake_case();
            let field_type = map_type_expr(&field.type_);
            writeln!(output, "    {}: Option<{}>,", field_name, field_type).unwrap();
        }
    }

    writeln!(output, "}}\n").unwrap();

    // Generate builder impl
    writeln!(output, "impl {} {{", builder_name).unwrap();
    writeln!(output, "    /// Create a new builder").unwrap();
    writeln!(output, "    pub fn new() -> Self {{").unwrap();
    writeln!(output, "        Self::default()").unwrap();
    writeln!(output, "    }}\n").unwrap();

    // Generate setter methods
    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            let field_name = field.name.to_snake_case();
            let field_type = map_type_expr(&field.type_);

            writeln!(output, "    /// Set {}", field_name).unwrap();
            writeln!(
                output,
                "    pub fn {}(mut self, value: {}) -> Self {{",
                field_name, field_type
            )
            .unwrap();
            writeln!(output, "        self.{} = Some(value);", field_name).unwrap();
            writeln!(output, "        self").unwrap();
            writeln!(output, "    }}\n").unwrap();
        }
    }

    // Generate build method
    writeln!(output, "    /// Build the {}", struct_name).unwrap();
    writeln!(
        output,
        "    pub fn build(self) -> Result<{}, String> {{",
        struct_name
    )
    .unwrap();
    writeln!(output, "        Ok({} {{", struct_name).unwrap();

    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            let field_name = field.name.to_snake_case();
            writeln!(
                output,
                "            {}: self.{}.ok_or_else(|| \"Missing field: {}\".to_string())?,",
                field_name, field_name, field_name
            )
            .unwrap();
        }
    }

    writeln!(output, "        }})").unwrap();
    writeln!(output, "    }}").unwrap();
    writeln!(output, "}}\n").unwrap();

    Ok(())
}

/// Map DOL type expression to Rust type
fn map_type_expr(type_expr: &TypeExpr) -> String {
    match type_expr {
        TypeExpr::Named(name) => match name.as_str() {
            "String" => "String".to_string(),
            "i8" => "i8".to_string(),
            "i16" => "i16".to_string(),
            "i32" | "Int32" => "i32".to_string(),
            "i64" | "Int64" => "i64".to_string(),
            "i128" => "i128".to_string(),
            "u8" => "u8".to_string(),
            "u16" => "u16".to_string(),
            "u32" => "u32".to_string(),
            "u64" => "u64".to_string(),
            "u128" => "u128".to_string(),
            "f32" | "Float32" => "f32".to_string(),
            "f64" | "Float64" => "f64".to_string(),
            "bool" | "Bool" => "bool".to_string(),
            other => other.to_pascal_case(),
        },
        TypeExpr::Generic { name, args } => {
            let arg_strs: Vec<_> = args.iter().map(map_type_expr).collect();
            match name.as_str() {
                "Vec" | "List" => format!("Vec<{}>", arg_strs.join(", ")),
                "Option" => format!("Option<{}>", arg_strs.join(", ")),
                "Result" => format!("Result<{}>", arg_strs.join(", ")),
                "Map" | "HashMap" => format!("HashMap<{}>", arg_strs.join(", ")),
                "Set" | "HashSet" => format!("HashSet<{}>", arg_strs.join(", ")),
                other => format!("{}<{}>", other.to_pascal_case(), arg_strs.join(", ")),
            }
        }
        TypeExpr::Function { params, return_type } => {
            let param_strs: Vec<_> = params.iter().map(map_type_expr).collect();
            let ret_str = map_type_expr(return_type);
            format!("fn({}) -> {}", param_strs.join(", "), ret_str)
        }
        TypeExpr::Tuple(types) => {
            let type_strs: Vec<_> = types.iter().map(map_type_expr).collect();
            format!("({})", type_strs.join(", "))
        }
        TypeExpr::Never => "!".to_string(),
        TypeExpr::Enum { .. } => "Enum".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dol::ast::{Span, Visibility};

    #[test]
    fn test_type_mapping() {
        let string_type = TypeExpr::Named("String".to_string());
        assert_eq!(map_type_expr(&string_type), "String");

        let vec_type = TypeExpr::Generic {
            name: "Vec".to_string(),
            args: vec![TypeExpr::Named("i32".to_string())],
        };
        assert_eq!(map_type_expr(&vec_type), "Vec<i32>");
    }

    #[test]
    fn test_generate_simple_gen() {
        let gen = Gen {
            visibility: Visibility::Public,
            name: "Point".to_string(),
            extends: None,
            statements: vec![],
            exegesis: "A 2D point".to_string(),
            span: Span::default(),
        };

        let file = DolFile {
            module: None,
            uses: vec![],
            declarations: vec![Declaration::Gene(gen)],
        };

        let context = CodegenContext::new(crate::Target::Rust);
        let code = generate(&file, &context).unwrap();

        assert!(code.contains("pub struct Point"));
        assert!(code.contains("/// A 2D point"));
    }
}
