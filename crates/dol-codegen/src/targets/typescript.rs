//! TypeScript Code Generation
//!
//! This module generates idiomatic TypeScript code from DOL declarations.
//! Features:
//! - Interface generation from Gen declarations
//! - Class generation with decorators
//! - Type-safe CRDT integration
//! - JSDoc comments

use crate::{CodegenContext, Result};
use dol::ast::{Declaration, DolFile, Gen, HasField, Statement, TypeExpr};
use heck::{ToPascalCase, ToSnakeCase};
use std::fmt::Write;

pub const GENERATOR_NAME: &str = "TypeScript";

/// Generate TypeScript code from a DOL file
pub fn generate(file: &DolFile, context: &CodegenContext) -> Result<String> {
    let mut output = String::new();

    // Generate header
    writeln!(
        output,
        "// Generated by DOL {} Code Generator",
        GENERATOR_NAME
    )
    .unwrap();
    writeln!(output, "// Do not edit manually\n").unwrap();

    // Generate imports
    generate_imports(&mut output, file, context)?;

    // Generate declarations
    for decl in &file.declarations {
        generate_declaration(&mut output, decl, context)?;
    }

    Ok(output)
}

/// Generate imports
fn generate_imports(output: &mut String, file: &DolFile, _context: &CodegenContext) -> Result<()> {
    // Generate use declarations from file
    for use_decl in &file.uses {
        let path = use_decl.path.join("/");
        writeln!(output, "import {{ }} from '{}';", path).unwrap();
    }

    if !file.uses.is_empty() {
        writeln!(output).unwrap();
    }

    Ok(())
}

/// Generate code for a declaration
fn generate_declaration(
    output: &mut String,
    decl: &Declaration,
    context: &CodegenContext,
) -> Result<()> {
    match decl {
        Declaration::Gene(gen) => generate_gen(output, gen, context),
        Declaration::Trait(trait_) => {
            // Generate trait as a TypeScript interface
            if context.include_docs && !trait_.exegesis.is_empty() {
                writeln!(output, "/**").unwrap();
                writeln!(output, " * {}", trait_.exegesis).unwrap();
                writeln!(output, " */").unwrap();
            }
            let trait_name = trait_.name.to_pascal_case();
            writeln!(output, "export interface {} {{}}\n", trait_name).unwrap();
            Ok(())
        }
        _ => Ok(()),
    }
}

/// Generate code for a Gen declaration
fn generate_gen(output: &mut String, gen: &Gen, context: &CodegenContext) -> Result<()> {
    let class_name = gen.name.to_pascal_case();

    // Generate JSDoc documentation
    if context.include_docs && !gen.exegesis.is_empty() {
        writeln!(output, "/**").unwrap();
        writeln!(output, " * {}", gen.exegesis).unwrap();
        writeln!(output, " */").unwrap();
    }

    // Generate interface
    writeln!(output, "export interface {} {{", class_name).unwrap();

    // Generate fields
    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            generate_field(output, field.as_ref(), context)?;
        }
    }

    writeln!(output, "}}\n").unwrap();

    // Generate class implementation
    writeln!(output, "export class {} implements {} {{", class_name, class_name).unwrap();

    // Generate field declarations
    for stmt in &gen.statements {
        if let Statement::HasField(field) = stmt {
            let field_name = field.name.to_snake_case();
            let field_type = map_type_expr(&field.type_);
            writeln!(output, "  {}: {};", field_name, field_type).unwrap();
        }
    }

    writeln!(output).unwrap();

    // Generate constructor
    generate_constructor(output, gen, context)?;

    writeln!(output, "}}\n").unwrap();

    Ok(())
}

/// Generate a field
fn generate_field(output: &mut String, field: &HasField, context: &CodegenContext) -> Result<()> {
    let field_name = field.name.to_snake_case();
    let field_type = map_type_expr(&field.type_);

    // Add CRDT annotation as a comment if present
    if let Some(crdt) = &field.crdt_annotation {
        writeln!(
            output,
            "  /** CRDT strategy: {} */",
            crdt.strategy.as_str()
        )
        .unwrap();
    }

    writeln!(output, "  {}: {};", field_name, field_type).unwrap();

    Ok(())
}

/// Generate constructor
fn generate_constructor(output: &mut String, gen: &Gen, _context: &CodegenContext) -> Result<()> {
    write!(output, "  constructor(").unwrap();

    // Collect fields
    let fields: Vec<&HasField> = gen
        .statements
        .iter()
        .filter_map(|stmt| {
            if let Statement::HasField(field) = stmt {
                Some(field.as_ref())
            } else {
                None
            }
        })
        .collect();

    // Generate parameters
    for (i, field) in fields.iter().enumerate() {
        let field_name = field.name.to_snake_case();
        let field_type = map_type_expr(&field.type_);
        write!(output, "{}: {}", field_name, field_type).unwrap();
        if i < fields.len() - 1 {
            write!(output, ", ").unwrap();
        }
    }

    writeln!(output, ") {{").unwrap();

    // Generate field assignments
    for field in &fields {
        let field_name = field.name.to_snake_case();
        writeln!(output, "    this.{} = {};", field_name, field_name).unwrap();
    }

    writeln!(output, "  }}").unwrap();

    Ok(())
}

/// Map DOL type expression to TypeScript type
fn map_type_expr(type_expr: &TypeExpr) -> String {
    match type_expr {
        TypeExpr::Named(name) => match name.as_str() {
            "String" => "string".to_string(),
            "i8" | "i16" | "i32" | "i64" | "i128" | "u8" | "u16" | "u32" | "u64" | "u128"
            | "f32" | "f64" | "Int32" | "Int64" | "Float32" | "Float64" => "number".to_string(),
            "bool" | "Bool" => "boolean".to_string(),
            other => other.to_pascal_case(),
        },
        TypeExpr::Generic { name, args } => {
            let arg_strs: Vec<_> = args.iter().map(map_type_expr).collect();
            match name.as_str() {
                "Vec" | "List" => format!("{}[]", arg_strs[0]),
                "Option" => format!("{} | null", arg_strs[0]),
                "Result" => format!("Result<{}>", arg_strs.join(", ")),
                "Map" | "HashMap" => format!("Map<{}>", arg_strs.join(", ")),
                "Set" | "HashSet" => format!("Set<{}>", arg_strs[0]),
                other => format!("{}<{}>", other.to_pascal_case(), arg_strs.join(", ")),
            }
        }
        TypeExpr::Function { params, return_type } => {
            let param_strs: Vec<_> = params
                .iter()
                .enumerate()
                .map(|(i, t)| format!("p{}: {}", i, map_type_expr(t)))
                .collect();
            let ret_str = map_type_expr(return_type);
            format!("({}) => {}", param_strs.join(", "), ret_str)
        }
        TypeExpr::Tuple(types) => {
            let type_strs: Vec<_> = types.iter().map(map_type_expr).collect();
            format!("[{}]", type_strs.join(", "))
        }
        TypeExpr::Never => "never".to_string(),
        TypeExpr::Enum { .. } => "Enum".to_string(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dol::ast::{Span, Visibility};

    #[test]
    fn test_type_mapping() {
        let string_type = TypeExpr::Named("String".to_string());
        assert_eq!(map_type_expr(&string_type), "string");

        let vec_type = TypeExpr::Generic {
            name: "Vec".to_string(),
            args: vec![TypeExpr::Named("i32".to_string())],
        };
        assert_eq!(map_type_expr(&vec_type), "number[]");
    }

    #[test]
    fn test_generate_simple_gen() {
        let gen = Gen {
            visibility: Visibility::Public,
            name: "Point".to_string(),
            extends: None,
            statements: vec![],
            exegesis: "A 2D point".to_string(),
            span: Span::default(),
        };

        let file = DolFile {
            module: None,
            uses: vec![],
            declarations: vec![Declaration::Gene(gen)],
        };

        let context = CodegenContext::new(crate::Target::TypeScript);
        let code = generate(&file, &context).unwrap();

        assert!(code.contains("export interface Point"));
        assert!(code.contains("export class Point"));
        assert!(code.contains("* A 2D point"));
    }
}
