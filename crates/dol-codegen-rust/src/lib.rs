//! DOL Rust Code Generation with Automerge Backend
//!
//! This crate provides code generation for transforming DOL declarations into
//! Rust code with Automerge CRDT backing for local-first applications.
//!
//! # Features
//!
//! - Generate Automerge-backed structs from DOL Gen declarations
//! - WASM bindings for browser/JavaScript interop
//! - Type-safe CRDT merge strategies based on `@crdt(...)` annotations
//! - Constraint enforcement during merge operations
//!
//! # Example
//!
//! ```rust
//! use dol_codegen_rust::{generate_rust, CodegenOptions, Target};
//! use dol::parse_dol_file;
//!
//! let source = r#"
//! gen ChatMessage {
//!   @crdt(immutable)
//!   message has id: String
//!
//!   @crdt(peritext)
//!   message has content: String
//!
//!   @crdt(or_set)
//!   message has reactions: Set<String>
//! }
//!
//! exegesis {
//!   A chat message with CRDT-based collaborative editing.
//! }
//! "#;
//!
//! let file = parse_dol_file(source).unwrap();
//! let options = CodegenOptions {
//!     target: Target::Rust,
//!     ..Default::default()
//! };
//!
//! // Generate Automerge-backed Rust code
//! // let code = generate_rust(&decl, &options).unwrap();
//! ```

pub mod automerge_backend;
pub mod migration_codegen;
pub mod type_mapper;

#[cfg(feature = "wasm")]
pub mod wasm_bindings;

use dol::ast::{Declaration, DolFile, Gen, Statement};
use thiserror::Error;

/// Code generation errors
#[derive(Debug, Error)]
pub enum CodegenError {
    #[error("Unsupported declaration type: {0}")]
    UnsupportedDeclaration(String),

    #[error("Type mapping error: {0}")]
    TypeMapping(String),

    #[error("CRDT annotation error: {0}")]
    CrdtAnnotation(String),

    #[error("Template rendering error: {0}")]
    Template(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}

/// Code generation target
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum Target {
    /// Standard Rust code
    #[default]
    Rust,
    /// Automerge-backed Rust code
    AutomergeRust,
    /// WASM with JavaScript bindings
    Wasm,
}

/// Code generation options
#[derive(Debug, Clone, Default)]
pub struct CodegenOptions {
    /// Target platform
    pub target: Target,

    /// Include documentation comments
    pub include_docs: bool,

    /// Generate builder pattern methods
    pub generate_builders: bool,

    /// Generate Debug, Clone derives
    pub derive_debug_clone: bool,

    /// Generate serde Serialize/Deserialize derives
    pub derive_serde: bool,

    /// Custom module name (defaults to file name)
    pub module_name: Option<String>,
}

/// Generate Rust code from a DOL file
pub fn generate_rust(file: &DolFile, options: &CodegenOptions) -> Result<String, CodegenError> {
    let mut output = String::new();

    // Generate header
    output.push_str("// Generated by DOL Automerge Codegen\n");
    output.push_str("// Do not edit manually\n\n");

    // Process each declaration
    for decl in &file.declarations {
        match decl {
            Declaration::Gene(gen) => {
                let code = generate_gen(gen, options)?;
                output.push_str(&code);
                output.push_str("\n\n");
            }
            Declaration::Trait(_) => {
                // Traits don't generate Automerge structs
                continue;
            }
            Declaration::Constraint(_) => {
                // Rules are used for constraint validation
                continue;
            }
            Declaration::System(_) => {
                // Systems are higher-level compositions
                continue;
            }
            Declaration::Evolution(_) => {
                // Evolutions define migrations
                continue;
            }
            Declaration::Function(_) => {
                // Functions are not part of the data model
                continue;
            }
            Declaration::Const(_) => {
                // Constants are not part of the data model
                continue;
            }
            Declaration::SexVar(_) => {
                // Sex variables are not part of the data model
                continue;
            }
        }
    }

    Ok(output)
}

/// Generate code for a single Gen declaration
fn generate_gen(gen: &Gen, options: &CodegenOptions) -> Result<String, CodegenError> {
    // Check if this gen has CRDT annotations
    let has_crdt = has_crdt_annotations(gen);

    if has_crdt && options.target != Target::Rust {
        // Generate Automerge-backed struct
        automerge_backend::generate_automerge_struct(gen, options)
    } else {
        // Generate standard struct
        generate_standard_struct(gen, options)
    }
}

/// Check if a Gen has any CRDT annotations
fn has_crdt_annotations(gen: &Gen) -> bool {
    gen.statements.iter().any(|stmt| {
        if let Statement::HasField(field) = stmt {
            field.crdt_annotation.is_some()
        } else {
            false
        }
    })
}

/// Generate a standard Rust struct (no CRDT backing)
fn generate_standard_struct(gen: &Gen, options: &CodegenOptions) -> Result<String, CodegenError> {
    use quote::quote;

    let struct_name = dol::codegen::to_pascal_case(&gen.name);
    let struct_ident = syn::parse_str::<syn::Ident>(&struct_name)
        .map_err(|e| CodegenError::TypeMapping(e.to_string()))?;

    // Extract fields
    let fields = extract_fields(gen);
    let field_tokens: Vec<_> = fields
        .iter()
        .map(|field| {
            let field_name = dol::codegen::to_snake_case(&field.name);
            let field_ident = syn::parse_str::<syn::Ident>(&field_name)
                .expect("Valid field identifier");
            let field_type = type_mapper::map_type_expr(&field.type_);
            let field_type_tokens = syn::parse_str::<syn::Type>(&field_type)
                .expect("Valid type");

            quote! {
                pub #field_ident: #field_type_tokens
            }
        })
        .collect();

    // Generate derives
    let mut derives = vec![quote! { Debug }, quote! { Clone }];
    if options.derive_serde {
        derives.push(quote! { serde::Serialize });
        derives.push(quote! { serde::Deserialize });
    }

    let tokens = quote! {
        #[derive(#(#derives),*)]
        pub struct #struct_ident {
            #(#field_tokens),*
        }
    };

    Ok(tokens.to_string())
}

/// Extract HasField statements from a Gen
fn extract_fields(gen: &Gen) -> Vec<&dol::ast::HasField> {
    gen.statements
        .iter()
        .filter_map(|stmt| {
            if let Statement::HasField(field) = stmt {
                Some(field.as_ref())
            } else {
                None
            }
        })
        .collect()
}

