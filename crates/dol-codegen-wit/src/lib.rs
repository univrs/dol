//! DOL WIT (WebAssembly Interface Types) Code Generation
//!
//! This crate provides code generation for transforming DOL Gen declarations into
//! WIT interface definitions for the WASM Component Model.
//!
//! # Features
//!
//! - Generate WIT record types from DOL Gen declarations
//! - Map DOL types to WIT types (including CRDT-annotated fields)
//! - Generate CRDT merge and serialization functions
//! - Clean component boundaries for WASM composition
//!
//! # Example
//!
//! ```rust
//! use dol_codegen_wit::{generate_wit, WitOptions};
//! use metadol::{Parser, parse_file};
//! use metadol::ast::{CrdtAnnotation, CrdtStrategy, Declaration, DolFile, Gen, HasField, Span, Statement, TypeExpr, Visibility};
//!
//! // Create a Gen with CRDT annotations
//! let gen = Gen {
//!     visibility: Visibility::Public,
//!     name: "ChatMessage".to_string(),
//!     extends: None,
//!     statements: vec![
//!         Statement::HasField(Box::new(HasField {
//!             name: "id".to_string(),
//!             type_: TypeExpr::Named("String".to_string()),
//!             default: None,
//!             constraint: None,
//!             crdt_annotation: Some(CrdtAnnotation {
//!                 strategy: CrdtStrategy::Immutable,
//!                 options: vec![],
//!                 span: Span::default(),
//!             }),
//!             span: Span::default(),
//!         })),
//!     ],
//!     exegesis: "A chat message".to_string(),
//!     span: Span::default(),
//! };
//!
//! let file = DolFile {
//!     module: None,
//!     uses: vec![],
//!     declarations: vec![Declaration::Gene(gen)],
//! };
//!
//! let options = WitOptions::default();
//!
//! // Generate WIT interface
//! let wit_code = generate_wit(&file, &options).unwrap();
//! ```

pub mod type_mapper;

use metadol::ast::{Declaration, DolFile, Gen, HasField, Statement};
use std::collections::HashSet;
use thiserror::Error;

/// WIT code generation errors
#[derive(Debug, Error)]
pub enum WitError {
    #[error("Unsupported declaration type: {0}")]
    UnsupportedDeclaration(String),

    #[error("Type mapping error: {0}")]
    TypeMapping(String),

    #[error("CRDT annotation error: {0}")]
    CrdtAnnotation(String),

    #[error("Invalid WIT identifier: {0}")]
    InvalidIdentifier(String),

    #[error("No Gen declarations found in file")]
    NoGenDeclarations,
}

/// WIT code generation options
#[derive(Debug, Clone)]
pub struct WitOptions {
    /// Package name for WIT interface (e.g., "univrs:message")
    pub package_name: Option<String>,

    /// Package version (e.g., "1.0.0")
    pub package_version: Option<String>,

    /// Include documentation comments
    pub include_docs: bool,

    /// Generate merge functions for CRDT types
    pub generate_merge_functions: bool,

    /// Generate serialization functions (to-bytes, from-bytes)
    pub generate_serialization: bool,
}

impl Default for WitOptions {
    fn default() -> Self {
        Self {
            package_name: None,
            package_version: Some("1.0.0".to_string()),
            include_docs: true,
            generate_merge_functions: true,
            generate_serialization: true,
        }
    }
}

/// Generate WIT code from a DOL file
pub fn generate_wit(file: &DolFile, options: &WitOptions) -> Result<String, WitError> {
    let mut output = String::new();

    // Extract Gen declarations
    let gens: Vec<&Gen> = file
        .declarations
        .iter()
        .filter_map(|decl| match decl {
            Declaration::Gene(gen) => Some(gen),
            _ => None,
        })
        .collect();

    if gens.is_empty() {
        return Err(WitError::NoGenDeclarations);
    }

    // Generate package header if package name provided
    if let Some(pkg_name) = &options.package_name {
        let version = options.package_version.as_deref().unwrap_or("1.0.0");
        output.push_str(&format!("package {}@{};\n\n", pkg_name, version));
    }

    // Generate comment header
    output.push_str("// Generated by DOL WIT Codegen\n");
    output.push_str("// Do not edit manually\n\n");

    // Process each Gen declaration
    for gen in &gens {
        let wit_code = generate_gen_interface(gen, options)?;
        output.push_str(&wit_code);
        output.push_str("\n\n");
    }

    Ok(output)
}

/// Generate WIT interface for a single Gen declaration
pub fn generate_gen_interface(gen: &Gen, options: &WitOptions) -> Result<String, WitError> {
    let mut output = String::new();

    // Interface name (kebab-case)
    let interface_name = type_mapper::to_wit_case(&gen.name);

    // Start interface block
    output.push_str(&format!("interface {} {{\n", interface_name));

    // Generate documentation if enabled
    if options.include_docs && !gen.exegesis.is_empty() {
        for line in gen.exegesis.lines() {
            if !line.trim().is_empty() {
                output.push_str(&format!("  /// {}\n", line.trim()));
            }
        }
    }

    // Generate record type
    let record_name = type_mapper::to_wit_case(&gen.name);
    output.push_str(&format!("  record {} {{\n", record_name));

    // Extract fields
    let fields = extract_fields(gen);

    // Track if we have any CRDT fields
    let has_crdt_fields = fields
        .iter()
        .any(|field| field.crdt_annotation.is_some());

    // Generate field declarations
    for field in &fields {
        // Add comment for CRDT strategy if present
        if let Some(crdt_ann) = &field.crdt_annotation {
            output.push_str(&format!(
                "    /// @crdt({})\n",
                crdt_ann.strategy.as_str()
            ));
        }

        let field_name = type_mapper::to_wit_field_name(&field.name);
        let field_type = type_mapper::map_type_expr(&field.type_);

        output.push_str(&format!("    {}: {},\n", field_name, field_type));
    }

    output.push_str("  }\n\n");

    // Generate CRDT merge function if requested
    if options.generate_merge_functions && has_crdt_fields {
        output.push_str(&format!(
            "  /// Merge two {} instances using CRDT semantics\n",
            record_name
        ));
        output.push_str(&format!(
            "  merge: func(a: {}, b: {}) -> {};\n\n",
            record_name, record_name, record_name
        ));
    }

    // Generate serialization functions if requested
    if options.generate_serialization {
        output.push_str(&format!(
            "  /// Serialize {} to bytes (Automerge format)\n",
            record_name
        ));
        output.push_str(&format!(
            "  to-bytes: func(value: {}) -> list<u8>;\n\n",
            record_name
        ));

        output.push_str(&format!(
            "  /// Deserialize {} from bytes (Automerge format)\n",
            record_name
        ));
        output.push_str(&format!(
            "  from-bytes: func(data: list<u8>) -> result<{}, string>;\n",
            record_name
        ));
    }

    // Close interface block
    output.push_str("}\n");

    Ok(output)
}

/// Extract HasField statements from a Gen
fn extract_fields(gen: &Gen) -> Vec<&HasField> {
    gen.statements
        .iter()
        .filter_map(|stmt| match stmt {
            Statement::HasField(field) => Some(field.as_ref()),
            _ => None,
        })
        .collect()
}

/// Generate a WIT world declaration for a component
pub fn generate_world(
    file: &DolFile,
    world_name: &str,
    _options: &WitOptions,
) -> Result<String, WitError> {
    let mut output = String::new();

    // Extract interface names
    let interface_names: Vec<String> = file
        .declarations
        .iter()
        .filter_map(|decl| match decl {
            Declaration::Gene(gen) => Some(type_mapper::to_wit_case(&gen.name)),
            _ => None,
        })
        .collect();

    if interface_names.is_empty() {
        return Err(WitError::NoGenDeclarations);
    }

    // Generate world declaration
    let world_name_kebab = type_mapper::to_wit_case(world_name);
    output.push_str(&format!("world {} {{\n", world_name_kebab));

    // Export all interfaces
    for interface_name in &interface_names {
        output.push_str(&format!("  export {};\n", interface_name));
    }

    output.push_str("}\n");

    Ok(output)
}

/// Validate that a Gen declaration can be converted to WIT
pub fn validate_gen_for_wit(gen: &Gen) -> Result<(), WitError> {
    // Check for valid fields
    let fields = extract_fields(gen);

    if fields.is_empty() {
        return Err(WitError::TypeMapping(format!(
            "Gen '{}' has no fields, cannot generate WIT record",
            gen.name
        )));
    }

    // Validate field types can be mapped to WIT
    for field in fields {
        // Try mapping the type to ensure it's valid
        let _ = type_mapper::map_type_expr(&field.type_);
    }

    Ok(())
}

/// Get the list of CRDT strategies used in a Gen
pub fn get_crdt_strategies(gen: &Gen) -> HashSet<String> {
    let fields = extract_fields(gen);
    fields
        .iter()
        .filter_map(|field| {
            field
                .crdt_annotation
                .as_ref()
                .map(|ann| ann.strategy.as_str().to_string())
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use metadol::ast::{CrdtAnnotation, CrdtStrategy, Span, TypeExpr, Visibility};

    fn create_simple_gen(name: &str, field_name: &str, field_type: &str) -> Gen {
        Gen {
            visibility: Visibility::Public,
            name: name.to_string(),
            extends: None,
            statements: vec![Statement::HasField(Box::new(HasField {
                name: field_name.to_string(),
                type_: TypeExpr::Named(field_type.to_string()),
                default: None,
                constraint: None,
                crdt_annotation: None,
                span: Span::default(),
            }))],
            exegesis: "Test gen".to_string(),
            span: Span::default(),
        }
    }

    fn create_crdt_gen() -> Gen {
        Gen {
            visibility: Visibility::Public,
            name: "ChatMessage".to_string(),
            extends: None,
            statements: vec![
                Statement::HasField(Box::new(HasField {
                    name: "id".to_string(),
                    type_: TypeExpr::Named("String".to_string()),
                    default: None,
                    constraint: None,
                    crdt_annotation: Some(CrdtAnnotation {
                        strategy: CrdtStrategy::Immutable,
                        options: vec![],
                        span: Span::default(),
                    }),
                    span: Span::default(),
                })),
                Statement::HasField(Box::new(HasField {
                    name: "content".to_string(),
                    type_: TypeExpr::Named("String".to_string()),
                    default: None,
                    constraint: None,
                    crdt_annotation: Some(CrdtAnnotation {
                        strategy: CrdtStrategy::Peritext,
                        options: vec![],
                        span: Span::default(),
                    }),
                    span: Span::default(),
                })),
                Statement::HasField(Box::new(HasField {
                    name: "reactions".to_string(),
                    type_: TypeExpr::Generic {
                        name: "Set".to_string(),
                        args: vec![TypeExpr::Named("String".to_string())],
                    },
                    default: None,
                    constraint: None,
                    crdt_annotation: Some(CrdtAnnotation {
                        strategy: CrdtStrategy::OrSet,
                        options: vec![],
                        span: Span::default(),
                    }),
                    span: Span::default(),
                })),
            ],
            exegesis: "A collaborative chat message".to_string(),
            span: Span::default(),
        }
    }

    #[test]
    fn test_generate_simple_gen() {
        let gen = create_simple_gen("User", "name", "String");
        let options = WitOptions::default();

        let result = generate_gen_interface(&gen, &options);
        assert!(result.is_ok());

        let wit = result.unwrap();
        assert!(wit.contains("interface user"));
        assert!(wit.contains("record user"));
        assert!(wit.contains("name: string"));
    }

    #[test]
    fn test_generate_crdt_gen() {
        let gen = create_crdt_gen();
        let options = WitOptions::default();

        let result = generate_gen_interface(&gen, &options);
        assert!(result.is_ok());

        let wit = result.unwrap();
        assert!(wit.contains("interface chat-message"));
        assert!(wit.contains("record chat-message"));
        assert!(wit.contains("/// @crdt(immutable)"));
        assert!(wit.contains("id: string"));
        assert!(wit.contains("/// @crdt(peritext)"));
        assert!(wit.contains("content: string"));
        assert!(wit.contains("/// @crdt(or_set)"));
        assert!(wit.contains("reactions: list<string>"));
    }

    #[test]
    fn test_generate_merge_function() {
        let gen = create_crdt_gen();
        let mut options = WitOptions::default();
        options.generate_merge_functions = true;

        let result = generate_gen_interface(&gen, &options);
        assert!(result.is_ok());

        let wit = result.unwrap();
        assert!(wit.contains("merge: func"));
        assert!(wit.contains("chat-message, b: chat-message) -> chat-message"));
    }

    #[test]
    fn test_generate_serialization_functions() {
        let gen = create_crdt_gen();
        let mut options = WitOptions::default();
        options.generate_serialization = true;

        let result = generate_gen_interface(&gen, &options);
        assert!(result.is_ok());

        let wit = result.unwrap();
        assert!(wit.contains("to-bytes: func"));
        assert!(wit.contains("from-bytes: func"));
        assert!(wit.contains("list<u8>"));
        assert!(wit.contains("result<chat-message, string>"));
    }

    #[test]
    fn test_validate_gen_for_wit() {
        let gen = create_simple_gen("User", "name", "String");
        assert!(validate_gen_for_wit(&gen).is_ok());
    }

    #[test]
    fn test_get_crdt_strategies() {
        let gen = create_crdt_gen();
        let strategies = get_crdt_strategies(&gen);

        assert_eq!(strategies.len(), 3);
        assert!(strategies.contains("immutable"));
        assert!(strategies.contains("peritext"));
        assert!(strategies.contains("or_set"));
    }

    #[test]
    fn test_generate_world() {
        let gen = create_simple_gen("User", "name", "String");
        let file = DolFile {
            module: None,
            uses: vec![],
            declarations: vec![Declaration::Gene(gen)],
        };

        let options = WitOptions::default();
        let result = generate_world(&file, "UserWorld", &options);

        assert!(result.is_ok());
        let world = result.unwrap();
        assert!(world.contains("world user-world"));
        assert!(world.contains("export user"));
    }
}
