# DOL v0.8.0 - Type System Design Document

**Status**: Draft
**Version**: 0.8.0
**Author**: Syntax Architecture Team
**Date**: 2026-01-16

## Executive Summary

DOL v0.8.0 transitions from PascalCase type names to Rust-aligned lowercase conventions. This change improves familiarity for Rust developers, aligns with WASM primitives, and creates a consistent type system that maps directly to WebAssembly value types.

---

## 1. Type Transformation Table

| Current (v0.7.x) | New (v0.8.0) | WASM Type | Size | Range |
|------------------|--------------|-----------|------|-------|
| `Int8` | `i8` | `i32` (extended) | 1 byte | -128 to 127 |
| `Int16` | `i16` | `i32` (extended) | 2 bytes | -32,768 to 32,767 |
| `Int32` | `i32` | `i32` | 4 bytes | -2³¹ to 2³¹-1 |
| `Int64` | `i64` | `i64` | 8 bytes | -2⁶³ to 2⁶³-1 |
| `UInt8` | `u8` | `i32` (extended) | 1 byte | 0 to 255 |
| `UInt16` | `u16` | `i32` (extended) | 2 bytes | 0 to 65,535 |
| `UInt32` | `u32` | `i32` (bitcast) | 4 bytes | 0 to 2³²-1 |
| `UInt64` | `u64` | `i64` (bitcast) | 8 bytes | 0 to 2⁶⁴-1 |
| `Float32` | `f32` | `f32` | 4 bytes | IEEE 754 single |
| `Float64` | `f64` | `f64` | 8 bytes | IEEE 754 double |
| `Bool` | `bool` | `i32` (0/1) | 4 bytes | false/true |
| `String` | `string` | `(ref string)` | variable | UTF-8 |
| `Void` | `()` | - | 0 bytes | unit type |

---

## 2. Detailed Type Specifications

### 2.1 Signed Integer Types

#### 2.1.1 `Int8` → `i8`

**Current Syntax (v0.7.x):**
```dol
fun add_bytes(a: Int8, b: Int8) -> Int8 {
  a + b
}
```

**New Syntax (v0.8.0):**
```dol
fun add_bytes(a: i8, b: i8) -> i8 {
  a + b
}
```

**WASM Mapping:**
- WASM type: `i32`
- Storage: Sign-extended to 32-bit
- Operations: Use `i32.add`, then truncate/sign-extend
- Range checking: Required at boundaries

**Rationale:**
- Direct Rust alignment (`i8` in Rust)
- Familiar to systems programmers
- Clear size indication in type name
- Reduces cognitive overhead

---

#### 2.1.2 `Int16` → `i16`

**WASM Mapping:**
- WASM type: `i32`
- Storage: Sign-extended to 32-bit
- Operations: Use `i32.add`, then mask to 16-bit
- Memory operations: `i32.load16_s`, `i32.store16`

---

#### 2.1.3 `Int32` → `i32`

**WASM Mapping:**
- WASM type: `i32` (native)
- Direct 1:1 mapping
- Operations: `i32.add`, `i32.mul`, etc.
- Most efficient integer type in WASM

---

#### 2.1.4 `Int64` → `i64`

**WASM Mapping:**
- WASM type: `i64` (native)
- Direct 1:1 mapping
- Operations: `i64.add`, `i64.mul`, etc.
- Required for 64-bit timestamps, IDs

---

### 2.2 Unsigned Integer Types

#### 2.2.1 `UInt8` → `u8`

**Current Syntax (v0.7.x):**
```dol
fun parse_byte(data: UInt8) -> UInt8 {
  data & 0xFF
}
```

**New Syntax (v0.8.0):**
```dol
fun parse_byte(data: u8) -> u8 {
  data & 0xFF
}
```

**WASM Mapping:**
- WASM type: `i32`
- Storage: Zero-extended to 32-bit
- Operations: Use `i32.and 0xFF` for masking
- Comparison: Use unsigned `i32.lt_u`

---

#### 2.2.2 `UInt16` → `u16`

**WASM Mapping:**
- WASM type: `i32`
- Storage: Zero-extended to 32-bit
- Memory operations: `i32.load16_u`, `i32.store16`
- Masking: `i32.and 0xFFFF`

---

#### 2.2.3 `UInt32` → `u32`

**WASM Mapping:**
- WASM type: `i32` (bitcast)
- Treated as unsigned in operations
- Comparison: Use `i32.lt_u`, `i32.gt_u`
- Division: Use `i32.div_u`

---

#### 2.2.4 `UInt64` → `u64`

**WASM Mapping:**
- WASM type: `i64` (bitcast)
- Treated as unsigned in operations
- Comparison: Use `i64.lt_u`, `i64.gt_u`
- Division: Use `i64.div_u`

---

### 2.3 Floating-Point Types

#### 2.3.1 `Float32` → `f32`

**Current Syntax (v0.7.x):**
```dol
const PI: Float32 = 3.14159

fun circle_area(radius: Float32) -> Float32 {
  PI * radius * radius
}
```

**New Syntax (v0.8.0):**
```dol
const PI: f32 = 3.14159

fun circle_area(radius: f32) -> f32 {
  PI * radius * radius
}
```

**WASM Mapping:**
- WASM type: `f32` (native)
- IEEE 754 single-precision
- Operations: `f32.add`, `f32.mul`, `f32.sqrt`
- Precision: ~7 decimal digits

---

#### 2.3.2 `Float64` → `f64`

**WASM Mapping:**
- WASM type: `f64` (native)
- IEEE 754 double-precision
- Operations: `f64.add`, `f64.mul`, `f64.sqrt`
- Precision: ~16 decimal digits
- Default for floating literals (if not suffixed)

---

### 2.4 Boolean Type

#### 2.4.1 `Bool` → `bool`

**Current Syntax (v0.7.x):**
```dol
fun is_valid(x: Int32) -> Bool {
  x > 0
}
```

**New Syntax (v0.8.0):**
```dol
fun is_valid(x: i32) -> bool {
  x > 0
}
```

**WASM Mapping:**
- WASM type: `i32`
- Values: `0` (false), `1` (true)
- Operations: Use `i32.eqz` for negation
- Comparison results produce `i32` 0/1

**Semantics:**
- Canonical representation: `0` = false, non-zero = true (in conditionals)
- Strict representation: Only `0` and `1` for stored booleans
- Type safety: Prevent implicit int-to-bool conversions

---

### 2.5 String Type

#### 2.5.1 `String` → `string`

**Current Syntax (v0.7.x):**
```dol
fun greet(name: String) -> String {
  "Hello, " + name
}
```

**New Syntax (v0.8.0):**
```dol
fun greet(name: string) -> string {
  "Hello, " + name
}
```

**WASM Mapping:**
- WASM type: `(ref string)` (WASM GC proposal)
- Encoding: UTF-8
- Immutability: Strings are immutable by default
- Operations: Via imported string functions or WASM GC

**Alternative WASM Representation (without GC):**
- Structure: `{ ptr: i32, len: i32 }`
- Memory layout: Contiguous UTF-8 bytes
- Managed by linear memory allocator

---

### 2.6 Unit Type

#### 2.6.1 `Void` → `()`

**Current Syntax (v0.7.x):**
```dol
fun log_message(msg: String) -> Void {
  sex {
    print(msg)
  }
}
```

**New Syntax (v0.8.0):**
```dol
fun log_message(msg: string) -> () {
  sex {
    print(msg)
  }
}
```

**WASM Mapping:**
- WASM type: None (no return value)
- Compilation: Omit return type in WASM function signature
- Equivalent to `void` in C/C++

**Rationale:**
- Rust alignment (unit type `()`)
- More precise than "Void"
- Enables tuple syntax consistency

---

## 3. Generic Type Constructors

### 3.1 Collection Types

#### 3.1.1 `List<T>` → `Vec<T>`

**Current Syntax (v0.7.x):**
```dol
fun sum(numbers: List<Int32>) -> Int32 {
  // implementation
}
```

**New Syntax (v0.8.0):**
```dol
fun sum(numbers: Vec<i32>) -> i32 {
  // implementation
}
```

**WASM Mapping:**
- Structure: `{ ptr: i32, len: i32, cap: i32 }`
- Memory: Contiguous elements in linear memory
- Growth: Doubling strategy (capacity)
- Operations: Via linear memory load/store

**Rationale:**
- Rust alignment (`Vec<T>`)
- Clear growable array semantics
- Distinguishes from immutable lists

---

#### 3.1.2 `Optional<T>` → `Option<T>`

**Current Syntax (v0.7.x):**
```dol
fun find_user(id: Int32) -> Optional<User> {
  // implementation
}
```

**New Syntax (v0.8.0):**
```dol
fun find_user(id: i32) -> Option<User> {
  // implementation
}
```

**WASM Mapping (Enum representation):**
```wasm
;; Option<T> as tagged union
(type $option_i32 (struct
  (field $tag i32)        ;; 0 = None, 1 = Some
  (field $value i32)      ;; Valid only if tag == 1
))
```

**Rationale:**
- Rust alignment (`Option<T>`)
- Industry standard for nullable types
- Clear Some/None semantics

---

### 3.2 Result Types

#### 3.2.1 `Result<T, E>`

**New Syntax (v0.8.0):**
```dol
fun parse_int(s: string) -> Result<i32, string> {
  // Returns Ok(value) or Err(message)
}
```

**WASM Mapping (Enum representation):**
```wasm
;; Result<i32, string> as tagged union
(type $result_i32_string (struct
  (field $tag i32)        ;; 0 = Ok, 1 = Err
  (field $ok_value i32)   ;; Valid if tag == 0
  (field $err_ptr i32)    ;; Valid if tag == 1
  (field $err_len i32)    ;; Valid if tag == 1
))
```

**Rationale:**
- Rust alignment (`Result<T, E>`)
- Explicit error handling
- No exceptions in WASM

---

## 4. AST Changes

### 4.1 TokenKind Enum Updates

**src/lexer.rs** (lines 213-238):

```rust
// BEFORE (v0.7.x)
pub enum TokenKind {
    // === Type Keywords ===
    Int8,
    Int16,
    Int32,
    Int64,
    UInt8,
    UInt16,
    UInt32,
    UInt64,
    Float32,
    Float64,
    BoolType,      // "Bool"
    StringType,    // "String"
    VoidType,      // "Void"
    // ...
}

// AFTER (v0.8.0)
pub enum TokenKind {
    // === Type Keywords ===
    I8,            // "i8"
    I16,           // "i16"
    I32,           // "i32"
    I64,           // "i64"
    U8,            // "u8"
    U16,           // "u16"
    U32,           // "u32"
    U64,           // "u64"
    F32,           // "f32"
    F64,           // "f64"
    Bool,          // "bool" (lowercase)
    String,        // "string" (lowercase)
    Unit,          // "()" represented as token
    // ...
}
```

### 4.2 Keyword Recognition

**src/lexer.rs** `keyword_kind()` method:

```rust
fn keyword_kind(&self, lexeme: &str) -> Option<TokenKind> {
    match lexeme {
        // v0.8.0 type keywords
        "i8" => Some(TokenKind::I8),
        "i16" => Some(TokenKind::I16),
        "i32" => Some(TokenKind::I32),
        "i64" => Some(TokenKind::I64),
        "u8" => Some(TokenKind::U8),
        "u16" => Some(TokenKind::U16),
        "u32" => Some(TokenKind::U32),
        "u64" => Some(TokenKind::U64),
        "f32" => Some(TokenKind::F32),
        "f64" => Some(TokenKind::F64),
        "bool" => Some(TokenKind::Bool),
        "string" => Some(TokenKind::String),
        // "()" handled as LeftParen + RightParen in parser
        _ => None,
    }
}
```

### 4.3 Display Implementation

**src/lexer.rs**:

```rust
impl std::fmt::Display for TokenKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TokenKind::I8 => write!(f, "i8"),
            TokenKind::I16 => write!(f, "i16"),
            TokenKind::I32 => write!(f, "i32"),
            TokenKind::I64 => write!(f, "i64"),
            TokenKind::U8 => write!(f, "u8"),
            TokenKind::U16 => write!(f, "u16"),
            TokenKind::U32 => write!(f, "u32"),
            TokenKind::U64 => write!(f, "u64"),
            TokenKind::F32 => write!(f, "f32"),
            TokenKind::F64 => write!(f, "f64"),
            TokenKind::Bool => write!(f, "bool"),
            TokenKind::String => write!(f, "string"),
            // ...
        }
    }
}
```

---

## 5. Type Inference

### 5.1 Literal Type Inference

```dol
// Integer literals
let x = 42              // Inferred as i32 (default)
let y: i64 = 42        // Explicit i64
let z = 42i8           // Suffix specifies i8

// Floating literals
let a = 3.14           // Inferred as f64 (default)
let b: f32 = 3.14     // Explicit f32
let c = 3.14f32       // Suffix specifies f32

// Boolean literals
let flag = true        // Inferred as bool

// String literals
let msg = "hello"      // Inferred as string

// Unit
let unit = ()          // Inferred as ()
```

### 5.2 Default Type Rules

| Literal | Default Type | Rationale |
|---------|--------------|-----------|
| Integer | `i32` | WASM native, Rust default |
| Float | `f64` | Higher precision, Rust default |
| Bool | `bool` | Only one boolean type |
| String | `string` | Only one string type |
| Unit | `()` | Only one unit type |

---

## 6. WASM Code Generation

### 6.1 Type Mapping Strategy

```rust
// DOL type → WASM type mapping
fn dol_to_wasm_type(dol_type: &TypeExpr) -> WasmType {
    match dol_type {
        TypeExpr::Named(name) => match name.as_str() {
            "i8" | "i16" | "i32" | "u8" | "u16" | "u32" | "bool" => WasmType::I32,
            "i64" | "u64" => WasmType::I64,
            "f32" => WasmType::F32,
            "f64" => WasmType::F64,
            "string" => WasmType::RefString,  // WASM GC
            "()" => WasmType::None,
            _ => WasmType::RefAny,  // User-defined types
        },
        TypeExpr::Generic { name, .. } => match name.as_str() {
            "Vec" | "Option" | "Result" => WasmType::RefStruct,
            _ => WasmType::RefAny,
        },
        TypeExpr::Function { .. } => WasmType::RefFunc,
        TypeExpr::Tuple(_) => WasmType::RefStruct,
        TypeExpr::Never => WasmType::None,
        TypeExpr::Enum { .. } => WasmType::RefStruct,
    }
}
```

### 6.2 Integer Overflow Behavior

DOL follows Rust's semantics:

| Build Mode | Behavior on Overflow |
|------------|---------------------|
| Debug | Panic (trap in WASM) |
| Release | Wrap (two's complement) |

**Explicit Control:**
```dol
// Checked operations (panic on overflow)
let result = a.checked_add(b)?

// Wrapping operations (always wrap)
let result = a.wrapping_add(b)

// Saturating operations (clamp to min/max)
let result = a.saturating_add(b)
```

---

## 7. Migration Strategy

### 7.1 Automated Type Migration

The `dol-migrate-0.8` tool handles type transformations:

```bash
# Migrate file
dol-migrate-0.8 --types file.dol
```

**Transformation Rules:**
```
Int8    → i8
Int16   → i16
Int32   → i32
Int64   → i64
UInt8   → u8
UInt16  → u16
UInt32  → u32
UInt64  → u64
Float32 → f32
Float64 → f64
Bool    → bool
String  → string
Void    → ()
List<T> → Vec<T>
Optional<T> → Option<T>
```

### 7.2 Regex Replacement Pattern

```regex
# Integer types
s/\bInt8\b/i8/g
s/\bInt16\b/i16/g
s/\bInt32\b/i32/g
s/\bInt64\b/i64/g
s/\bUInt8\b/u8/g
s/\bUInt16\b/u16/g
s/\bUInt32\b/u32/g
s/\bUInt64\b/u64/g

# Float types
s/\bFloat32\b/f32/g
s/\bFloat64\b/f64/g

# Other types
s/\bBool\b/bool/g
s/\bString\b/string/g
s/\bVoid\b/()/g

# Generic types
s/\bList</Vec</g
s/\bOptional</Option</g
```

### 7.3 Manual Review Required

Cases requiring human judgment:

1. **Void vs Unit in contexts:**
   ```dol
   // Clear case
   fun foo() -> Void { }  // → fun foo() -> () { }

   // Requires review (return type omission possible)
   fun bar() -> () { }    // Could be: fun bar() { }
   ```

2. **List vs Vec semantics:**
   ```dol
   // If immutability expected, might need different type
   fun process(data: List<Int32>)  // Review if truly mutable
   ```

---

## 8. Testing Requirements

### 8.1 Type System Tests

```rust
#[test]
fn test_integer_types_v08() {
    let input = "fun add(a: i32, b: i32) -> i32 { a + b }";
    let mut parser = Parser::new(input);
    let decl = parser.parse_declaration().unwrap();

    match decl {
        Declaration::Function(func) => {
            assert_eq!(func.params[0].type_ann,
                      TypeExpr::Named("i32".to_string()));
        }
        _ => panic!("Expected function"),
    }
}

#[test]
fn test_unit_type() {
    let input = "fun log(msg: string) -> () { sex { print(msg) } }";
    let mut parser = Parser::new(input);
    let decl = parser.parse_declaration().unwrap();

    match decl {
        Declaration::Function(func) => {
            assert_eq!(func.return_type,
                      Some(TypeExpr::Named("()".to_string())));
        }
        _ => panic!("Expected function"),
    }
}

#[test]
fn test_generic_types() {
    let input = "fun first(list: Vec<i32>) -> Option<i32> { /* ... */ }";
    let mut parser = Parser::new(input);
    // Verify Generic { name: "Vec", args: [Named("i32")] }
}
```

### 8.2 WASM Code Generation Tests

```rust
#[test]
fn test_wasm_type_mapping() {
    assert_eq!(dol_to_wasm_type(&TypeExpr::Named("i32".to_string())),
               WasmType::I32);
    assert_eq!(dol_to_wasm_type(&TypeExpr::Named("f64".to_string())),
               WasmType::F64);
    assert_eq!(dol_to_wasm_type(&TypeExpr::Named("()".to_string())),
               WasmType::None);
}
```

---

## 9. Documentation Updates

### 9.1 Type Reference Table

Create comprehensive type reference:

```markdown
| DOL Type | Rust Equiv | WASM Type | Size | Literals |
|----------|------------|-----------|------|----------|
| i8 | i8 | i32 | 1 byte | 42i8, -10i8 |
| i16 | i16 | i32 | 2 bytes | 1000i16 |
| i32 | i32 | i32 | 4 bytes | 42, -100 |
| i64 | i64 | i64 | 8 bytes | 42i64, 1000000i64 |
| u8 | u8 | i32 | 1 byte | 255u8 |
| u16 | u16 | i32 | 2 bytes | 65535u16 |
| u32 | u32 | i32 | 4 bytes | 4000000000u32 |
| u64 | u64 | i64 | 8 bytes | 18000000000000000000u64 |
| f32 | f32 | f32 | 4 bytes | 3.14f32 |
| f64 | f64 | f64 | 8 bytes | 3.14, 2.71828 |
| bool | bool | i32 | 4 bytes | true, false |
| string | String | ref string | variable | "hello" |
| () | () | - | 0 bytes | () |
| Vec<T> | Vec<T> | ref struct | variable | vec![1, 2, 3] |
| Option<T> | Option<T> | ref struct | variable | Some(x), None |
```

### 9.2 Grammar Updates

**docs/grammar.ebnf:**

```ebnf
(* Type expressions *)
type_expr = primitive_type
          | generic_type
          | function_type
          | tuple_type
          | unit_type ;

primitive_type = "i8" | "i16" | "i32" | "i64"
               | "u8" | "u16" | "u32" | "u64"
               | "f32" | "f64"
               | "bool" | "string" ;

generic_type = identifier "<" type_expr_list ">" ;

unit_type = "(" ")" ;

type_expr_list = type_expr { "," type_expr } ;
```

---

## 10. Backward Compatibility

### 10.1 Deprecation Warnings

**v0.8.0 compiler behavior:**

```
warning: type 'Int32' is deprecated, use 'i32' instead
  --> examples/math.dol:5:15
   |
 5 | fun add(a: Int32, b: Int32) -> Int32 {
   |            ^^^^^ help: replace with 'i32'
```

### 10.2 Transition Period

- **v0.7.x**: PascalCase types (no warnings)
- **v0.8.0**: PascalCase types supported with deprecation warnings
- **v0.9.0**: PascalCase types removed (breaking change)

---

## 11. Implementation Checklist

- [ ] Update TokenKind enum for all type keywords
- [ ] Update keyword_kind() method
- [ ] Update Display implementation
- [ ] Add unit type `()` parsing logic
- [ ] Update TypeExpr AST nodes
- [ ] Implement WASM type mapping
- [ ] Add literal suffix parsing (42i8, 3.14f32)
- [ ] Update all type-related tests
- [ ] Create type migration tool
- [ ] Update documentation
- [ ] Add WASM codegen tests
- [ ] Update examples/
- [ ] Add type reference documentation
- [ ] Update grammar specification

---

## 12. Success Criteria

- [ ] All primitive types map correctly to WASM
- [ ] Type inference works for literals
- [ ] Generic types (Vec, Option) parse correctly
- [ ] Unit type `()` behaves as expected
- [ ] Migration tool converts all examples successfully
- [ ] No performance regression in type checking
- [ ] Documentation complete with examples

---

**Document Version**: 1.0
**Last Updated**: 2026-01-16
**Next Review**: v0.9.0 planning
