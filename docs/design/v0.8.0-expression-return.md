# DOL v0.8.0 - Expression-Based Return Semantics

**Status**: Draft
**Version**: 0.8.0
**Author**: Syntax Architecture Team
**Date**: 2026-01-16

## Executive Summary

DOL v0.8.0 adopts expression-based return semantics aligned with Rust and functional programming languages. The last expression in a block becomes the return value, semicolons suppress return, and explicit `return` is reserved for early exits. This change makes DOL more concise and functional-first.

---

## 1. Core Concepts

### 1.1 Expression-Oriented Programming

**Key Principle**: In DOL v0.8.0, almost everything is an expression that produces a value.

| Construct | v0.7.x | v0.8.0 |
|-----------|--------|--------|
| If statement | Statement | Expression (returns value) |
| Match | Statement | Expression (returns value) |
| Block `{}` | Statement | Expression (returns value) |
| Function body | Requires `return` | Last expression is return |
| Assignment | Statement | Expression (returns `()`) |

### 1.2 Three Forms of Return

```dol
// 1. Implicit return (last expression, no semicolon)
fun add(a: i32, b: i32) -> i32 {
  a + b  // ← Returns this value
}

// 2. Suppressed return (trailing semicolon)
fun log_and_return_unit(msg: string) -> () {
  sex { print(msg); }  // ← Semicolon suppresses, returns ()
}

// 3. Early return (explicit `return` keyword)
fun find_first_positive(numbers: Vec<i32>) -> Option<i32> {
  for num in numbers {
    if num > 0 {
      return Some(num)  // ← Early exit
    }
  }
  None  // ← Final implicit return
}
```

---

## 2. Detailed Semantics

### 2.1 Block Expressions

**Syntax:**
```dol
block = "{" statement* [expression] "}"
```

**Rules:**
1. **Empty block** `{}` returns `()`
2. **Block ending with semicolon** returns `()`
3. **Block ending with expression** (no semicolon) returns that expression's value

**Examples:**

```dol
// Example 1: Returns ()
fun noop() -> () {
  {}  // Empty block
}

// Example 2: Returns ()
fun side_effects() -> () {
  sex {
    print("hello");
    print("world");  // ← Semicolon suppresses return
  }
}

// Example 3: Returns i32
fun compute() -> i32 {
  let x = 10;
  let y = 20;
  x + y  // ← No semicolon, returns 30
}

// Example 4: Nested blocks
fun nested() -> i32 {
  let result = {
    let a = 5;
    let b = 10;
    a * b  // ← Inner block returns 50
  };  // ← Note: semicolon here, doesn't affect inner block
  result + 10  // ← Outer block returns 60
}
```

### 2.2 If Expressions

**Syntax:**
```dol
if_expr = "if" expression block ["else" (block | if_expr)]
```

**Rules:**
1. Both branches must return the same type
2. If no `else` branch, the type must be `()` or `bool`
3. The value of the matched branch is the if-expression's value

**Examples:**

```dol
// Example 1: If as expression
fun abs(x: i32) -> i32 {
  if x < 0 {
    -x
  } else {
    x
  }  // ← Both branches return i32
}

// Example 2: If without else (must return ())
fun log_if_positive(x: i32) -> () {
  if x > 0 {
    sex { print("positive"); }
  }  // ← Returns (), no else needed
}

// Example 3: If-else chain
fun classify(x: i32) -> string {
  if x < 0 {
    "negative"
  } else if x == 0 {
    "zero"
  } else {
    "positive"
  }
}

// Example 4: If with suppressed return
fun conditional_side_effect(flag: bool) -> () {
  if flag {
    sex { print("flag is true"); }  // Returns ()
  } else {
    sex { print("flag is false"); }  // Returns ()
  };  // ← Semicolon optional here (already returns ())
}
```

**Type Checking:**

```dol
// ERROR: Type mismatch
fun broken(flag: bool) -> i32 {
  if flag {
    42     // Type: i32
  } else {
    "no"   // Type: string ← ERROR
  }
}

// ERROR: Missing else branch for non-unit type
fun incomplete(flag: bool) -> i32 {
  if flag {
    42
  }  // ← ERROR: else branch required when return type is not ()
}
```

### 2.3 Match Expressions

**Syntax:**
```dol
match_expr = "match" expression "{" match_arm+ "}"
match_arm = pattern ["if" expression] "=>" expression [","]
```

**Rules:**
1. All arms must return the same type
2. Arms must be exhaustive (cover all cases)
3. The value of the matched arm is the match-expression's value

**Examples:**

```dol
// Example 1: Match with implicit returns
fun describe_option(opt: Option<i32>) -> string {
  match opt {
    Some(x) => "has value",
    None => "no value"
  }  // ← Returns string from matched arm
}

// Example 2: Match with block expressions
fun process_result(res: Result<i32, string>) -> i32 {
  match res {
    Ok(value) => {
      sex { print("success"); }
      value  // ← Block's last expression
    },
    Err(msg) => {
      sex { print(msg); }
      -1  // ← Default error value
    }
  }
}

// Example 3: Match with guards
fun classify_number(x: i32) -> string {
  match x {
    n if n < 0 => "negative",
    0 => "zero",
    n if n > 0 && n <= 10 => "small positive",
    _ => "large positive"
  }
}

// Example 4: Match with early return
fun find_in_result(res: Result<Vec<i32>, string>, target: i32) -> bool {
  match res {
    Ok(numbers) => {
      for num in numbers {
        if num == target {
          return true  // ← Early exit
        }
      }
      false  // ← Final return
    },
    Err(_) => false
  }
}
```

**Type Checking:**

```dol
// ERROR: Non-exhaustive patterns
fun bad_match(opt: Option<i32>) -> string {
  match opt {
    Some(x) => "has value"
    // ← ERROR: Missing None case
  }
}

// ERROR: Type mismatch in arms
fun broken_match(x: i32) -> string {
  match x {
    0 => "zero",      // Type: string
    _ => 42           // Type: i32 ← ERROR
  }
}
```

### 2.4 Loop Expressions

**Syntax:**
```dol
loop_expr = "loop" block
while_expr = "while" expression block
for_expr = "for" identifier "in" expression block
```

**Rules:**
1. Loops without `break` return `()`
2. `break` can return a value: `break expr`
3. All `break` expressions in a loop must return the same type

**Examples:**

```dol
// Example 1: Loop with break value
fun find_divisor(n: i32) -> i32 {
  let mut i = 2;
  loop {
    if i * i > n {
      break 1  // ← Returns 1 (no divisor found)
    }
    if n % i == 0 {
      break i  // ← Returns divisor
    }
    i = i + 1;
  }  // ← Loop expression returns i32
}

// Example 2: While loop returning ()
fun countdown(mut n: i32) -> () {
  while n > 0 {
    sex { print(n); }
    n = n - 1;
  }  // ← Returns ()
}

// Example 3: For loop with early return
fun contains(numbers: Vec<i32>, target: i32) -> bool {
  for num in numbers {
    if num == target {
      return true  // ← Early exit
    }
  }
  false  // ← Implicit return
}

// Example 4: Nested loops with labeled breaks
fun find_pair(matrix: Vec<Vec<i32>>, target: i32) -> Option<(i32, i32)> {
  'outer: for (i, row) in matrix.enumerate() {
    for (j, val) in row.enumerate() {
      if val == target {
        break 'outer Some((i, j))  // ← Break outer loop with value
      }
    }
  }
  None  // ← If not found
}
```

### 2.5 Semicolon Semantics

**Rule**: A semicolon after an expression converts it to a statement that returns `()`.

**Mental Model:**
```dol
expr;     // ≡ { expr; () }
```

**Examples:**

```dol
// Example 1: With semicolon (returns ())
fun side_effect_only() -> () {
  compute();  // ← Semicolon suppresses return value
}

// Example 2: Without semicolon (returns value)
fun get_result() -> i32 {
  compute()  // ← Returns compute()'s value
}

// Example 3: Multiple statements
fun multi_step() -> i32 {
  let x = 10;    // Semicolon required (let is a statement)
  let y = 20;    // Semicolon required
  x + y          // No semicolon, returns value
}

// Example 4: Semicolon placement matters
fun demonstrate() -> i32 {
  let result = {
    42  // ← Block returns 42
  };    // ← Semicolon after block (statement)
  result  // ← Final return
}
```

**Common Mistake:**

```dol
// ERROR: Returns (), expected i32
fun broken_return() -> i32 {
  42;  // ← Semicolon suppresses return, function returns ()
}

// CORRECT
fun correct_return() -> i32 {
  42   // ← No semicolon, returns 42
}
```

### 2.6 Explicit Return Statement

**Purpose**: Early exit from a function.

**Rules:**
1. `return` immediately exits the function
2. `return expr` returns `expr`'s value
3. `return` without expression returns `()`
4. `return` is NOT required for final return (use implicit return)

**Examples:**

```dol
// Example 1: Guard clauses with early return
fun divide(a: i32, b: i32) -> Result<i32, string> {
  if b == 0 {
    return Err("division by zero")  // ← Early exit
  }
  Ok(a / b)  // ← Implicit return
}

// Example 2: Multiple early exits
fun validate_age(age: i32) -> Result<(), string> {
  if age < 0 {
    return Err("age cannot be negative")
  }
  if age > 150 {
    return Err("age too large")
  }
  Ok(())  // ← Implicit return
}

// Example 3: Return in nested blocks
fun complex_logic(x: i32) -> i32 {
  if x < 0 {
    return -1  // ← Early exit from function
  }

  let result = {
    if x > 100 {
      return 100  // ← Early exit from FUNCTION, not just block
    }
    x * 2
  };

  result + 10
}

// Example 4: Return without value (for () functions)
fun log_if_error(res: Result<i32, string>) -> () {
  match res {
    Ok(_) => return,  // ← Early exit, returns ()
    Err(msg) => sex { print(msg); }
  }
}
```

**Anti-Pattern:**

```dol
// BAD: Unnecessary explicit return
fun add_bad(a: i32, b: i32) -> i32 {
  return a + b;  // ← Don't do this
}

// GOOD: Implicit return
fun add_good(a: i32, b: i32) -> i32 {
  a + b  // ← Idiomatic
}
```

---

## 3. WASM Code Generation

### 3.1 Return Value Compilation

```dol
// DOL code
fun compute() -> i32 {
  let x = 10;
  let y = 20;
  x + y
}
```

**WASM output:**

```wasm
(func $compute (result i32)
  (local $x i32)
  (local $y i32)

  ;; let x = 10
  (local.set $x (i32.const 10))

  ;; let y = 20
  (local.set $y (i32.const 20))

  ;; x + y (implicit return)
  (i32.add (local.get $x) (local.get $y))
)
```

### 3.2 Early Return Compilation

```dol
// DOL code
fun find_positive(numbers: Vec<i32>) -> Option<i32> {
  for num in numbers {
    if num > 0 {
      return Some(num)
    }
  }
  None
}
```

**WASM output (pseudo-code):**

```wasm
(func $find_positive (param $numbers (ref $Vec_i32)) (result (ref $Option_i32))
  (local $num i32)
  (local $iter (ref $VecIter))

  ;; for num in numbers
  (local.set $iter (call $Vec_i32_iter (local.get $numbers)))
  (block $loop_end
    (loop $loop_start
      ;; Get next element
      (br_if $loop_end
        (i32.eqz (call $VecIter_next (local.get $iter) (local.get $num))))

      ;; if num > 0
      (if (i32.gt_s (local.get $num) (i32.const 0))
        (then
          ;; return Some(num)
          (return (call $Option_i32_Some (local.get $num)))
        )
      )

      (br $loop_start)
    )
  )

  ;; None (implicit return)
  (call $Option_i32_None)
)
```

### 3.3 If Expression Compilation

```dol
// DOL code
fun abs(x: i32) -> i32 {
  if x < 0 {
    -x
  } else {
    x
  }
}
```

**WASM output:**

```wasm
(func $abs (param $x i32) (result i32)
  (if (result i32)
    (i32.lt_s (local.get $x) (i32.const 0))
    (then
      (i32.sub (i32.const 0) (local.get $x))  ;; -x
    )
    (else
      (local.get $x)  ;; x
    )
  )
)
```

---

## 4. Type Checking Rules

### 4.1 Block Type Inference

```rust
// Pseudo-code for type checking blocks
fn check_block(block: &Block, expected_type: &Type) -> Result<Type, TypeError> {
    let mut current_type = Type::Unit;

    for stmt in &block.statements {
        check_statement(stmt)?;
    }

    if let Some(final_expr) = &block.final_expr {
        current_type = infer_expr(final_expr)?;

        // Check against expected type
        if !current_type.compatible_with(expected_type) {
            return Err(TypeError::TypeMismatch {
                expected: expected_type.clone(),
                found: current_type,
            });
        }
    }

    Ok(current_type)
}
```

### 4.2 If Expression Type Checking

```rust
fn check_if_expr(if_expr: &IfExpr) -> Result<Type, TypeError> {
    // Condition must be bool
    let cond_type = infer_expr(&if_expr.condition)?;
    if cond_type != Type::Bool {
        return Err(TypeError::ExpectedBool { found: cond_type });
    }

    // Check then branch
    let then_type = check_block(&if_expr.then_branch, &Type::Unknown)?;

    // Check else branch (if present)
    if let Some(else_branch) = &if_expr.else_branch {
        let else_type = check_expr(else_branch)?;

        // Both branches must have same type
        if then_type != else_type {
            return Err(TypeError::IfBranchMismatch {
                then_type,
                else_type,
            });
        }

        Ok(then_type)
    } else {
        // No else branch: must be unit type
        if then_type != Type::Unit {
            return Err(TypeError::MissingElseBranch {
                then_type,
            });
        }

        Ok(Type::Unit)
    }
}
```

### 4.3 Match Exhaustiveness Checking

```rust
fn check_match_exhaustive(match_expr: &MatchExpr) -> Result<(), TypeError> {
    let scrutinee_type = infer_expr(&match_expr.scrutinee)?;

    // Collect all patterns
    let patterns: Vec<&Pattern> = match_expr.arms
        .iter()
        .map(|arm| &arm.pattern)
        .collect();

    // Check exhaustiveness based on type
    match scrutinee_type {
        Type::Bool => {
            // Must have both true and false, or wildcard
            check_bool_exhaustive(&patterns)
        }
        Type::Enum(variants) => {
            // Must cover all variants or have wildcard
            check_enum_exhaustive(&patterns, &variants)
        }
        Type::Option(_) => {
            // Must have Some and None, or wildcard
            check_option_exhaustive(&patterns)
        }
        _ => {
            // Must have wildcard for other types
            check_wildcard_present(&patterns)
        }
    }
}
```

---

## 5. Migration from v0.7.x

### 5.1 Common Patterns

**Pattern 1: Explicit return → Implicit return**

```dol
// v0.7.x
fun add(a: i32, b: i32) -> i32 {
  return a + b;
}

// v0.8.0
fun add(a: i32, b: i32) -> i32 {
  a + b
}
```

**Pattern 2: If statement → If expression**

```dol
// v0.7.x
fun abs(x: i32) -> i32 {
  let result: i32;
  if x < 0 {
    result = -x;
  } else {
    result = x;
  }
  return result;
}

// v0.8.0
fun abs(x: i32) -> i32 {
  if x < 0 {
    -x
  } else {
    x
  }
}
```

**Pattern 3: Match with explicit returns**

```dol
// v0.7.x
fun process_option(opt: Option<i32>) -> i32 {
  match opt {
    Some(x) => { return x; }
    None => { return 0; }
  }
}

// v0.8.0
fun process_option(opt: Option<i32>) -> i32 {
  match opt {
    Some(x) => x,
    None => 0
  }
}
```

### 5.2 Automated Migration

The `dol-migrate-0.8` tool can automatically remove unnecessary returns:

```bash
dol-migrate-0.8 --remove-redundant-returns file.dol
```

**Transformation Rules:**

1. **Remove final return in blocks:**
   ```dol
   { return expr; }  →  { expr }
   ```

2. **Simplify if-else chains:**
   ```dol
   if cond { return a; } else { return b; }
   →
   if cond { a } else { b }
   ```

3. **Remove semicolon before closing brace:**
   ```dol
   { expr; }  (when return type != ())  →  { expr }
   ```

### 5.3 Warning System

v0.8.0 compiler emits warnings for non-idiomatic code:

```
warning: unnecessary `return` keyword
  --> file.dol:10:5
   |
10 |     return x + y;
   |     ^^^^^^^^^^^^^ help: remove `return` and semicolon
   |
   = note: the final expression is implicitly returned
```

```
warning: unnecessary semicolon suppresses return value
  --> file.dol:15:14
   |
15 |     x + y;
   |          ^ help: remove this semicolon
   |
   = note: function returns `i32`, but semicolon makes it return `()`
```

---

## 6. Testing Requirements

### 6.1 Expression Return Tests

```rust
#[test]
fn test_implicit_return() {
    let input = r#"
    fun add(a: i32, b: i32) -> i32 {
      a + b
    }
    "#;

    let func = parse_function(input).unwrap();
    assert!(matches!(func.body.last(),
                     Some(Stmt::Expr(Expr::Binary { .. }))));
}

#[test]
fn test_semicolon_suppresses_return() {
    let input = r#"
    fun noop() -> () {
      42;
    }
    "#;

    let func = parse_function(input).unwrap();
    // Type checker should verify this returns ()
    assert_eq!(infer_function_type(&func).unwrap(), Type::Unit);
}

#[test]
fn test_if_expression_return() {
    let input = r#"
    fun abs(x: i32) -> i32 {
      if x < 0 {
        -x
      } else {
        x
      }
    }
    "#;

    let func = parse_function(input).unwrap();
    let return_type = infer_function_type(&func).unwrap();
    assert_eq!(return_type, Type::Named("i32".to_string()));
}
```

### 6.2 Type Error Tests

```rust
#[test]
fn test_missing_else_branch_error() {
    let input = r#"
    fun broken(flag: bool) -> i32 {
      if flag {
        42
      }
    }
    "#;

    let result = parse_and_typecheck(input);
    assert!(matches!(result, Err(TypeError::MissingElseBranch { .. })));
}

#[test]
fn test_branch_type_mismatch() {
    let input = r#"
    fun broken(flag: bool) -> i32 {
      if flag {
        42
      } else {
        "error"
      }
    }
    "#;

    let result = parse_and_typecheck(input);
    assert!(matches!(result, Err(TypeError::IfBranchMismatch { .. })));
}
```

### 6.3 WASM Codegen Tests

```rust
#[test]
fn test_wasm_implicit_return() {
    let dol_code = r#"
    fun add(a: i32, b: i32) -> i32 {
      a + b
    }
    "#;

    let wasm = compile_to_wasm(dol_code).unwrap();

    // Verify WASM has no explicit return instruction,
    // just leaves value on stack
    assert!(wasm.ends_with_expression());
    assert!(!wasm.contains_return_instruction());
}
```

---

## 7. Documentation Updates

### 7.1 Style Guide

Create DOL style guide section on returns:

```markdown
# Return Statements

## Prefer Implicit Returns

**Good:**
```dol
fun add(a: i32, b: i32) -> i32 {
  a + b
}
```

**Bad:**
```dol
fun add(a: i32, b: i32) -> i32 {
  return a + b;
}
```

## Use `return` Only for Early Exits

**Good:**
```dol
fun validate(x: i32) -> Result<(), string> {
  if x < 0 {
    return Err("negative value")
  }
  Ok(())
}
```

**Bad:**
```dol
fun validate(x: i32) -> Result<(), string> {
  if x >= 0 {
    return Ok(())
  } else {
    return Err("negative value")
  }
}
```

## Expression-First Thinking

**Good:**
```dol
let abs_value = if x < 0 { -x } else { x };
```

**Bad:**
```dol
let abs_value: i32;
if x < 0 {
  abs_value = -x;
} else {
  abs_value = x;
}
```
```

### 7.2 Tutorial Updates

Update tutorials to teach expression-based thinking:

```markdown
# Functions in DOL

Functions in DOL are expression-oriented. The last expression in a
function body is automatically returned:

```dol
fun square(x: i32) -> i32 {
  x * x  // ← Automatically returned
}
```

You don't need to write `return` for the final value. Use `return`
only when you need to exit early:

```dol
fun find_first_even(numbers: Vec<i32>) -> Option<i32> {
  for num in numbers {
    if num % 2 == 0 {
      return Some(num)  // ← Early exit
    }
  }
  None  // ← Final implicit return
}
```
```

---

## 8. Error Messages

### 8.1 Helpful Error Messages

```
error: function returns `()` but expected `i32`
  --> file.dol:3:5
   |
 3 |   42;
   |     ^ this semicolon suppresses the return value
   |
help: remove the semicolon to return the value
   |
 3 |   42
   |
```

```
error: if expression missing else branch
  --> file.dol:5:3
   |
 5 |   if x > 0 {
   |   ^^ this if has no else branch
 6 |     42
 7 |   }
   |   - expected type `i32` here
   |
   = note: all branches of an if expression must return the same type
help: add an else branch
   |
 7 |   } else {
 8 |     0
 9 |   }
   |
```

### 8.2 Suggestion System

Compiler provides suggestions:

```
warning: unnecessary `return` keyword
  --> file.dol:10:5
   |
10 |     return x + y;
   |     ^^^^^^^^^^^^^ help: try this: `x + y`
   |
   = note: `#[warn(clippy::needless_return)]` on by default
```

---

## 9. Performance Considerations

### 9.1 WASM Optimization

Expression-based returns enable better WASM optimization:

**Before (explicit return):**
```wasm
(func $add (param $a i32) (param $b i32) (result i32)
  (local $result i32)
  (local.set $result (i32.add (local.get $a) (local.get $b)))
  (local.get $result)
)
```

**After (implicit return):**
```wasm
(func $add (param $a i32) (param $b i32) (result i32)
  (i32.add (local.get $a) (local.get $b))
)
```

**Benefit**: Eliminates unnecessary local variable, reduces stack usage.

### 9.2 Tail Call Optimization

Expression-based returns make tail calls easier to identify:

```dol
// Tail-recursive (can be optimized)
fun factorial_tail(n: i32, acc: i32) -> i32 {
  if n <= 1 {
    acc
  } else {
    factorial_tail(n - 1, n * acc)  // ← Tail position
  }
}

// NOT tail-recursive
fun factorial_bad(n: i32) -> i32 {
  if n <= 1 {
    1
  } else {
    n * factorial_bad(n - 1)  // ← Not in tail position
  }
}
```

---

## 10. Implementation Checklist

- [ ] Update parser to support blocks ending with expressions
- [ ] Implement semicolon suppression logic
- [ ] Add type inference for block expressions
- [ ] Add type checking for if-expressions (branch compatibility)
- [ ] Add type checking for match-expressions (exhaustiveness)
- [ ] Implement early return statement handling
- [ ] Add WASM codegen for implicit returns
- [ ] Add WASM codegen for early returns
- [ ] Create expression-return tests
- [ ] Add type error tests (missing else, type mismatch)
- [ ] Update style guide with return conventions
- [ ] Add migration tool for removing redundant returns
- [ ] Implement warning system for non-idiomatic code
- [ ] Update all documentation and tutorials

---

## 11. Success Criteria

- [ ] All functions can use implicit returns
- [ ] If and match expressions work as expressions
- [ ] Semicolon suppression works correctly
- [ ] Early returns work in all contexts
- [ ] Type checking catches all return type errors
- [ ] WASM codegen produces optimal code
- [ ] Migration tool removes redundant returns
- [ ] No performance regression
- [ ] Documentation complete with examples

---

**Document Version**: 1.0
**Last Updated**: 2026-01-16
**Next Review**: v0.9.0 planning
