// error-handling.dol - Proper Error Handling
// This example demonstrates robust error handling patterns when calling
// host functions, including result code checking and error reporting.

// Host function: Print a string to standard output
// Returns: ResultCode (0 = success, 1 = buffer full, 2 = invalid encoding)
sex fun vudo_println(ptr: i32, len: i32) -> i32

// Host function: Send a message to another spirit
// Returns: ResultCode (0 = success, 1 = recipient not found, 2 = queue full, 3 = invalid message)
sex fun vudo_send(recipient_id: i32, msg_ptr: i32, msg_len: i32) -> i32

// Host function: Report an error to the host system
// Parameters: error_code, error_message
// Returns: ResultCode (0 = logged, 1 = error queue full)
sex fun vudo_error(error_code: i32, error_message: string) -> i32

// Host function: Receive a message
// Returns: message string (empty if no pending messages)
sex fun vudo_recv() -> string

// Host function: Check for pending messages
// Returns: count of pending messages
sex fun vudo_pending() -> i32

// Define standard error codes as constants
gen ErrorCodes {
    // Success
    has SUCCESS: i32 = 0

    // Generic errors
    has ERROR_UNKNOWN: i32 = 1
    has ERROR_INVALID_INPUT: i32 = 2
    has ERROR_NOT_FOUND: i32 = 3

    // I/O errors
    has ERROR_IO_BUFFER_FULL: i32 = 100
    has ERROR_IO_ENCODING: i32 = 101
    has ERROR_IO_FAILED: i32 = 102

    // Messaging errors
    has ERROR_MSG_RECIPIENT_NOT_FOUND: i32 = 200
    has ERROR_MSG_QUEUE_FULL: i32 = 201
    has ERROR_MSG_INVALID: i32 = 202

    // Operation errors
    has ERROR_OP_TIMEOUT: i32 = 300
    has ERROR_OP_CANCELLED: i32 = 301
    has ERROR_OP_STATE: i32 = 302
}

// A spirit that demonstrates safe I/O with error checking
gen SafeIOSpirit {
    has name: string
    has total_errors: i32
    has successful_prints: i32

    fun new(spirit_name: string) {
        this.name = spirit_name
        this.total_errors = 0
        this.successful_prints = 0
    }

    // Safe print that checks return codes
    // Returns: true on success, false on error
    fun safe_print(message: string) -> bool {
        vudo_println("Attempting to print: " + message)

        let result = vudo_println(message)

        if result == 0 {
            vudo_println("Print succeeded")
            this.successful_prints = this.successful_prints + 1
            return true
        } else if result == 1 {
            let error_msg = "Error: Output buffer is full"
            vudo_println(error_msg)
            this.total_errors = this.total_errors + 1

            // Report the error to the host
            vudo_error(100, error_msg)
            return false
        } else if result == 2 {
            let error_msg = "Error: Invalid character encoding in message"
            vudo_println(error_msg)
            this.total_errors = this.total_errors + 1

            vudo_error(101, error_msg)
            return false
        }

        // Handle unexpected error codes
        let unexpected_error = "Unexpected error code: " + result.to_string()
        vudo_println(unexpected_error)
        this.total_errors = this.total_errors + 1
        vudo_error(1, unexpected_error)
        return false
    }

    // Print with fallback strategy
    // If printing fails, try a shorter message
    fun print_with_fallback(message: string) {
        let success = this.safe_print(message)

        if !success && message.length > 20 {
            vudo_println("Trying shorter message...")
            let short_msg = message.substring(0, 20) + "..."
            this.safe_print(short_msg)
        }
    }

    fun get_stats() {
        let stats = "Stats - Successful: " + this.successful_prints.to_string() +
                   ", Errors: " + this.total_errors.to_string()
        vudo_println(stats)
    }
}

// A spirit that demonstrates safe messaging with error checking
gen SafeMessagingSpirit {
    has spirit_id: i32
    has messages_sent: i32
    has messages_failed: i32
    has last_error_code: i32

    fun new(id: i32) {
        this.spirit_id = id
        this.messages_sent = 0
        this.messages_failed = 0
        this.last_error_code = 0
    }

    // Safely send a message with detailed error handling
    fun safe_send(recipient_id: i32, content: string) {
        vudo_println("Attempting to send message...")

        let result = vudo_send(recipient_id, content)

        if result == 0 {
            vudo_println("Message sent successfully")
            this.messages_sent = this.messages_sent + 1
        } else if result == 1 {
            let error_msg = "Error: Recipient " + recipient_id.to_string() + " not found"
            vudo_println(error_msg)
            this.messages_failed = this.messages_failed + 1
            this.last_error_code = 1

            // Report the error with details
            vudo_error(200, error_msg)
        } else if result == 2 {
            let error_msg = "Error: Message queue for recipient is full"
            vudo_println(error_msg)
            this.messages_failed = this.messages_failed + 1
            this.last_error_code = 2

            // Report and suggest retry
            vudo_error(201, error_msg + " - Retry later")
        } else if result == 3 {
            let error_msg = "Error: Message format is invalid"
            vudo_println(error_msg)
            this.messages_failed = this.messages_failed + 1
            this.last_error_code = 3

            // Report the validation error
            vudo_error(202, error_msg)
        } else {
            let error_msg = "Unknown error: " + result.to_string()
            vudo_println(error_msg)
            this.messages_failed = this.messages_failed + 1
            this.last_error_code = result

            vudo_error(1, error_msg)
        }
    }

    // Send with retry logic
    fun send_with_retry(recipient_id: i32, content: string, max_retries: i32) {
        let retry_count = 0

        while retry_count < max_retries {
            let attempt_msg = "Attempt " + (retry_count + 1).to_string()
            vudo_println(attempt_msg)

            let result = vudo_send(recipient_id, content)

            if result == 0 {
                vudo_println("Message sent successfully")
                this.messages_sent = this.messages_sent + 1
                return
            } else if result == 1 {
                // Recipient not found - don't retry
                vudo_println("Error: Recipient not found, aborting")
                this.messages_failed = this.messages_failed + 1
                vudo_error(200, "Recipient not found")
                return
            } else if result == 2 {
                // Queue full - retry is appropriate
                vudo_println("Error: Queue full, retrying...")
                retry_count = retry_count + 1

                if retry_count >= max_retries {
                    this.messages_failed = this.messages_failed + 1
                    vudo_error(201, "Failed after " + max_retries.to_string() + " retries")
                }
            } else {
                // Other errors - don't retry
                vudo_println("Fatal error, aborting")
                this.messages_failed = this.messages_failed + 1
                vudo_error(1, "Fatal error: " + result.to_string())
                return
            }
        }
    }

    fun get_stats() {
        let stats = "Messaging Stats - Sent: " + this.messages_sent.to_string() +
                   ", Failed: " + this.messages_failed.to_string()
        vudo_println(stats)
    }
}

// A spirit that safely receives and handles messages
gen SafeReceiverSpirit {
    has receiver_id: i32
    has messages_received: i32
    has processing_errors: i32

    fun new(id: i32) {
        this.receiver_id = id
        this.messages_received = 0
        this.processing_errors = 0
    }

    // Safely process pending messages
    fun safe_receive_all() {
        let pending = vudo_pending()

        if pending <= 0 {
            vudo_println("No pending messages")
            return
        }

        let msg_count = 0

        while msg_count < pending {
            let msg = vudo_recv()

            if msg.length > 0 {
                let log_msg = "Received message: " + msg
                vudo_println(log_msg)

                // Attempt to process the message safely
                this.process_message_safely(msg)
                this.messages_received = this.messages_received + 1
            }

            msg_count = msg_count + 1
        }
    }

    // Process a single message with error handling
    fun process_message_safely(message: string) {
        if message.length == 0 {
            let error_msg = "Error: Empty message received"
            vudo_println(error_msg)
            vudo_error(2, error_msg)
            this.processing_errors = this.processing_errors + 1
            return
        }

        if message.length > 1000 {
            let error_msg = "Error: Message exceeds size limit"
            vudo_println(error_msg)
            vudo_error(2, error_msg)
            this.processing_errors = this.processing_errors + 1
            return
        }

        // Message is valid, process it
        let process_msg = "Processing valid message of length: " + message.length.to_string()
        vudo_println(process_msg)
    }

    fun get_stats() {
        let stats = "Receiver Stats - Received: " + this.messages_received.to_string() +
                   ", Errors: " + this.processing_errors.to_string()
        vudo_println(stats)
    }
}

// Master example demonstrating the complete error handling pattern
gen ErrorHandlingDemo {
    has io_spirit: SafeIOSpirit
    has msg_spirit: SafeMessagingSpirit
    has recv_spirit: SafeReceiverSpirit

    fun new() {
        this.io_spirit = SafeIOSpirit { name: "IOSpirit", total_errors: 0, successful_prints: 0 }
        this.msg_spirit = SafeMessagingSpirit { spirit_id: 1, messages_sent: 0, messages_failed: 0, last_error_code: 0 }
        this.recv_spirit = SafeReceiverSpirit { receiver_id: 2, messages_received: 0, processing_errors: 0 }
    }

    fun run() {
        vudo_println("=== Error Handling Example ===")

        // Demonstrate I/O error handling
        vudo_println("Testing I/O operations...")
        this.io_spirit.safe_print("Hello World")
        this.io_spirit.print_with_fallback("This is a very long message that might not fit in the buffer")

        // Demonstrate messaging error handling
        vudo_println("Testing messaging operations...")
        this.msg_spirit.safe_send(42, "Hello recipient")
        this.msg_spirit.send_with_retry(43, "Retry message", 3)

        // Demonstrate receiver error handling
        vudo_println("Testing receiver operations...")
        this.recv_spirit.safe_receive_all()

        // Print final statistics
        vudo_println("=== Final Statistics ===")
        this.io_spirit.get_stats()
        this.msg_spirit.get_stats()
        this.recv_spirit.get_stats()
    }
}

docs {
    This example demonstrates best practices for error handling when using
    the DOL ABI:

    1. Result Code Checking:
       - Every ABI function returns a ResultCode (typically 0 for success)
       - Always check the return value before proceeding
       - Different error codes indicate different failure modes

    2. Error Reporting:
       - vudo_error(error_code, message): Report errors to the host
       - Enables centralized error logging and monitoring
       - Helps with debugging and observability

    3. Error Recovery Strategies:
       - Fallback: Try an alternative approach (e.g., shorter message)
       - Retry: Attempt the operation again (useful for transient failures)
       - Abort: Stop processing and report the error
       - Queue: Defer the operation for later retry

    4. Input Validation:
       - Check message lengths and encoding before sending
       - Validate received messages before processing
       - Prevents cascading failures from bad data

    5. Differentiating Error Types:
       - Result codes distinguish between different failure modes
       - Different errors require different handling strategies
       - Some errors are transient (retry), others are permanent (abort)

    6. Logging and Statistics:
       - Track successful and failed operations
       - Store the last error code for diagnostics
       - Report statistics to aid monitoring and alerting

    Common ResultCode Values (defined in ErrorCodes):
       - 0: Success
       - 1: Recipient not found (don't retry)
       - 2: Buffer/queue full (retry is appropriate)
       - 3: Invalid message format (don't retry)
       - 100+: I/O related errors
       - 200+: Messaging errors
       - 300+: Operation errors

    Proper error handling is essential for production spirits that must
    handle failures gracefully and provide visibility into system issues.
}
