/**
 * Core type definitions for @vudo/runtime
 */
/** Supported primitive types in WASM memory */
type GeneFieldType = 'i32' | 'i64' | 'f32' | 'f64' | 'bool' | 'string';
/** A single field in a Gene layout */
interface GeneField {
    /** Field name matching DOL declaration */
    name: string;
    /** WASM type */
    type: GeneFieldType;
    /** Byte offset from struct start */
    offset: number;
}
/** Memory layout for a Gene (generated by dol-codegen) */
interface GeneLayout {
    /** Gene name from DOL source */
    name: string;
    /** Field definitions with offsets */
    fields: GeneField[];
    /** Total size in bytes */
    size: number;
    /** Alignment requirement */
    alignment: number;
}
/** Type helper for gene values */
type GeneValues<T extends GeneLayout> = {
    [K in T['fields'][number]['name']]: T['fields'][number] extends {
        name: K;
        type: infer Type;
    } ? Type extends 'i64' ? bigint : Type extends 'f64' ? number : Type extends 'f32' ? number : Type extends 'i32' ? number : Type extends 'bool' ? boolean : Type extends 'string' ? string : unknown : unknown;
};
/** Options for loading a Spirit */
interface LoadOptions {
    /** Custom host function implementations */
    imports?: Record<string, WebAssembly.ImportValue>;
    /** Memory configuration */
    memory?: {
        /** Initial memory pages (64KB each) */
        initial?: number;
        /** Maximum memory pages */
        maximum?: number;
    };
    /** Enable debug logging */
    debug?: boolean;
    /** Loa registry for service injection */
    loas?: LoaRegistry$1;
}
/** Spirit instance returned by loader */
interface SpiritInstance {
    /** Call an exported function */
    call<R = unknown>(name: string, args?: unknown[]): R;
    /** Get typed interface */
    as<T extends object>(): T;
    /** Access memory manager */
    readonly memory: MemoryManager;
    /** Raw WASM exports */
    readonly exports: WebAssembly.Exports;
}
/** A Loa (service) that can be injected into Spirits */
interface Loa {
    /** Unique service name */
    name: string;
    /** Semantic version */
    version: string;
    /** List of capabilities provided */
    capabilities: string[];
    /** Factory function returning host function implementations */
    provides: (context: LoaContext) => Record<string, WebAssembly.ImportValue>;
}
/** Context passed to Loa providers */
interface LoaContext {
    /** WASM memory for the Spirit */
    memory: WebAssembly.Memory;
    /** Allocator for memory operations */
    alloc: (size: number) => number;
    /** Debug mode flag */
    debug: boolean;
}
/** Registry for managing Loa services */
interface LoaRegistry$1 {
    /** Register a new Loa */
    register(loa: Loa): void;
    /** Get a Loa by name */
    get(name: string): Loa | undefined;
    /** Check if a Loa is registered */
    has(name: string): boolean;
    /** Get all registered Loas */
    all(): Loa[];
    /** Unregister a Loa */
    unregister(name: string): boolean;
    /** Build imports object from registered Loas */
    buildImports(context: LoaContext): Record<string, WebAssembly.ImportValue>;
}
/** A Séance manages multiple Spirit instances */
interface SeanceInstance {
    /** Summon a Spirit into the session */
    summon(name: string, source: string | ArrayBuffer): Promise<void>;
    /** Invoke a function on a summoned Spirit */
    invoke<R = unknown>(spiritName: string, funcName: string, args?: unknown[]): Promise<R>;
    /** Get a summoned Spirit by name */
    getSpirit(name: string): SpiritInstance | undefined;
    /** Dismiss the session and clean up */
    dismiss(): Promise<void>;
    /** List all summoned Spirit names */
    spirits(): string[];
}
/** Memory manager for a Spirit instance */
interface MemoryManager {
    /** Allocate bytes, returns pointer */
    alloc(size: number, align?: number): number;
    /** Free allocated memory (no-op for bump allocator) */
    free(ptr: number): void;
    /** Reset allocator */
    reset(): void;
    /** Read a Gene from memory */
    readGene<T extends GeneLayout>(ptr: number, layout: T): Record<string, unknown>;
    /** Write a Gene to memory */
    writeGene<T extends GeneLayout>(ptr: number, values: Record<string, unknown>, layout: T): void;
    /** Encode a string, returns pointer */
    encodeString(str: string): number;
    /** Decode a string from pointer */
    decodeString(ptr: number): string;
    /** Get raw memory buffer */
    readonly buffer: ArrayBuffer;
    /** Get current allocation offset */
    readonly offset: number;
}

/**
 * Spirit - WASM module loader and wrapper
 *
 * A Spirit is a compiled DOL program running in WASM.
 */

/**
 * Spirit instance wrapping a loaded WASM module
 */
declare class Spirit implements SpiritInstance {
    private instance;
    private wasmMemory;
    private memoryManager;
    private debug;
    constructor(instance: WebAssembly.Instance, memory: WebAssembly.Memory, debug?: boolean);
    /**
     * Call an exported function by name
     */
    call<R = unknown>(name: string, args?: unknown[]): R;
    /**
     * Get a typed interface to the Spirit
     *
     * Allows type-safe calls using generated TypeScript types:
     * ```typescript
     * import type { Calculator } from './generated/calculator.types';
     * const calc = spirit.as<Calculator>();
     * const sum = calc.add(1n, 2n);
     * ```
     */
    as<T extends object>(): T;
    /**
     * Get the memory manager for this Spirit
     */
    get memory(): MemoryManager;
    /**
     * Get raw WASM exports
     */
    get exports(): WebAssembly.Exports;
    /**
     * Get raw WASM memory
     */
    get rawMemory(): WebAssembly.Memory;
    /**
     * Check if the Spirit exports a function
     */
    hasFunction(name: string): boolean;
    /**
     * List all exported function names
     */
    listFunctions(): string[];
}
/**
 * Loader for Spirit WASM modules
 */
declare class SpiritLoader {
    private registry;
    private debug;
    constructor(options?: {
        loas?: LoaRegistry$1;
        debug?: boolean;
    });
    /**
     * Load a Spirit from WASM bytes
     */
    load(wasmBytes: ArrayBuffer | Uint8Array, options?: LoadOptions): Promise<Spirit>;
    /**
     * Load a Spirit from a URL (browser) or file path (Node.js)
     */
    loadFrom(source: string | URL, options?: LoadOptions): Promise<Spirit>;
    /**
     * Fetch WASM bytes from URL or file
     */
    private fetchBytes;
}
/**
 * Load a Spirit from WASM bytes or URL
 *
 * @example
 * ```typescript
 * // From bytes
 * const spirit = await loadSpirit(wasmBytes);
 *
 * // From URL/path
 * const spirit = await loadSpirit('/spirits/calculator.wasm');
 *
 * // With options
 * const spirit = await loadSpirit(wasmBytes, {
 *   debug: true,
 *   memory: { initial: 32 },
 * });
 * ```
 */
declare function loadSpirit(source: string | URL | ArrayBuffer | Uint8Array, options?: LoadOptions): Promise<Spirit>;

/**
 * Loa - Service injection for Spirit instances
 *
 * A Loa is a named service that provides host functions to WASM modules.
 * Based on vudo-runtime-spec.md host function implementations.
 */

/**
 * Core Loa providing essential host functions
 *
 * These functions are available to all Spirits by default:
 * - vudo_print: Print a string to console
 * - vudo_alloc: Allocate memory (bound to Spirit's allocator)
 * - vudo_now: Get current timestamp
 * - vudo_random: Generate random number
 * - vudo_emit_effect: Emit a side effect
 */
declare const coreLoa: Loa;
/**
 * Registry for managing Loa services
 *
 * Allows registration of custom Loas that provide host functions to Spirits.
 */
declare class LoaRegistry implements LoaRegistry$1 {
    private loas;
    constructor();
    /**
     * Register a new Loa
     * @param loa - Loa to register
     * @throws Error if Loa with same name already exists
     */
    register(loa: Loa): void;
    /**
     * Get a Loa by name
     */
    get(name: string): Loa | undefined;
    /**
     * Get all registered Loas
     */
    all(): Loa[];
    /**
     * Check if a Loa is registered
     */
    has(name: string): boolean;
    /**
     * Unregister a Loa
     */
    unregister(name: string): boolean;
    /**
     * Build WASM imports object from all registered Loas
     */
    buildImports(context: LoaContext): Record<string, WebAssembly.ImportValue>;
}
/**
 * Create a simple Loa from host function definitions
 */
declare function createLoa(name: string, version: string, functions: Record<string, (context: LoaContext) => WebAssembly.ImportValue>): Loa;
/**
 * Create a logging Loa with custom logger
 */
declare function createLoggingLoa(logger: {
    log: (msg: string) => void;
    error: (msg: string) => void;
    debug: (msg: string) => void;
}): Loa;

/**
 * Séance - Session management for multiple Spirit instances
 *
 * A Séance coordinates multiple Spirits, allowing them to interact
 * within a shared session context.
 */

/**
 * Session manager for coordinating multiple Spirit instances
 *
 * @example
 * ```typescript
 * const seance = new Seance();
 *
 * // Summon Spirits
 * await seance.summon('calc', '/spirits/calculator.wasm');
 * await seance.summon('logger', '/spirits/logger.wasm');
 *
 * // Invoke functions
 * const result = await seance.invoke('calc', 'add', [1, 2]);
 * await seance.invoke('logger', 'log', [`Result: ${result}`]);
 *
 * // Cleanup
 * await seance.dismiss();
 * ```
 */
declare class Seance implements SeanceInstance {
    private spiritMap;
    private registry;
    private debug;
    private defaultOptions;
    constructor(options?: {
        loas?: LoaRegistry;
        debug?: boolean;
        defaultLoadOptions?: LoadOptions;
    });
    /**
     * Summon a Spirit into the session
     *
     * @param name - Unique name for the Spirit within this session
     * @param source - WASM bytes or URL to load from
     * @param options - Additional load options
     */
    summon(name: string, source: string | ArrayBuffer | Uint8Array, options?: LoadOptions): Promise<void>;
    /**
     * Invoke a function on a summoned Spirit
     *
     * @param spiritName - Name of the Spirit to invoke
     * @param funcName - Function name to call
     * @param args - Arguments to pass
     * @returns Function result
     */
    invoke<R = unknown>(spiritName: string, funcName: string, args?: unknown[]): Promise<R>;
    /**
     * Get a summoned Spirit by name
     */
    getSpirit(name: string): SpiritInstance | undefined;
    /**
     * Check if a Spirit is summoned
     */
    hasSpirit(name: string): boolean;
    /**
     * List all summoned Spirit names
     */
    spirits(): string[];
    /**
     * Dismiss a specific Spirit from the session
     */
    release(name: string): Promise<void>;
    /**
     * Dismiss the session and clean up all Spirits
     */
    dismiss(): Promise<void>;
    /**
     * Get the Loa registry for this session
     */
    get loas(): LoaRegistry;
    /**
     * Get the number of summoned Spirits
     */
    get size(): number;
}
/**
 * Create a new Séance session
 */
declare function createSeance(options?: {
    loas?: LoaRegistry;
    debug?: boolean;
}): Seance;
/**
 * Run a Spirit session with automatic cleanup
 *
 * @example
 * ```typescript
 * await withSeance(async (seance) => {
 *   await seance.summon('calc', './calculator.wasm');
 *   const result = await seance.invoke('calc', 'add', [1, 2]);
 *   console.log('Result:', result);
 * });
 * // Session is automatically dismissed
 * ```
 */
declare function withSeance<T>(fn: (seance: Seance) => Promise<T>, options?: {
    loas?: LoaRegistry;
    debug?: boolean;
}): Promise<T>;

/**
 * Memory management for Spirit instances
 *
 * Internal implementation based on vudo-runtime-spec.md BumpAllocator
 */

/**
 * Bump allocator for WASM linear memory
 *
 * Simple and fast allocation strategy - memory is allocated sequentially
 * and only freed when the entire allocator is reset.
 *
 * @internal
 */
declare class BumpAllocator {
    private memory;
    private currentOffset;
    private readonly baseOffset;
    /**
     * Create a new bump allocator
     * @param memory - WASM memory instance
     * @param baseOffset - Starting offset (default 1024 to avoid null pointer region)
     */
    constructor(memory: WebAssembly.Memory, baseOffset?: number);
    /**
     * Allocate `size` bytes with alignment
     * @param size - Number of bytes to allocate
     * @param align - Alignment requirement (default 8 for 64-bit)
     * @returns Pointer to allocated memory
     */
    alloc(size: number, align?: number): number;
    /**
     * Free memory at pointer (no-op for bump allocator)
     * Memory is only reclaimed on reset()
     */
    free(_ptr: number): void;
    /**
     * Reset allocator to initial state
     * All previously allocated memory becomes invalid
     */
    reset(): void;
    /**
     * Get current allocation offset
     */
    get offset(): number;
    /**
     * Get raw memory buffer
     */
    get buffer(): ArrayBuffer;
    /**
     * Get WASM memory instance
     */
    get rawMemory(): WebAssembly.Memory;
}
/**
 * Memory manager implementation wrapping BumpAllocator
 * Provides high-level API for gene operations
 */
declare class SpiritMemoryManager implements MemoryManager {
    private allocator;
    private wasmMemory;
    constructor(memory: WebAssembly.Memory, baseOffset?: number);
    alloc(size: number, align?: number): number;
    free(ptr: number): void;
    reset(): void;
    readGene<T extends GeneLayout>(ptr: number, layout: T): Record<string, unknown>;
    writeGene<T extends GeneLayout>(ptr: number, values: Record<string, unknown>, layout: T): void;
    encodeString(str: string): number;
    decodeString(ptr: number): string;
    get buffer(): ArrayBuffer;
    get offset(): number;
    /**
     * Get typed array views of memory
     */
    get views(): {
        i8: Int8Array<ArrayBuffer>;
        u8: Uint8Array<ArrayBuffer>;
        i32: Int32Array<ArrayBuffer>;
        u32: Uint32Array<ArrayBuffer>;
        i64: BigInt64Array<ArrayBuffer>;
        u64: BigUint64Array<ArrayBuffer>;
        f32: Float32Array<ArrayBuffer>;
        f64: Float64Array<ArrayBuffer>;
    };
}

/**
 * Type bridge utilities for DOL ↔ JavaScript conversion
 *
 * Handles encoding/decoding of DOL types in WASM linear memory.
 * Based on vudo-runtime-spec.md string and gene helpers.
 */

/**
 * Encode a JavaScript string into WASM memory
 *
 * Format: 4-byte length prefix (u32, little-endian) + UTF-8 bytes
 *
 * @param memory - WASM memory instance
 * @param allocator - Allocator for memory allocation
 * @param str - String to encode
 * @returns Pointer to encoded string
 */
declare function encodeString(memory: WebAssembly.Memory, allocator: {
    alloc: (size: number, align?: number) => number;
}, str: string): number;
/**
 * Decode a string from WASM memory
 *
 * Expects format: 4-byte length prefix (u32, little-endian) + UTF-8 bytes
 *
 * @param memory - WASM memory instance
 * @param ptr - Pointer to encoded string
 * @returns Decoded JavaScript string
 */
declare function decodeString(memory: WebAssembly.Memory, ptr: number): string;
/**
 * Write a gene struct to WASM memory
 *
 * @param memory - WASM memory instance
 * @param ptr - Pointer to write location
 * @param layout - Gene layout definition
 * @param values - Field values to write
 */
declare function writeGene(memory: WebAssembly.Memory, ptr: number, layout: GeneLayout, values: Record<string, unknown>): void;
/**
 * Read a gene struct from WASM memory
 *
 * @param memory - WASM memory instance
 * @param ptr - Pointer to gene location
 * @param layout - Gene layout definition
 * @returns Object with field values
 */
declare function readGene<T extends GeneLayout>(memory: WebAssembly.Memory, ptr: number, layout: T): Record<string, unknown>;
/**
 * Get byte size for a field type
 */
declare function getTypeSize(type: GeneField['type']): number;
/**
 * Get alignment for a field type
 */
declare function getTypeAlignment(type: GeneField['type']): number;
/**
 * Calculate gene layout from field definitions
 */
declare function calculateLayout(name: string, fields: Omit<GeneField, 'offset'>[]): GeneLayout;

export { BumpAllocator, type GeneField, type GeneFieldType, type GeneLayout, type GeneValues, type Loa, type LoaContext, LoaRegistry, type LoadOptions, type MemoryManager, Seance, type SeanceInstance, Spirit, type SpiritInstance, SpiritLoader, SpiritMemoryManager, calculateLayout, coreLoa, createLoa, createLoggingLoa, createSeance, decodeString, encodeString, getTypeAlignment, getTypeSize, loadSpirit, readGene, withSeance, writeGene };
