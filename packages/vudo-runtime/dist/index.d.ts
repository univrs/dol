/**
 * Core type definitions for @vudo/runtime
 */
/** Supported primitive types in WASM memory */
type GeneFieldType = 'i32' | 'i64' | 'f32' | 'f64' | 'bool' | 'string';
/** A single field in a Gene layout */
interface GeneField {
    /** Field name matching DOL declaration */
    name: string;
    /** WASM type */
    type: GeneFieldType;
    /** Byte offset from struct start */
    offset: number;
}
/** Memory layout for a Gene (generated by dol-codegen) */
interface GeneLayout {
    /** Gene name from DOL source */
    name: string;
    /** Field definitions with offsets */
    fields: GeneField[];
    /** Total size in bytes */
    size: number;
    /** Alignment requirement */
    alignment: number;
}
/** Type helper for gene values */
type GeneValues<T extends GeneLayout> = {
    [K in T['fields'][number]['name']]: T['fields'][number] extends {
        name: K;
        type: infer Type;
    } ? Type extends 'i64' ? bigint : Type extends 'f64' ? number : Type extends 'f32' ? number : Type extends 'i32' ? number : Type extends 'bool' ? boolean : Type extends 'string' ? string : unknown : unknown;
};
/** Options for loading a Spirit */
interface LoadOptions {
    /** Custom host function implementations */
    imports?: Record<string, WebAssembly.ImportValue>;
    /** Memory configuration */
    memory?: {
        /** Initial memory pages (64KB each) */
        initial?: number;
        /** Maximum memory pages */
        maximum?: number;
    };
    /** Enable debug logging */
    debug?: boolean;
    /** Loa registry for service injection */
    loas?: LoaRegistry$1;
}
/** Spirit instance returned by loader */
interface SpiritInstance {
    /** Call an exported function */
    call<R = unknown>(name: string, args?: unknown[]): R;
    /** Get typed interface */
    as<T extends object>(): T;
    /** Access memory manager */
    readonly memory: MemoryManager;
    /** Raw WASM exports */
    readonly exports: WebAssembly.Exports;
}
/** A Loa (service) that can be injected into Spirits */
interface Loa {
    /** Unique service name */
    name: string;
    /** Semantic version */
    version: string;
    /** List of capabilities provided */
    capabilities: string[];
    /** Factory function returning host function implementations */
    provides: (context: LoaContext) => Record<string, WebAssembly.ImportValue>;
}
/** Context passed to Loa providers */
interface LoaContext {
    /** WASM memory for the Spirit */
    memory: WebAssembly.Memory;
    /** Allocator for memory operations */
    alloc: (size: number) => number;
    /** Debug mode flag */
    debug: boolean;
}
/** Registry for managing Loa services */
interface LoaRegistry$1 {
    /** Register a new Loa */
    register(loa: Loa): void;
    /** Get a Loa by name */
    get(name: string): Loa | undefined;
    /** Check if a Loa is registered */
    has(name: string): boolean;
    /** Get all registered Loas */
    all(): Loa[];
    /** Unregister a Loa */
    unregister(name: string): boolean;
    /** Build imports object from registered Loas */
    buildImports(context: LoaContext): Record<string, WebAssembly.ImportValue>;
}
/** A Séance manages multiple Spirit instances */
interface SeanceInstance {
    /** Summon a Spirit into the session */
    summon(name: string, source: string | ArrayBuffer): Promise<void>;
    /** Invoke a function on a summoned Spirit */
    invoke<R = unknown>(spiritName: string, funcName: string, args?: unknown[]): Promise<R>;
    /** Get a summoned Spirit by name */
    getSpirit(name: string): SpiritInstance | undefined;
    /** Dismiss the session and clean up */
    dismiss(): Promise<void>;
    /** List all summoned Spirit names */
    spirits(): string[];
}
/** Memory manager for a Spirit instance */
interface MemoryManager {
    /** Allocate bytes, returns pointer */
    alloc(size: number, align?: number): number;
    /** Free allocated memory (no-op for bump allocator) */
    free(ptr: number): void;
    /** Reset allocator */
    reset(): void;
    /** Read a Gene from memory */
    readGene<T extends GeneLayout>(ptr: number, layout: T): Record<string, unknown>;
    /** Write a Gene to memory */
    writeGene<T extends GeneLayout>(ptr: number, values: Record<string, unknown>, layout: T): void;
    /** Encode a string, returns pointer */
    encodeString(str: string): number;
    /** Decode a string from pointer */
    decodeString(ptr: number): string;
    /** Get raw memory buffer */
    readonly buffer: ArrayBuffer;
    /** Get current allocation offset */
    readonly offset: number;
}

/**
 * Spirit - WASM module loader and wrapper
 *
 * A Spirit is a compiled DOL program running in WASM.
 */

/**
 * Spirit instance wrapping a loaded WASM module
 */
declare class Spirit implements SpiritInstance {
    private instance;
    private wasmMemory;
    private memoryManager;
    private debug;
    constructor(instance: WebAssembly.Instance, memory: WebAssembly.Memory, debug?: boolean);
    /**
     * Call an exported function by name
     */
    call<R = unknown>(name: string, args?: unknown[]): R;
    /**
     * Get a typed interface to the Spirit
     *
     * Allows type-safe calls using generated TypeScript types:
     * ```typescript
     * import type { Calculator } from './generated/calculator.types';
     * const calc = spirit.as<Calculator>();
     * const sum = calc.add(1n, 2n);
     * ```
     */
    as<T extends object>(): T;
    /**
     * Get the memory manager for this Spirit
     */
    get memory(): MemoryManager;
    /**
     * Get raw WASM exports
     */
    get exports(): WebAssembly.Exports;
    /**
     * Get raw WASM memory
     */
    get rawMemory(): WebAssembly.Memory;
    /**
     * Check if the Spirit exports a function
     */
    hasFunction(name: string): boolean;
    /**
     * List all exported function names
     */
    listFunctions(): string[];
}
/**
 * Loader for Spirit WASM modules
 */
declare class SpiritLoader {
    private registry;
    private debug;
    constructor(options?: {
        loas?: LoaRegistry$1;
        debug?: boolean;
    });
    /**
     * Load a Spirit from WASM bytes
     */
    load(wasmBytes: ArrayBuffer | Uint8Array, options?: LoadOptions): Promise<Spirit>;
    /**
     * Load a Spirit from a URL (browser) or file path (Node.js)
     */
    loadFrom(source: string | URL, options?: LoadOptions): Promise<Spirit>;
    /**
     * Fetch WASM bytes from URL or file
     */
    private fetchBytes;
}
/**
 * Load a Spirit from WASM bytes or URL
 *
 * @example
 * ```typescript
 * // From bytes
 * const spirit = await loadSpirit(wasmBytes);
 *
 * // From URL/path
 * const spirit = await loadSpirit('/spirits/calculator.wasm');
 *
 * // With options
 * const spirit = await loadSpirit(wasmBytes, {
 *   debug: true,
 *   memory: { initial: 32 },
 * });
 * ```
 */
declare function loadSpirit(source: string | URL | ArrayBuffer | Uint8Array, options?: LoadOptions): Promise<Spirit>;

/**
 * Loa - Service injection for Spirit instances
 *
 * A Loa is a named service that provides host functions to WASM modules.
 * Based on vudo-runtime-spec.md host function implementations.
 */

/**
 * Core Loa providing essential host functions
 *
 * These functions are available to all Spirits by default:
 * - vudo_print: Print a string to console
 * - vudo_alloc: Allocate memory (bound to Spirit's allocator)
 * - vudo_now: Get current timestamp
 * - vudo_random: Generate random number
 * - vudo_emit_effect: Emit a side effect
 */
declare const coreLoa: Loa;
/**
 * Registry for managing Loa services
 *
 * Allows registration of custom Loas that provide host functions to Spirits.
 */
declare class LoaRegistry implements LoaRegistry$1 {
    private loas;
    constructor();
    /**
     * Register a new Loa
     * @param loa - Loa to register
     * @throws Error if Loa with same name already exists
     */
    register(loa: Loa): void;
    /**
     * Get a Loa by name
     */
    get(name: string): Loa | undefined;
    /**
     * Get all registered Loas
     */
    all(): Loa[];
    /**
     * Check if a Loa is registered
     */
    has(name: string): boolean;
    /**
     * Unregister a Loa
     */
    unregister(name: string): boolean;
    /**
     * Build WASM imports object from all registered Loas
     */
    buildImports(context: LoaContext): Record<string, WebAssembly.ImportValue>;
}
/**
 * Create a simple Loa from host function definitions
 */
declare function createLoa(name: string, version: string, functions: Record<string, (context: LoaContext) => WebAssembly.ImportValue>): Loa;
/**
 * Create a logging Loa with custom logger
 */
declare function createLoggingLoa(logger: {
    log: (msg: string) => void;
    error: (msg: string) => void;
    debug: (msg: string) => void;
}): Loa;

/**
 * MessageBus - Inter-Spirit communication
 *
 * Enables Spirits to send and receive messages within a Séance session.
 * Messages are queued per-Spirit and can be consumed synchronously.
 */

/**
 * A message sent between Spirits
 */
interface Message$1 {
    /** Source Spirit name */
    from: string;
    /** Destination Spirit name */
    to: string;
    /** Message type/channel identifier */
    channel: number;
    /** Raw payload bytes */
    payload: Uint8Array;
    /** Timestamp when message was sent */
    timestamp: number;
}
/**
 * Message handler callback type
 */
type MessageHandler = (message: Message$1) => void;
/**
 * Message bus for Spirit-to-Spirit communication
 *
 * @example
 * ```typescript
 * const bus = new MessageBus();
 *
 * // Register Spirits
 * bus.register('ping');
 * bus.register('pong');
 *
 * // Send a message
 * bus.send('ping', 'pong', 1, new Uint8Array([1, 2, 3]));
 *
 * // Receive message
 * const msg = bus.recv('pong', 1);
 * ```
 */
declare class MessageBus {
    /** Message queues per Spirit name */
    private queues;
    /** Global message handlers */
    private handlers;
    /** Debug mode flag */
    private debug;
    constructor(options?: {
        debug?: boolean;
    });
    /**
     * Register a Spirit to receive messages
     */
    register(name: string): void;
    /**
     * Unregister a Spirit from the message bus
     */
    unregister(name: string): void;
    /**
     * Check if a Spirit is registered
     */
    isRegistered(name: string): boolean;
    /**
     * Send a message to a Spirit
     *
     * @param from - Source Spirit name
     * @param to - Destination Spirit name
     * @param channel - Message channel/type identifier
     * @param payload - Raw bytes to send
     * @returns true if message was delivered, false if destination not found
     */
    send(from: string, to: string, channel: number, payload: Uint8Array): boolean;
    /**
     * Receive a message for a Spirit
     *
     * @param name - Spirit name to receive for
     * @param channel - Optional channel filter (0 = any channel)
     * @returns Next message or undefined if queue is empty
     */
    recv(name: string, channel?: number): Message$1 | undefined;
    /**
     * Peek at the next message without removing it
     */
    peek(name: string, channel?: number): Message$1 | undefined;
    /**
     * Get the number of pending messages for a Spirit
     */
    pending(name: string, channel?: number): number;
    /**
     * Add a message handler for a Spirit
     */
    onMessage(name: string, handler: MessageHandler): void;
    /**
     * Clear all messages for a Spirit
     */
    clear(name: string): void;
    /**
     * Clear all messages in the bus
     */
    clearAll(): void;
    /**
     * Get all registered Spirit names
     */
    spirits(): string[];
}
/**
 * Create a messaging Loa that provides vudo_send and vudo_recv functions
 *
 * @param bus - MessageBus instance
 * @param spiritName - Name of the Spirit using this Loa
 */
declare function createMessagingLoa(bus: MessageBus, spiritName: string): Loa;
/**
 * Create a new MessageBus
 */
declare function createMessageBus(options?: {
    debug?: boolean;
}): MessageBus;

/**
 * Séance - Session management for multiple Spirit instances
 *
 * A Séance coordinates multiple Spirits, allowing them to interact
 * within a shared session context.
 */

/**
 * Session manager for coordinating multiple Spirit instances
 *
 * @example
 * ```typescript
 * const seance = new Seance();
 *
 * // Summon Spirits
 * await seance.summon('calc', '/spirits/calculator.wasm');
 * await seance.summon('logger', '/spirits/logger.wasm');
 *
 * // Invoke functions
 * const result = await seance.invoke('calc', 'add', [1, 2]);
 * await seance.invoke('logger', 'log', [`Result: ${result}`]);
 *
 * // Cleanup
 * await seance.dismiss();
 * ```
 */
declare class Seance implements SeanceInstance {
    private spiritMap;
    private registry;
    private messageBus;
    private debug;
    private defaultOptions;
    constructor(options?: {
        loas?: LoaRegistry;
        messageBus?: MessageBus;
        debug?: boolean;
        defaultLoadOptions?: LoadOptions;
    });
    /**
     * Summon a Spirit into the session
     *
     * @param name - Unique name for the Spirit within this session
     * @param source - WASM bytes or URL to load from
     * @param options - Additional load options
     */
    summon(name: string, source: string | ArrayBuffer | Uint8Array, options?: LoadOptions): Promise<void>;
    /**
     * Invoke a function on a summoned Spirit
     *
     * @param spiritName - Name of the Spirit to invoke
     * @param funcName - Function name to call
     * @param args - Arguments to pass
     * @returns Function result
     */
    invoke<R = unknown>(spiritName: string, funcName: string, args?: unknown[]): Promise<R>;
    /**
     * Get a summoned Spirit by name
     */
    getSpirit(name: string): SpiritInstance | undefined;
    /**
     * Check if a Spirit is summoned
     */
    hasSpirit(name: string): boolean;
    /**
     * List all summoned Spirit names
     */
    spirits(): string[];
    /**
     * Dismiss a specific Spirit from the session
     */
    release(name: string): Promise<void>;
    /**
     * Dismiss the session and clean up all Spirits
     */
    dismiss(): Promise<void>;
    /**
     * Get the Loa registry for this session
     */
    get loas(): LoaRegistry;
    /**
     * Get the MessageBus for this session
     */
    get messages(): MessageBus;
    /**
     * Get the number of summoned Spirits
     */
    get size(): number;
    /**
     * Send a message from one Spirit to another
     *
     * @param from - Source Spirit name
     * @param to - Destination Spirit name
     * @param channel - Message channel identifier
     * @param payload - Data to send
     * @returns true if message was delivered
     *
     * @example
     * ```typescript
     * seance.send('ping', 'pong', 1, new Uint8Array([1, 2, 3]));
     * ```
     */
    send(from: string, to: string, channel: number, payload: Uint8Array): boolean;
    /**
     * Check number of pending messages for a Spirit
     *
     * @param name - Spirit name
     * @param channel - Optional channel filter (0 = all channels)
     */
    pending(name: string, channel?: number): number;
    /**
     * Broadcast a message to all Spirits except the sender
     *
     * @param from - Source Spirit name
     * @param channel - Message channel identifier
     * @param payload - Data to send
     * @returns Number of Spirits that received the message
     *
     * @example
     * ```typescript
     * seance.broadcast('coordinator', 1, new Uint8Array([0xFF]));
     * ```
     */
    broadcast(from: string, channel: number, payload: Uint8Array): number;
}
/**
 * Create a new Séance session
 */
declare function createSeance(options?: {
    loas?: LoaRegistry;
    messageBus?: MessageBus;
    debug?: boolean;
}): Seance;
/**
 * Run a Spirit session with automatic cleanup
 *
 * @example
 * ```typescript
 * await withSeance(async (seance) => {
 *   await seance.summon('calc', './calculator.wasm');
 *   const result = await seance.invoke('calc', 'add', [1, 2]);
 *   console.log('Result:', result);
 * });
 * // Session is automatically dismissed
 * ```
 */
declare function withSeance<T>(fn: (seance: Seance) => Promise<T>, options?: {
    loas?: LoaRegistry;
    messageBus?: MessageBus;
    debug?: boolean;
}): Promise<T>;

/**
 * Memory management for Spirit instances
 *
 * Internal implementation based on vudo-runtime-spec.md BumpAllocator
 */

/**
 * Bump allocator for WASM linear memory
 *
 * Simple and fast allocation strategy - memory is allocated sequentially
 * and only freed when the entire allocator is reset.
 *
 * @internal
 */
declare class BumpAllocator {
    private memory;
    private currentOffset;
    private readonly baseOffset;
    /**
     * Create a new bump allocator
     * @param memory - WASM memory instance
     * @param baseOffset - Starting offset (default 1024 to avoid null pointer region)
     */
    constructor(memory: WebAssembly.Memory, baseOffset?: number);
    /**
     * Allocate `size` bytes with alignment
     * @param size - Number of bytes to allocate
     * @param align - Alignment requirement (default 8 for 64-bit)
     * @returns Pointer to allocated memory
     */
    alloc(size: number, align?: number): number;
    /**
     * Free memory at pointer (no-op for bump allocator)
     * Memory is only reclaimed on reset()
     */
    free(_ptr: number): void;
    /**
     * Reset allocator to initial state
     * All previously allocated memory becomes invalid
     */
    reset(): void;
    /**
     * Get current allocation offset
     */
    get offset(): number;
    /**
     * Get raw memory buffer
     */
    get buffer(): ArrayBuffer;
    /**
     * Get WASM memory instance
     */
    get rawMemory(): WebAssembly.Memory;
}
/**
 * Memory manager implementation wrapping BumpAllocator
 * Provides high-level API for gene operations
 */
declare class SpiritMemoryManager implements MemoryManager {
    private allocator;
    private wasmMemory;
    constructor(memory: WebAssembly.Memory, baseOffset?: number);
    alloc(size: number, align?: number): number;
    free(ptr: number): void;
    reset(): void;
    readGene<T extends GeneLayout>(ptr: number, layout: T): Record<string, unknown>;
    writeGene<T extends GeneLayout>(ptr: number, values: Record<string, unknown>, layout: T): void;
    encodeString(str: string): number;
    decodeString(ptr: number): string;
    get buffer(): ArrayBuffer;
    get offset(): number;
    /**
     * Get typed array views of memory
     */
    get views(): {
        i8: Int8Array<ArrayBuffer>;
        u8: Uint8Array<ArrayBuffer>;
        i32: Int32Array<ArrayBuffer>;
        u32: Uint32Array<ArrayBuffer>;
        i64: BigInt64Array<ArrayBuffer>;
        u64: BigUint64Array<ArrayBuffer>;
        f32: Float32Array<ArrayBuffer>;
        f64: Float64Array<ArrayBuffer>;
    };
}

/**
 * Type bridge utilities for DOL ↔ JavaScript conversion
 *
 * Handles encoding/decoding of DOL types in WASM linear memory.
 * Based on vudo-runtime-spec.md string and gene helpers.
 */

/**
 * Encode a JavaScript string into WASM memory
 *
 * Format: 4-byte length prefix (u32, little-endian) + UTF-8 bytes
 *
 * @param memory - WASM memory instance
 * @param allocator - Allocator for memory allocation
 * @param str - String to encode
 * @returns Pointer to encoded string
 */
declare function encodeString(memory: WebAssembly.Memory, allocator: {
    alloc: (size: number, align?: number) => number;
}, str: string): number;
/**
 * Decode a string from WASM memory
 *
 * Expects format: 4-byte length prefix (u32, little-endian) + UTF-8 bytes
 *
 * @param memory - WASM memory instance
 * @param ptr - Pointer to encoded string
 * @returns Decoded JavaScript string
 */
declare function decodeString(memory: WebAssembly.Memory, ptr: number): string;
/**
 * Write a gene struct to WASM memory
 *
 * @param memory - WASM memory instance
 * @param ptr - Pointer to write location
 * @param layout - Gene layout definition
 * @param values - Field values to write
 */
declare function writeGene(memory: WebAssembly.Memory, ptr: number, layout: GeneLayout, values: Record<string, unknown>): void;
/**
 * Read a gene struct from WASM memory
 *
 * @param memory - WASM memory instance
 * @param ptr - Pointer to gene location
 * @param layout - Gene layout definition
 * @returns Object with field values
 */
declare function readGene<T extends GeneLayout>(memory: WebAssembly.Memory, ptr: number, layout: T): Record<string, unknown>;
/**
 * Get byte size for a field type
 */
declare function getTypeSize(type: GeneField['type']): number;
/**
 * Get alignment for a field type
 */
declare function getTypeAlignment(type: GeneField['type']): number;
/**
 * Calculate gene layout from field definitions
 */
declare function calculateLayout(name: string, fields: Omit<GeneField, 'offset'>[]): GeneLayout;

/**
 * Type definitions for the DOL ABI
 *
 * These types mirror the Rust ABI definitions and are designed
 * to serialize/deserialize cleanly with serde_json.
 */
/**
 * A qualified identifier in DOL (e.g., "domain.property" or "domain.property.version")
 *
 * @example
 * const id = new QualifiedId('container', 'exists');
 * const idWithVersion = new QualifiedId('container', 'exists', '1.0.0');
 */
declare class QualifiedId {
    /**
     * Domain part of the identifier
     */
    domain: string;
    /**
     * Property part of the identifier
     */
    property: string;
    /**
     * Optional version part (semantic version)
     */
    version?: string;
    /**
     * Create a new qualified identifier
     * @param domain - Domain part
     * @param property - Property part
     * @param version - Optional version part
     */
    constructor(domain: string, property: string, version?: string);
    /**
     * Convert to string representation (e.g., "domain.property.1.0.0")
     */
    toString(): string;
    /**
     * Parse a qualified identifier string into a QualifiedId
     * @param input - String in format "domain.property" or "domain.property.version"
     * @returns Parsed QualifiedId
     */
    static parse(input: string): QualifiedId;
}
/**
 * Serializable version of QualifiedId for JSON serialization
 * Mirrors the Rust serde representation
 */
interface QualifiedIdSerialized {
    domain: string;
    property: string;
    version?: string;
}
/**
 * Standard effect type for logging and tracing
 * Used to represent side effects and state changes
 */
interface StandardEffect {
    /** Type of effect (e.g., "log", "state_change", "function_call") */
    effect_type: string;
    /** Payload data for the effect */
    payload: unknown;
    /** Unix timestamp of when the effect occurred */
    timestamp: number;
}
/**
 * Standard event type for event-driven communication
 * Compatible with the event bus architecture
 */
interface StandardEvent {
    /** Unique event identifier */
    id: string;
    /** Event type classifier */
    event_type: string;
    /** Originating component/module */
    source: string;
    /** Event payload data */
    data: unknown;
    /** Unix timestamp of event creation */
    timestamp: number;
    /** Optional metadata key-value pairs */
    metadata?: Record<string, unknown>;
}
/**
 * Logging level enumeration
 * Ordered from least to most severe
 */
declare enum LogLevel {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Error = 3
}
/**
 * Result code enumeration for operation status
 * Mirrors Rust enum with numeric discriminants
 */
declare enum ResultCode {
    Success = 0,
    Error = 1,
    Pending = 2,
    Timeout = 3
}
/**
 * Convert LogLevel enum value to string
 * @param level - LogLevel enum value
 * @returns String representation
 */
declare function logLevelToString(level: LogLevel): string;
/**
 * Convert string to LogLevel enum
 * @param str - String representation
 * @returns LogLevel enum value
 */
declare function stringToLogLevel(str: string): LogLevel;
/**
 * Convert ResultCode enum value to string
 * @param code - ResultCode enum value
 * @returns String representation
 */
declare function resultCodeToString(code: ResultCode): string;
/**
 * Convert string to ResultCode enum
 * @param str - String representation
 * @returns ResultCode enum value
 */
declare function stringToResultCode(str: string): ResultCode;

/**
 * Message types for host-to-ABI communication
 *
 * These types define the message protocol between the DOL runtime (host)
 * and WASM modules (guests). All types are JSON-serializable.
 */
/**
 * Header information for a message
 * Contains metadata about the message for routing and tracking
 */
interface MessageHeader {
    /** Unique message identifier for request-response matching */
    id: string;
    /** Message type classifier (e.g., "init", "call", "event") */
    msg_type: string;
    /** Source identifier (host or module name) */
    source: string;
    /** Destination identifier (module or host) */
    destination: string;
    /** Unix timestamp of message creation */
    timestamp: number;
    /** Message version/protocol version */
    version: string;
    /** Optional correlation ID for tracing message chains */
    correlation_id?: string;
    /** Message priority (0-3, higher = more important) */
    priority?: number;
    /** Optional timeout in milliseconds */
    timeout_ms?: number;
}
/**
 * Message payload wrapper
 * Encapsulates the actual data being transmitted
 */
interface MessagePayload {
    /** Payload data (can be any JSON-serializable value) */
    data: unknown;
    /** Optional encoding hint (e.g., "utf-8", "base64") */
    encoding?: string;
    /** Optional content type (e.g., "application/json") */
    content_type?: string;
    /** Optional compression hint (e.g., "gzip") */
    compression?: string;
}
/**
 * A message from the host to a WASM module or vice versa
 *
 * This is the primary communication unit in the ABI. It combines
 * header information with payload data in a single serializable structure.
 *
 * @example
 * const msg = new Message(
 *   '123',
 *   'call',
 *   { function: 'init', args: [] },
 *   { source: 'host', destination: 'spirit-1' }
 * );
 */
declare class Message {
    /** Message header with metadata */
    header: MessageHeader;
    /** Message payload wrapper */
    payload: MessagePayload;
    /**
     * Create a new message
     * @param id - Unique message identifier
     * @param msg_type - Type of message
     * @param data - Payload data
     * @param options - Optional message configuration
     */
    constructor(id: string, msg_type: string, data: unknown, options?: {
        source?: string;
        destination?: string;
        timestamp?: number;
        version?: string;
        correlation_id?: string;
        priority?: number;
        timeout_ms?: number;
        encoding?: string;
        content_type?: string;
        compression?: string;
    });
    /**
     * Serialize to JSON (for transmission)
     * @returns JSON string representation
     */
    toJSON(): string;
    /**
     * Deserialize from JSON string
     * @param json - JSON string representation
     * @returns Parsed Message
     */
    static fromJSON(json: string): Message;
    /**
     * Create a response to this message
     * @param success - Whether the operation succeeded
     * @param data - Response data
     * @param error - Optional error message
     * @returns Response message
     */
    response(success: boolean, data: unknown, error?: string): Response;
}
/**
 * A response message from a WASM module to the host (or vice versa)
 *
 * Responses are typically created in reply to a Message and include
 * a status code and optional error information.
 *
 * @example
 * const response = new Response(
 *   'req-123',
 *   true,
 *   { result: 42 },
 *   { source: 'spirit-1', destination: 'host' }
 * );
 */
declare class Response {
    /** Message header with metadata */
    header: MessageHeader;
    /** Response status: true for success, false for error */
    success: boolean;
    /** Response data payload */
    data: unknown;
    /** Optional error message */
    error?: string;
    /**
     * Create a new response
     * @param id - Unique response identifier (should match request)
     * @param success - Whether the operation succeeded
     * @param data - Response data
     * @param options - Optional response configuration
     */
    constructor(id: string, success: boolean, data: unknown, options?: {
        source?: string;
        destination?: string;
        timestamp?: number;
        version?: string;
        correlation_id?: string;
        priority?: number;
        error?: string;
    });
    /**
     * Create a successful response with data
     * @param id - Response identifier
     * @param data - Response data
     * @param options - Optional configuration
     * @returns Response instance
     */
    static success(id: string, data: unknown, options?: {
        source?: string;
        destination?: string;
        version?: string;
        priority?: number;
    }): Response;
    /**
     * Create a failed response with error message
     * @param id - Response identifier
     * @param error - Error message
     * @param options - Optional configuration
     * @returns Response instance
     */
    static error(id: string, error: string, options?: {
        source?: string;
        destination?: string;
        version?: string;
        priority?: number;
    }): Response;
    /**
     * Serialize to JSON (for transmission)
     * @returns JSON string representation
     */
    toJSON(): string;
    /**
     * Deserialize from JSON string
     * @param json - JSON string representation
     * @returns Parsed Response
     */
    static fromJSON(json: string): Response;
}
/**
 * Options for sending a message
 * Allows customization of timeout and retry behavior
 */
interface SendOptions {
    /** Timeout in milliseconds (default: 30000) */
    timeout?: number;
    /** Number of retry attempts on failure (default: 3) */
    retries?: number;
    /** Delay between retries in milliseconds (default: 100) */
    retryDelay?: number;
    /** Whether to throw on error (default: true) */
    throwOnError?: boolean;
}
/**
 * Message filter predicate
 * Returns true if message should be processed
 */
type MessageFilter = (message: Message) => boolean;

/**
 * Error types for the DOL ABI
 *
 * These types mirror the Rust error enum and provide structured
 * error handling across the host-guest boundary.
 */
/**
 * Discriminant enum for ABI error types
 * Must match the Rust enum variant order
 */
declare enum AbiErrorType {
    InvalidConfig = "InvalidConfig",
    InvalidMessage = "InvalidMessage",
    HostError = "HostError",
    TypeMismatch = "TypeMismatch",
    Other = "Other"
}
/**
 * Base ABI error class
 *
 * All ABI errors inherit from this class. It provides structured
 * error information that can be serialized for transmission across
 * the host-guest boundary.
 *
 * @example
 * try {
 *   // Some operation
 * } catch (err) {
 *   if (err instanceof AbiError) {
 *     console.error(`${err.type}: ${err.message}`);
 *   }
 * }
 */
declare class AbiError extends Error {
    /** Type of error (for serialization and matching) */
    type: AbiErrorType;
    /** Error code for programmatic handling */
    code: string;
    /** Nested error details (if any) */
    details?: unknown;
    /** Stack trace context */
    context?: string;
    /**
     * Create a new AbiError
     * @param message - Human-readable error message
     * @param type - Error type discriminant
     * @param code - Error code for programmatic matching
     * @param details - Optional error details
     */
    constructor(message: string, type?: AbiErrorType, code?: string, details?: unknown);
    /**
     * Serialize error to JSON-compatible object
     * Suitable for transmission in Response messages
     */
    toJSON(): {
        type: string;
        code: string;
        message: string;
        details?: unknown;
        stack?: string;
    };
    /**
     * Serialize error to string for logging
     */
    toString(): string;
    /**
     * Create an InvalidConfig error
     * @param message - Error message
     * @param details - Optional error details
     * @returns AbiError instance
     */
    static invalidConfig(message: string, details?: unknown): AbiError;
    /**
     * Create an InvalidMessage error
     * @param message - Error message
     * @param details - Optional error details
     * @returns AbiError instance
     */
    static invalidMessage(message: string, details?: unknown): AbiError;
    /**
     * Create a HostError
     * @param message - Error message
     * @param details - Optional error details
     * @returns AbiError instance
     */
    static hostError(message: string, details?: unknown): AbiError;
    /**
     * Create a TypeMismatch error
     * @param expected - Expected type
     * @param received - Received type
     * @param details - Optional error details
     * @returns AbiError instance
     */
    static typeMismatch(expected: string, received: string, details?: unknown): AbiError;
    /**
     * Create a generic error
     * @param message - Error message
     * @param details - Optional error details
     * @returns AbiError instance
     */
    static other(message: string, details?: unknown): AbiError;
}
/**
 * Result type for ABI operations
 * Mirrors Rust's Result<T, E> pattern
 *
 * @example
 * const result: AbiResult<number> = {
 *   ok: true,
 *   value: 42
 * };
 *
 * const error: AbiResult<number> = {
 *   ok: false,
 *   error: new AbiError('Operation failed')
 * };
 */
type AbiResult<T> = {
    ok: true;
    value: T;
} | {
    ok: false;
    error: AbiError;
};
/**
 * Create a successful result
 * @param value - Result value
 * @returns AbiResult with ok=true
 */
declare function ok<T>(value: T): AbiResult<T>;
/**
 * Create an error result
 * @param error - Error value
 * @returns AbiResult with ok=false
 */
declare function err<T>(error: AbiError | string): AbiResult<T>;
/**
 * Check if a result is ok
 * @param result - Result to check
 * @returns True if ok
 */
declare function isOk<T>(result: AbiResult<T>): result is {
    ok: true;
    value: T;
};
/**
 * Check if a result is an error
 * @param result - Result to check
 * @returns True if error
 */
declare function isErr<T>(result: AbiResult<T>): result is {
    ok: false;
    error: AbiError;
};
/**
 * Extract value from result or throw
 * @param result - Result to unwrap
 * @returns Value if ok
 * @throws {AbiError} If result is error
 */
declare function unwrap<T>(result: AbiResult<T>): T;
/**
 * Extract value with default fallback
 * @param result - Result to unwrap
 * @param defaultValue - Default value if error
 * @returns Value if ok, otherwise defaultValue
 */
declare function unwrapOr<T>(result: AbiResult<T>, defaultValue: T): T;
/**
 * Transform result value with a mapping function
 * @param result - Result to map
 * @param fn - Mapping function
 * @returns New result with mapped value
 */
declare function map<T, U>(result: AbiResult<T>, fn: (value: T) => U): AbiResult<U>;
/**
 * Chain results with a function that returns a result
 * @param result - Result to chain
 * @param fn - Function returning a result
 * @returns Chained result
 */
declare function flatMap<T, U>(result: AbiResult<T>, fn: (value: T) => AbiResult<U>): AbiResult<U>;
/**
 * Helper to convert promises to AbiResult
 * @param promise - Promise to convert
 * @returns AbiResult of the resolved value
 */
declare function fromPromise<T>(promise: Promise<T>): Promise<AbiResult<T>>;

/**
 * DOL ABI (Application Binary Interface) Module
 *
 * This module provides the core ABI types and interfaces for DOL WASM-based applications.
 * It defines the contract between the DOL runtime and compiled DOL programs.
 *
 * The ABI is based on the Rust dol-abi crate and provides TypeScript equivalents
 * for seamless interoperability across the host-guest boundary.
 *
 * @example
 * ```typescript
 * import {
 *   Message,
 *   Response,
 *   AbiError,
 *   QualifiedId,
 *   ABI_VERSION,
 *   IMPORT_MODULE
 * } from '@vudo/runtime/abi';
 *
 * // Create a qualified identifier
 * const id = new QualifiedId('container', 'exists', '1.0.0');
 * console.log(id.toString()); // "container.exists.1.0.0"
 *
 * // Create a message
 * const msg = new Message(
 *   'msg-1',
 *   'call',
 *   { function: 'init', args: [] },
 *   { source: 'host', destination: 'spirit-1' }
 * );
 *
 * // Create a response
 * const response = Response.success('msg-1', { result: 'ok' });
 * console.log(response.toJSON());
 *
 * // Handle errors
 * const error = AbiError.invalidConfig('Missing required field');
 * console.error(error.toString());
 * ```
 */

/**
 * ABI version string
 * Used for version negotiation between host and guest
 * @constant
 */
declare const ABI_VERSION = "0.1.0";
/**
 * WASM import module name
 * This is the namespace used for WASM imports (e.g., IMPORT_MODULE.sendMessage)
 * @constant
 */
declare const IMPORT_MODULE = "vudo";

/**
 * Type guard to check if a value is a QualifiedId
 * @param value - Value to check
 * @returns True if value is a QualifiedId
 */
declare function isQualifiedId(value: unknown): value is QualifiedId;
/**
 * Type guard to check if a value is a Message
 * @param value - Value to check
 * @returns True if value is a Message
 */
declare function isMessage(value: unknown): value is Message;
/**
 * Type guard to check if a value is a Response
 * @param value - Value to check
 * @returns True if value is a Response
 */
declare function isResponse(value: unknown): value is Response;
/**
 * Type guard to check if a value is an AbiError
 * @param value - Value to check
 * @returns True if value is an AbiError
 */
declare function isAbiError(value: unknown): value is AbiError;
/**
 * ABI compatibility checker
 * Verifies that host and guest are compatible versions
 */
declare class AbiCompat {
    /**
     * Check if two ABI versions are compatible
     * Uses semantic versioning rules
     * @param hostVersion - Host ABI version
     * @param guestVersion - Guest ABI version
     * @returns True if versions are compatible
     */
    static compatible(hostVersion: string, guestVersion: string): boolean;
    /**
     * Get a version negotiation message
     * @param version - Version string
     * @returns Message requesting version negotiation
     */
    static versionMessage(version: string): Message;
}
/**
 * Serialized form of AbiError for transmission
 */
interface SerializedAbiError {
    type: string;
    code: string;
    message: string;
    details?: unknown;
    stack?: string;
}
/**
 * Serialize an AbiError to JSON-compatible format
 * @param error - Error to serialize
 * @returns Serialized error
 */
declare function serializeError(error: AbiError): SerializedAbiError;
/**
 * Deserialize an error from JSON format
 * @param data - Serialized error data
 * @returns AbiError instance
 */
declare function deserializeError(data: SerializedAbiError): AbiError;

export { ABI_VERSION, AbiCompat, AbiError, AbiErrorType, type AbiResult, BumpAllocator, type GeneField, type GeneFieldType, type GeneLayout, type GeneValues, IMPORT_MODULE, type Loa, type LoaContext, LoaRegistry, type LoadOptions, LogLevel, type MemoryManager, type Message$1 as Message, MessageBus, type MessageFilter, type MessageHandler, type MessageHeader, type MessagePayload, QualifiedId, type QualifiedIdSerialized, Response, ResultCode, Seance, type SeanceInstance, type SendOptions, type SerializedAbiError, Spirit, type SpiritInstance, SpiritLoader, SpiritMemoryManager, type StandardEffect, type StandardEvent, calculateLayout, coreLoa, createLoa, createLoggingLoa, createMessageBus, createMessagingLoa, createSeance, decodeString, deserializeError, encodeString, err, flatMap, fromPromise, getTypeAlignment, getTypeSize, isAbiError, isErr, isMessage, isOk, isQualifiedId, isResponse, loadSpirit, logLevelToString, map, ok, readGene, resultCodeToString, serializeError, stringToLogLevel, stringToResultCode, unwrap, unwrapOr, withSeance, writeGene };
