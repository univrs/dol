# claude-flow-fix-binary.yaml
#
# Mission: Fix dol-check binary to support DOL 2.0 syntax
#
# Run: npx claude-flow@alpha swarm "read claude-flow-fix-binary.yaml --workflow fix-all"
#
# Issues:
# 1. parse_file() returns single Declaration, can't handle module/use statements
# 2. Naming validator expects lowercase qualified names, but genes should be PascalCase
#
# ═══════════════════════════════════════════════════════════════════════════════

name: fix-binary
version: 1.0.0
description: Fix dol-check binary for DOL 2.0 support

config:
  max_concurrent_agents: 2
  working_dir: ~/repos/univrs-dol

# ═══════════════════════════════════════════════════════════════════════════════
# AGENTS
# ═══════════════════════════════════════════════════════════════════════════════

agents:
  fix-ast-module:
    name: Add Module AST Types
    role: Add Module and Use declaration types to AST
    instructions: |
      The AST needs Module and Use declaration types that the parser can return.
      
      UPDATE src/ast.rs - Add new declaration variants if not present:
      
      Find the Declaration enum and ensure it has these variants:
      
      ```rust
      /// Top-level declaration in a DOL file
      #[derive(Debug, Clone)]
      pub enum Declaration {
          /// Gene declaration
          Gene(GeneDeclaration),
          /// Trait declaration  
          Trait(TraitDeclaration),
          /// Constraint declaration
          Constraint(ConstraintDeclaration),
          /// System declaration
          System(SystemDeclaration),
          /// Evolution declaration
          Evolution(EvolutionDeclaration),
          /// Module declaration (DOL 2.0)
          Module(ModuleDeclaration),
          /// Use/import declaration (DOL 2.0)
          Use(UseDeclaration),
          /// Function declaration (DOL 2.0)
          Function(FunctionDeclaration),
          /// Constant declaration (DOL 2.0)
          Const(ConstDeclaration),
      }
      ```
      
      Add the ModuleDeclaration struct if not present:
      
      ```rust
      /// Module declaration: module path.to.module @ version
      #[derive(Debug, Clone)]
      pub struct ModuleDeclaration {
          /// Module path segments: ["biology", "types"]
          pub path: Vec<String>,
          /// Optional semantic version
          pub version: Option<String>,
          /// Source span
          pub span: Span,
      }
      
      impl ModuleDeclaration {
          pub fn name(&self) -> String {
              self.path.join(".")
          }
      }
      ```
      
      Add UseDeclaration struct if not present:
      
      ```rust
      /// Use/import declaration
      #[derive(Debug, Clone)]
      pub struct UseDeclaration {
          /// Import path segments
          pub path: Vec<String>,
          /// Specific items to import (empty = import all or single)
          pub items: Vec<UseItem>,
          /// Whether this imports all (path.*)
          pub import_all: bool,
          /// Source span
          pub span: Span,
      }
      
      #[derive(Debug, Clone)]
      pub struct UseItem {
          pub name: String,
          pub alias: Option<String>,
      }
      
      impl UseDeclaration {
          pub fn name(&self) -> String {
              self.path.join(".")
          }
      }
      ```
      
      Update the Declaration::name() method to handle new variants:
      
      ```rust
      impl Declaration {
          pub fn name(&self) -> &str {
              match self {
                  Declaration::Gene(g) => &g.name,
                  Declaration::Trait(t) => &t.name,
                  Declaration::Constraint(c) => &c.name,
                  Declaration::System(s) => &s.name,
                  Declaration::Evolution(e) => &e.name,
                  Declaration::Module(m) => &m.path.join("."),
                  Declaration::Use(u) => &u.path.join("."),
                  Declaration::Function(f) => &f.name,
                  Declaration::Const(c) => &c.name,
              }
          }
      }
      ```
      
      FILE: ~/repos/univrs-dol/src/ast.rs

  fix-parser-module:
    name: Fix Parser Module/Use
    role: Update parser to handle module and use declarations
    dependencies:
      - fix-ast-module
    instructions: |
      The parser needs to recognize module and use as valid declaration starters.
      
      First, find where the parser checks for valid declaration types:
      
      ```bash
      grep -n "gene\|trait\|constraint\|system\|evolves" src/parser.rs | head -30
      ```
      
      UPDATE src/parser.rs - Find the parse() or parse_declaration() function
      and update it to handle module/use:
      
      ```rust
      impl Parser {
          /// Parse a top-level declaration
          pub fn parse(&mut self) -> Result<Declaration, ParseError> {
              // Skip any leading whitespace/comments
              self.skip_trivia();
              
              // Check what kind of declaration this is
              match self.current_token() {
                  // DOL 2.0: Module declaration
                  Token::Module => self.parse_module_declaration(),
                  
                  // DOL 2.0: Use/import declaration
                  Token::Use => self.parse_use_declaration(),
                  
                  // DOL 2.0: Visibility modifier
                  Token::Pub => {
                      self.advance();
                      self.parse_visible_declaration()
                  }
                  
                  // DOL 2.0: Function declaration
                  Token::Fun => self.parse_function_declaration(),
                  
                  // DOL 2.0: Sex function
                  Token::Sex => self.parse_sex_declaration(),
                  
                  // DOL 2.0: Constant
                  Token::Const => self.parse_const_declaration(),
                  
                  // Original DOL 1.x declarations
                  Token::Gene => self.parse_gene(),
                  Token::Trait => self.parse_trait(),
                  Token::Constraint => self.parse_constraint(),
                  Token::System => self.parse_system(),
                  Token::Evolves => self.parse_evolution(),
                  
                  // Unknown
                  token => Err(ParseError::InvalidDeclarationType {
                      found: format!("{:?}", token),
                      span: self.current_span(),
                  }),
              }
          }
          
          /// Parse module declaration: module path.to.module @ version
          fn parse_module_declaration(&mut self) -> Result<Declaration, ParseError> {
              let start = self.current_span();
              self.expect(Token::Module)?;
              
              // Parse dotted path
              let mut path = vec![self.expect_identifier()?];
              while self.check(Token::Dot) {
                  self.advance();
                  path.push(self.expect_identifier()?);
              }
              
              // Optional version: @ 1.0.0
              let version = if self.check(Token::At) {
                  self.advance();
                  Some(self.parse_version_string()?)
              } else {
                  None
              };
              
              Ok(Declaration::Module(ModuleDeclaration {
                  path,
                  version,
                  span: start.merge(&self.previous_span()),
              }))
          }
          
          /// Parse use declaration: use path.{ items } or use path.*
          fn parse_use_declaration(&mut self) -> Result<Declaration, ParseError> {
              let start = self.current_span();
              self.expect(Token::Use)?;
              
              // Parse dotted path
              let mut path = vec![self.expect_identifier()?];
              while self.check(Token::Dot) && !self.check_next(Token::Star) && !self.check_next(Token::LBrace) {
                  self.advance();
                  if self.check(Token::Star) || self.check(Token::LBrace) {
                      break;
                  }
                  path.push(self.expect_identifier()?);
              }
              
              // Check for .* or .{ items }
              let (items, import_all) = if self.check(Token::Dot) {
                  self.advance();
                  if self.check(Token::Star) {
                      self.advance();
                      (vec![], true)
                  } else if self.check(Token::LBrace) {
                      self.advance();
                      let items = self.parse_use_items()?;
                      self.expect(Token::RBrace)?;
                      (items, false)
                  } else {
                      // Single item import
                      let name = self.expect_identifier()?;
                      (vec![UseItem { name, alias: None }], false)
                  }
              } else {
                  (vec![], false)
              };
              
              Ok(Declaration::Use(UseDeclaration {
                  path,
                  items,
                  import_all,
                  span: start.merge(&self.previous_span()),
              }))
          }
          
          fn parse_use_items(&mut self) -> Result<Vec<UseItem>, ParseError> {
              let mut items = Vec::new();
              
              loop {
                  let name = self.expect_identifier()?;
                  let alias = if self.check(Token::As) {
                      self.advance();
                      Some(self.expect_identifier()?)
                  } else {
                      None
                  };
                  items.push(UseItem { name, alias });
                  
                  if !self.check(Token::Comma) {
                      break;
                  }
                  self.advance();
              }
              
              Ok(items)
          }
          
          fn parse_version_string(&mut self) -> Result<String, ParseError> {
              // Handle versions like 1.0.0, 1.0, 3.5Gya
              let mut version = String::new();
              
              // Get first number
              if let Token::Integer(n) = self.current_token() {
                  version.push_str(&n.to_string());
                  self.advance();
              } else if let Token::Float(f) = self.current_token() {
                  version.push_str(&f.to_string());
                  self.advance();
              }
              
              // Get rest of version (e.g., .0.0 or Gya suffix)
              while self.check(Token::Dot) {
                  version.push('.');
                  self.advance();
                  if let Token::Integer(n) = self.current_token() {
                      version.push_str(&n.to_string());
                      self.advance();
                  }
              }
              
              // Check for suffix like "Gya", "alpha"
              if let Token::Identifier(s) = self.current_token() {
                  version.push_str(&s);
                  self.advance();
              }
              
              Ok(version)
          }
      }
      ```
      
      FILE: ~/repos/univrs-dol/src/parser.rs

  fix-lib-parse-file:
    name: Fix parse_file Function
    role: Update parse_file to return multiple declarations
    dependencies:
      - fix-parser-module
    instructions: |
      The parse_file function needs to handle files with multiple declarations.
      
      UPDATE src/lib.rs - Change parse_file to handle DOL 2.0 files:
      
      Option 1: Return Vec<Declaration> for multiple declarations:
      
      ```rust
      /// Parse a DOL source file into declarations
      /// 
      /// DOL 2.0 files can contain multiple declarations:
      /// - module declaration (optional, first)
      /// - use declarations (optional, after module)
      /// - type declarations (gene, trait, system, etc.)
      pub fn parse_file(source: &str) -> Result<Vec<Declaration>, ParseError> {
          let mut parser = Parser::new(source);
          let mut declarations = Vec::new();
          
          while !parser.is_at_end() {
              parser.skip_trivia();
              if parser.is_at_end() {
                  break;
              }
              declarations.push(parser.parse()?);
          }
          
          Ok(declarations)
      }
      
      /// Parse a single declaration (backward compatible)
      pub fn parse_single(source: &str) -> Result<Declaration, ParseError> {
          let mut parser = Parser::new(source);
          parser.parse()
      }
      ```
      
      Option 2: Create a File AST node that contains all declarations:
      
      ```rust
      /// A complete DOL source file
      #[derive(Debug, Clone)]
      pub struct DolFile {
          /// Optional module declaration
          pub module: Option<ModuleDeclaration>,
          /// Use/import declarations
          pub uses: Vec<UseDeclaration>,
          /// Type declarations (genes, traits, etc.)
          pub declarations: Vec<Declaration>,
      }
      
      /// Parse a complete DOL file
      pub fn parse_file(source: &str) -> Result<DolFile, ParseError> {
          let mut parser = Parser::new(source);
          let mut file = DolFile {
              module: None,
              uses: Vec::new(),
              declarations: Vec::new(),
          };
          
          while !parser.is_at_end() {
              parser.skip_trivia();
              if parser.is_at_end() {
                  break;
              }
              
              let decl = parser.parse()?;
              match decl {
                  Declaration::Module(m) => {
                      if file.module.is_some() {
                          return Err(ParseError::DuplicateModule { span: m.span });
                      }
                      file.module = Some(m);
                  }
                  Declaration::Use(u) => {
                      file.uses.push(u);
                  }
                  other => {
                      file.declarations.push(other);
                  }
              }
          }
          
          Ok(file)
      }
      ```
      
      Choose Option 2 as it's cleaner. Also update parse_and_validate:
      
      ```rust
      pub fn parse_and_validate(source: &str) -> Result<(DolFile, ValidationResult), ParseError> {
          let file = parse_file(source)?;
          let result = validator::validate_file(&file, &ValidationOptions::default());
          Ok((file, result))
      }
      ```
      
      FILE: ~/repos/univrs-dol/src/lib.rs

  fix-validator-naming:
    name: Fix Naming Convention Validator
    role: Update validator to accept PascalCase for types
    instructions: |
      The naming validator incorrectly requires lowercase qualified names.
      Genes and Traits should use PascalCase (Vec3, MyceliumNode).
      
      UPDATE src/validator.rs - Replace the validate_naming function:
      
      ```rust
      /// Validates naming conventions based on declaration type.
      /// 
      /// Conventions:
      /// - Genes: PascalCase (Vec3, Container, MyceliumNode)
      /// - Traits: PascalCase (Schedulable, Runnable)
      /// - Systems: PascalCase (Scheduler, Ecosystem)
      /// - Constraints: snake_case (valid_id, non_negative)
      /// - Functions: snake_case (calculate_sum, process_data)
      fn validate_naming(decl: &Declaration, result: &mut ValidationResult) {
          let name = decl.name();
          
          match decl {
              // Types should be PascalCase
              Declaration::Gene(_) | Declaration::Trait(_) | Declaration::System(_) => {
                  if !is_pascal_case(name) {
                      result.add_warning(ValidationWarning::NamingConvention {
                          name: name.to_string(),
                          suggestion: format!("use PascalCase: '{}'", to_pascal_case(name)),
                      });
                  }
              }
              
              // Constraints should be snake_case
              Declaration::Constraint(_) => {
                  if !is_snake_case(name) {
                      result.add_warning(ValidationWarning::NamingConvention {
                          name: name.to_string(),
                          suggestion: format!("use snake_case: '{}'", to_snake_case(name)),
                      });
                  }
              }
              
              // Functions should be snake_case
              Declaration::Function(_) => {
                  if !is_snake_case(name) {
                      result.add_warning(ValidationWarning::NamingConvention {
                          name: name.to_string(),
                          suggestion: format!("use snake_case: '{}'", to_snake_case(name)),
                      });
                  }
              }
              
              // Module and Use declarations don't need naming validation
              Declaration::Module(_) | Declaration::Use(_) => {}
              
              // Evolution names follow the "From > To" pattern
              Declaration::Evolution(_) => {}
              
              // Constants should be SCREAMING_SNAKE_CASE
              Declaration::Const(_) => {
                  if !is_screaming_snake_case(name) {
                      result.add_warning(ValidationWarning::NamingConvention {
                          name: name.to_string(),
                          suggestion: format!("use SCREAMING_SNAKE_CASE: '{}'", to_screaming_snake_case(name)),
                      });
                  }
              }
          }
      }
      
      /// Check if a name is PascalCase (starts with uppercase, no underscores)
      fn is_pascal_case(s: &str) -> bool {
          if s.is_empty() {
              return false;
          }
          let first = s.chars().next().unwrap();
          first.is_uppercase() && !s.contains('_')
      }
      
      /// Check if a name is snake_case (all lowercase with underscores)
      fn is_snake_case(s: &str) -> bool {
          if s.is_empty() {
              return false;
          }
          s.chars().all(|c| c.is_lowercase() || c.is_numeric() || c == '_')
      }
      
      /// Check if a name is SCREAMING_SNAKE_CASE
      fn is_screaming_snake_case(s: &str) -> bool {
          if s.is_empty() {
              return false;
          }
          s.chars().all(|c| c.is_uppercase() || c.is_numeric() || c == '_')
      }
      
      /// Convert to PascalCase
      fn to_pascal_case(s: &str) -> String {
          s.split('_')
              .map(|word| {
                  let mut chars = word.chars();
                  match chars.next() {
                      None => String::new(),
                      Some(first) => first.to_uppercase().chain(chars).collect(),
                  }
              })
              .collect()
      }
      
      /// Convert to snake_case
      fn to_snake_case(s: &str) -> String {
          let mut result = String::new();
          for (i, c) in s.chars().enumerate() {
              if c.is_uppercase() && i > 0 {
                  result.push('_');
              }
              result.push(c.to_lowercase().next().unwrap());
          }
          result
      }
      
      /// Convert to SCREAMING_SNAKE_CASE
      fn to_screaming_snake_case(s: &str) -> String {
          to_snake_case(s).to_uppercase()
      }
      ```
      
      Also remove the old is_valid_qualified_identifier check since we no longer
      require qualified names:
      
      ```rust
      // REMOVE this check or make it optional:
      // if !is_valid_qualified_identifier(name) { ... }
      ```
      
      FILE: ~/repos/univrs-dol/src/validator.rs

  fix-validator-file:
    name: Fix Validator for File Type
    role: Update validator to work with DolFile
    dependencies:
      - fix-lib-parse-file
      - fix-validator-naming
    instructions: |
      Update the validator to work with the new DolFile type.
      
      UPDATE src/validator.rs:
      
      ```rust
      use crate::{DolFile, Declaration};
      
      /// Validate a complete DOL file
      pub fn validate_file(file: &DolFile, options: &ValidationOptions) -> ValidationResult {
          let mut result = ValidationResult::new();
          
          // Validate module declaration if present
          if let Some(ref module) = file.module {
              validate_module(module, &mut result);
          }
          
          // Validate use declarations
          for use_decl in &file.uses {
              validate_use(use_decl, &mut result);
          }
          
          // Validate each declaration
          for decl in &file.declarations {
              validate_declaration(decl, options, &mut result);
          }
          
          result
      }
      
      fn validate_module(module: &ModuleDeclaration, result: &mut ValidationResult) {
          // Module path should be lowercase with dots
          for part in &module.path {
              if !part.chars().all(|c| c.is_lowercase() || c.is_numeric() || c == '_') {
                  result.add_warning(ValidationWarning::NamingConvention {
                      name: part.clone(),
                      suggestion: format!("module path segments should be lowercase: '{}'", part.to_lowercase()),
                  });
              }
          }
      }
      
      fn validate_use(use_decl: &UseDeclaration, result: &mut ValidationResult) {
          // Use declarations are generally fine, just check path is valid
          if use_decl.path.is_empty() {
              result.add_error(ValidationError::InvalidIdentifier {
                  name: "".to_string(),
                  reason: "use declaration must have a path".to_string(),
              });
          }
      }
      
      /// Validate a single declaration (for backward compatibility)
      pub fn validate_declaration(decl: &Declaration, options: &ValidationOptions, result: &mut ValidationResult) {
          // Skip Module and Use - they're validated separately
          match decl {
              Declaration::Module(_) | Declaration::Use(_) => return,
              _ => {}
          }
          
          // Existing validation logic
          validate_naming(decl, result);
          
          if options.require_exegesis {
              validate_exegesis(decl, options, result);
          }
          
          validate_statements(decl, result);
      }
      ```
      
      FILE: ~/repos/univrs-dol/src/validator.rs

  fix-binary:
    name: Fix dol-check Binary
    role: Update binary to use new parse_file
    dependencies:
      - fix-validator-file
    instructions: |
      Update the dol-check binary to work with the new DolFile type.
      
      UPDATE src/bin/dol-check.rs:
      
      Find where it calls parse_file and update:
      
      ```rust
      use metadol::{parse_file, DolFile, Declaration};
      use metadol::validator::{validate_file, ValidationOptions};
      
      fn check_file(path: &Path, args: &Args) -> CheckResult {
          let source = std::fs::read_to_string(path)?;
          
          // Parse the file
          let file = match parse_file(&source) {
              Ok(f) => f,
              Err(e) => {
                  return CheckResult {
                      path: path.to_path_buf(),
                      passed: false,
                      errors: vec![format!("{}", e)],
                      warnings: vec![],
                  };
              }
          };
          
          // Validate
          let options = ValidationOptions {
              require_exegesis: args.require_exegesis,
              min_exegesis_length: args.min_exegesis_length,
              ..Default::default()
          };
          
          let result = validate_file(&file, &options);
          
          CheckResult {
              path: path.to_path_buf(),
              passed: result.errors.is_empty(),
              errors: result.errors.iter().map(|e| format!("{}", e)).collect(),
              warnings: result.warnings.iter().map(|w| format!("{}", w)).collect(),
          }
      }
      ```
      
      FILE: ~/repos/univrs-dol/src/bin/dol-check.rs

  fix-error:
    name: Fix Error Message
    role: Update error message to include new declaration types
    instructions: |
      UPDATE src/error.rs - Find and update the InvalidDeclarationType error:
      
      ```rust
      /// An invalid declaration type was encountered.
      #[error("invalid declaration type '{found}' at line {}, column {} (expected module, use, pub, fun, gene, trait, constraint, system, or evolves)", span.line, span.column)]
      InvalidDeclarationType {
          found: String,
          span: Span,
      },
      ```
      
      FILE: ~/repos/univrs-dol/src/error.rs

  run-tests:
    name: Run Tests
    role: Verify all fixes work
    dependencies:
      - fix-binary
      - fix-error
    instructions: |
      Run all tests and verify the biology module parses:
      
      ```bash
      cd ~/repos/univrs-dol
      
      # Format code
      cargo fmt --all
      
      # Run clippy
      cargo clippy --all-features -- -D warnings
      
      # Run all tests
      cargo test --all-features
      
      # Test the binary specifically
      cargo run --bin dol-check --features cli -- examples/stdlib/biology/
      
      # Verify no naming warnings for PascalCase genes
      cargo run --bin dol-check --features cli -- examples/stdlib/biology/ 2>&1 | grep -i "naming"
      ```
      
      Expected output: No errors, no naming warnings for PascalCase types.
      
      If tests pass:
      ```bash
      git add -A
      git commit -m "fix: update parser and validator for DOL 2.0
      
      - Add Module and Use declaration types to AST
      - Update parser to recognize module/use/pub/fun as valid declarations
      - Change parse_file to return DolFile with multiple declarations
      - Fix naming validator to expect PascalCase for genes/traits
      - Update dol-check binary for new API
      - Update error messages to include new declaration types
      
      Fixes biology module parsing and removes spurious naming warnings."
      
      git push
      ```

# ═══════════════════════════════════════════════════════════════════════
# WORKFLOWS
# ═══════════════════════════════════════════════════════════════════════════════

workflows:
  fix-all:
    name: Fix All Issues
    description: Fix parser, validator, and binary for DOL
    stages:
      - name: ast
        description: Update AST types
        agents:
          - fix-ast-module
          
      - name: parser
        description: Update parser
        agents:
          - fix-parser-module
        depends_on:
          - ast
          
      - name: lib
        description: Update lib.rs
        agents:
          - fix-lib-parse-file
        depends_on:
          - parser
          
      - name: validator
        description: Fix validator
        agents:
          - fix-validator-naming
          - fix-validator-file
        depends_on:
          - lib
          
      - name: binary
        description: Fix binary and errors
        agents:
          - fix-binary
          - fix-error
        depends_on:
          - validator
          
      - name: verify
        description: Run tests
        agents:
          - run-tests
        depends_on:
          - binary

  validator-only:
    name: Fix Validator Only
    stages:
      - name: validator
        agents:
          - fix-validator-naming

  parser-only:
    name: Fix Parser Only
    stages:
      - name: ast
        agents:
          - fix-ast-module
      - name: parser
        agents:
          - fix-parser-module
        depends_on:
          - ast

# ═══════════════════════════════════════════════════════════════════════════════
# CHECKPOINTS
# ════â═══════════════════════════════════════════════════════════════════

checkpoints:
  ast-updated:
    trigger: command_success
    command: "grep -q 'Declaration::Module' src/ast.rs"
    message: "AST updated with Module declaration"

  parser-updated:
    trigger: command_success
    command: "grep -q 'Token::Module =>' src/parser.rs"
    message: "Parser handles module dens"

  validator-fixed:
    trigger: command_success
    command: "grep -q 'is_pascal_case' src/validator.rs"
    message: "Validator accepts PascalCase"

  biology-passes:
    trigger: command_success
    command: "cargo run --bin dol-check --features cli -- examples/stdlib/biology/ 2>&1 | grep -q 'Passed:   7'"
    message: "All biology files pass validation!"

  all-tests-pass:
    trigger: command_success
    command: "cargo test --all-features"
    message: |
      ════════════â═════════════════════════════════════════
      ALL FIXES COMPLETE
      
      ✓ AST supports Module and Use declarations
      ✓ Parser recognizes DOL 2.0 declaration types
      ✓ parse_file returns DolFile with multiple declarations
      ✓ Validator accepts PascalCase for genes/traits
      ✓ dol-check binary works with DOL 2.0 files
      ✓ Biology module validates without errors
      ══════â══════════════════════════════════════════
