module tests.nested_sex @ 1.0.0

// Global mutable state
sex var COUNTER: i64 = 0
sex var LOG: Vec<string> = []
sex var CACHE: Map<string, i64> = Map.new()

// Simple sex function
sex fun increment() -> i64 {
    COUNTER += 1
    return COUNTER
}

// Sex function with sex block
sex fun logged_increment(label: string) -> i64 {
    sex {
        LOG.push(label + ": incrementing")
    }

    result = COUNTER + 1
    COUNTER = result

    sex {
        LOG.push(label + ": now " + result.to_string())
    }

    return result
}

// Pure function with sex block
fun compute_with_logging(x: i64) -> i64 {
    result = x * 2 + 1

    sex {
        LOG.push("computed: " + result.to_string())
    }

    return result
}

// Nested sex blocks (should work but warn)
sex fun deeply_nested() -> i64 {
    sex {
        COUNTER += 1
        sex {
            LOG.push("nested sex block")
        }
    }
    return COUNTER
}

// Sex with control flow
sex fun conditional_effects(cond: bool) -> i64 {
    if cond {
        sex {
            COUNTER += 10
        }
    } else {
        sex {
            COUNTER -= 10
        }
    }
    return COUNTER
}

// Sex with loops
sex fun loop_effects(n: i64) -> i64 {
    for i in 0..n {
        sex {
            COUNTER += 1
            LOG.push("iteration " + i.to_string())
        }
    }
    return COUNTER
}

// Extern declarations
sex extern "C" fun printf(fmt: Ptr<i8>, ...) -> i32
sex extern "C" fun malloc(size: u64) -> Ptr<()>
sex extern "C" fun free(ptr: Ptr<()>)

docs {
    Tests for various sex block patterns and nesting.
}
