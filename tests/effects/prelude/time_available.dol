// Effect System Prelude Test: Time Functions Available
// =====================================================
//
// What this test validates:
//   - All standard time prelude functions are available
//   - Time functions are correctly typed and callable
//   - Time effect is properly attributed (most time functions are effectful)
//   - Both query and manipulation operations are covered
//
// Expected effect inference results:
//   - Time queries: Effectful(Time) - reading system time is an effect
//   - Pure duration arithmetic: Pure
//   - Sleep/timers: Effectful(Time)

gene Prelude.Time.Test @0.1.0 {
    """
    Tests availability and effect inference of time prelude functions.
    """

    // Test: @time.now - get current timestamp
    fn test_now() -> Timestamp {
        @time.now()
    }

    // Test: @time.now_millis - get milliseconds since epoch
    fn test_now_millis() -> Int {
        @time.now_millis()
    }

    // Test: @time.now_micros - get microseconds since epoch
    fn test_now_micros() -> Int {
        @time.now_micros()
    }

    // Test: @time.now_nanos - get nanoseconds since epoch
    fn test_now_nanos() -> Int {
        @time.now_nanos()
    }

    // Test: @time.monotonic - monotonic clock (for measuring durations)
    fn test_monotonic() -> Int {
        @time.monotonic()
    }

    // Test: @time.sleep - pause execution
    fn test_sleep(duration_ms: Int) -> Unit {
        @time.sleep(duration_ms)
    }

    // Test: @time.sleep_until - sleep until timestamp
    fn test_sleep_until(timestamp: Timestamp) -> Unit {
        @time.sleep_until(timestamp)
    }

    // Test: @time.after - create timer
    fn test_after(duration_ms: Int) -> TimerRef {
        @time.after(duration_ms)
    }

    // Test: @time.cancel_timer - cancel timer
    fn test_cancel_timer(timer: TimerRef) -> Unit {
        @time.cancel_timer(timer)
    }

    // Test: @time.interval - create repeating timer
    fn test_interval(duration_ms: Int) -> IntervalRef {
        @time.interval(duration_ms)
    }

    // Test: @time.cancel_interval - cancel interval
    fn test_cancel_interval(interval: IntervalRef) -> Unit {
        @time.cancel_interval(interval)
    }

    // Test: @time.elapsed - time elapsed since
    fn test_elapsed(start: Timestamp) -> Duration {
        @time.elapsed(start)
    }

    // Duration creation - these could be pure
    fn test_duration_from_millis(ms: Int) -> Duration {
        @time.duration_millis(ms)
    }

    fn test_duration_from_secs(secs: Int) -> Duration {
        @time.duration_secs(secs)
    }

    fn test_duration_from_mins(mins: Int) -> Duration {
        @time.duration_mins(mins)
    }

    fn test_duration_from_hours(hours: Int) -> Duration {
        @time.duration_hours(hours)
    }

    // Duration arithmetic - could be pure
    fn test_duration_add(a: Duration, b: Duration) -> Duration {
        @time.duration_add(a, b)
    }

    fn test_duration_sub(a: Duration, b: Duration) -> Duration {
        @time.duration_sub(a, b)
    }

    fn test_duration_mul(d: Duration, factor: Int) -> Duration {
        @time.duration_mul(d, factor)
    }

    fn test_duration_div(d: Duration, divisor: Int) -> Duration {
        @time.duration_div(d, divisor)
    }

    // Timestamp arithmetic
    fn test_timestamp_add(t: Timestamp, d: Duration) -> Timestamp {
        @time.timestamp_add(t, d)
    }

    fn test_timestamp_sub(t: Timestamp, d: Duration) -> Timestamp {
        @time.timestamp_sub(t, d)
    }

    fn test_timestamp_diff(a: Timestamp, b: Timestamp) -> Duration {
        @time.timestamp_diff(a, b)
    }

    // Formatting
    fn test_format(timestamp: Timestamp, format: String) -> String {
        @time.format(timestamp, format)
    }

    fn test_format_duration(duration: Duration) -> String {
        @time.format_duration(duration)
    }

    // Parsing
    fn test_parse(s: String, format: String) -> Option[Timestamp] {
        @time.parse(s, format)
    }

    // Combined usage test - measure execution time
    fn test_measure_time() -> Duration {
        let start = @time.monotonic();
        // ... do some work ...
        @time.sleep(100);
        let end = @time.monotonic();
        @time.duration_millis(end - start)
    }

    // Combined usage test - timeout pattern
    fn test_with_timeout(timeout_ms: Int) -> Option[Any] {
        let deadline = @time.timestamp_add(@time.now(), @time.duration_millis(timeout_ms));
        loop {
            if @time.now() > deadline {
                return None
            }
            let result = @msg.try_recv();
            if result.is_some() {
                return result
            }
            @time.sleep(10)
        }
    }

    // Date/time component extraction
    fn test_year(t: Timestamp) -> Int {
        @time.year(t)
    }

    fn test_month(t: Timestamp) -> Int {
        @time.month(t)
    }

    fn test_day(t: Timestamp) -> Int {
        @time.day(t)
    }

    fn test_hour(t: Timestamp) -> Int {
        @time.hour(t)
    }

    fn test_minute(t: Timestamp) -> Int {
        @time.minute(t)
    }

    fn test_second(t: Timestamp) -> Int {
        @time.second(t)
    }

    fn test_weekday(t: Timestamp) -> Int {
        @time.weekday(t)
    }
}

// Test assertions for prelude availability and effects
test prelude_time {
    // Time queries - Effectful(Time) - reading system time
    assert_effectful(Prelude.Time.Test.test_now, Time);
    assert_effectful(Prelude.Time.Test.test_now_millis, Time);
    assert_effectful(Prelude.Time.Test.test_now_micros, Time);
    assert_effectful(Prelude.Time.Test.test_now_nanos, Time);
    assert_effectful(Prelude.Time.Test.test_monotonic, Time);

    // Sleep/timers - Effectful(Time)
    assert_effectful(Prelude.Time.Test.test_sleep, Time);
    assert_effectful(Prelude.Time.Test.test_sleep_until, Time);
    assert_effectful(Prelude.Time.Test.test_after, Time);
    assert_effectful(Prelude.Time.Test.test_cancel_timer, Time);
    assert_effectful(Prelude.Time.Test.test_interval, Time);
    assert_effectful(Prelude.Time.Test.test_cancel_interval, Time);
    assert_effectful(Prelude.Time.Test.test_elapsed, Time);

    // Duration creation - Pure (just constructing values)
    assert_pure(Prelude.Time.Test.test_duration_from_millis);
    assert_pure(Prelude.Time.Test.test_duration_from_secs);
    assert_pure(Prelude.Time.Test.test_duration_from_mins);
    assert_pure(Prelude.Time.Test.test_duration_from_hours);

    // Duration arithmetic - Pure
    assert_pure(Prelude.Time.Test.test_duration_add);
    assert_pure(Prelude.Time.Test.test_duration_sub);
    assert_pure(Prelude.Time.Test.test_duration_mul);
    assert_pure(Prelude.Time.Test.test_duration_div);

    // Timestamp arithmetic - Pure (just math on values)
    assert_pure(Prelude.Time.Test.test_timestamp_add);
    assert_pure(Prelude.Time.Test.test_timestamp_sub);
    assert_pure(Prelude.Time.Test.test_timestamp_diff);

    // Formatting/parsing - Pure
    assert_pure(Prelude.Time.Test.test_format);
    assert_pure(Prelude.Time.Test.test_format_duration);
    assert_pure(Prelude.Time.Test.test_parse);

    // Combined patterns - Effectful
    assert_effectful(Prelude.Time.Test.test_measure_time, Time);
    assert_effectful(Prelude.Time.Test.test_with_timeout, [Time, Msg]);

    // Date extraction - Pure (extracting from timestamp value)
    assert_pure(Prelude.Time.Test.test_year);
    assert_pure(Prelude.Time.Test.test_month);
    assert_pure(Prelude.Time.Test.test_day);
    assert_pure(Prelude.Time.Test.test_hour);
    assert_pure(Prelude.Time.Test.test_minute);
    assert_pure(Prelude.Time.Test.test_second);
    assert_pure(Prelude.Time.Test.test_weekday);

    // Type signatures
    assert_signature(@time.now, Fn() -> Timestamp);
    assert_signature(@time.sleep, Fn(Int) -> Unit);
    assert_signature(@time.after, Fn(Int) -> TimerRef);
    assert_signature(@time.duration_millis, Fn(Int) -> Duration);
}
