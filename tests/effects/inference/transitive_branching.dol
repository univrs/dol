// Effect System Test: Transitive Branching
// =========================================
//
// What this test validates:
//   - Effect propagation through branching call graphs
//   - If ANY branch is effectful, the caller becomes effectful
//   - Both branches pure -> caller pure
//   - One branch effectful -> caller effectful
//   - Multiple effect types from different branches -> combined effects
//
// Expected effect inference results:
//   - both_pure(cond) -> Pure
//   - one_effectful(cond) -> Effectful(IO)
//   - different_effects(cond) -> Effectful(IO, Msg)

gene Branch.Simple @0.1.0 {
    """
    Simple branching where both branches have same effect status.
    """

    // Pure helpers
    fn pure_a(x: Int) -> Int {
        x + 1
    }

    fn pure_b(x: Int) -> Int {
        x * 2
    }

    // Effectful helper
    fn effectful_a(x: Int) -> Int {
        @io.println("effectful_a: " + @fmt.int(x));
        x + 1
    }

    // Pure: both branches are pure
    fn both_pure(cond: Bool, x: Int) -> Int {
        if cond {
            pure_a(x)
        } else {
            pure_b(x)
        }
    }

    // Effectful: one branch is effectful -> whole function effectful
    fn one_effectful(cond: Bool, x: Int) -> Int {
        if cond {
            pure_a(x)        // Pure branch
        } else {
            effectful_a(x)   // Effectful branch
        }
    }

    // Effectful: both branches effectful
    fn both_effectful(cond: Bool, x: Int) -> Int {
        if cond {
            effectful_a(x)
        } else {
            effectful_a(x * 2)
        }
    }
}

gene Branch.MultiEffect @0.1.0 {
    """
    Branching with different effect types in different branches.
    The caller accumulates all possible effects.
    """

    // IO effectful
    fn io_effect(x: Int) -> Int {
        @io.println("IO effect");
        x
    }

    // Msg effectful
    fn msg_effect(x: Int) -> Int {
        @msg.send(@msg.self(), x);
        x
    }

    // Mut effectful
    mut counter: Int = 0
    fn mut_effect(x: Int) -> Int {
        self.counter = x;
        x
    }

    // Effectful(IO, Msg): different effects in branches
    fn different_effects(cond: Bool, x: Int) -> Int {
        if cond {
            io_effect(x)
        } else {
            msg_effect(x)
        }
    }

    // Effectful(IO, Msg, Mut): three-way branch with different effects
    fn three_way_effects(choice: Int, x: Int) -> Int {
        if choice == 0 {
            io_effect(x)
        } else if choice == 1 {
            msg_effect(x)
        } else {
            mut_effect(x)
        }
    }
}

gene Branch.Nested @0.1.0 {
    """
    Nested branching structures with effect propagation.
    """

    fn pure_leaf(x: Int) -> Int {
        x
    }

    fn effectful_leaf(x: Int) -> Int {
        @io.println("leaf");
        x
    }

    // Pure: all paths lead to pure functions
    fn nested_all_pure(a: Bool, b: Bool, x: Int) -> Int {
        if a {
            if b {
                pure_leaf(x)
            } else {
                pure_leaf(x + 1)
            }
        } else {
            pure_leaf(x * 2)
        }
    }

    // Effectful: one deep path is effectful
    fn nested_one_effectful(a: Bool, b: Bool, x: Int) -> Int {
        if a {
            if b {
                pure_leaf(x)
            } else {
                effectful_leaf(x)  // Only this path is effectful
            }
        } else {
            pure_leaf(x * 2)
        }
    }

    // Effectful: effect in outer branch
    fn nested_outer_effectful(a: Bool, b: Bool, x: Int) -> Int {
        if a {
            if b {
                pure_leaf(x)
            } else {
                pure_leaf(x + 1)
            }
        } else {
            effectful_leaf(x)
        }
    }
}

gene Branch.Match @0.1.0 {
    """
    Pattern matching with effect propagation.
    """

    fn pure_case(x: Int) -> String {
        "pure"
    }

    fn effectful_case(x: Int) -> String {
        @io.println("effectful case");
        "effectful"
    }

    // Pure: all match arms are pure
    fn match_all_pure(opt: Option[Int]) -> String {
        match opt {
            Some(x) => pure_case(x),
            None => "none"
        }
    }

    // Effectful: one match arm is effectful
    fn match_one_effectful(opt: Option[Int]) -> String {
        match opt {
            Some(x) => effectful_case(x),
            None => "none"
        }
    }

    // Effectful: effect in default arm
    fn match_default_effectful(value: Int) -> String {
        match value {
            0 => "zero",
            1 => "one",
            _ => effectful_case(value)
        }
    }
}

// Test assertions for effect inference
test effects {
    // Simple branching
    assert_pure(Branch.Simple.pure_a);
    assert_pure(Branch.Simple.pure_b);
    assert_effectful(Branch.Simple.effectful_a, IO);
    assert_pure(Branch.Simple.both_pure);
    assert_effectful(Branch.Simple.one_effectful, IO);
    assert_effectful(Branch.Simple.both_effectful, IO);

    // Multi-effect branching
    assert_effectful(Branch.MultiEffect.io_effect, IO);
    assert_effectful(Branch.MultiEffect.msg_effect, Msg);
    assert_effectful(Branch.MultiEffect.mut_effect, Mut);
    assert_effectful(Branch.MultiEffect.different_effects, [IO, Msg]);
    assert_effectful(Branch.MultiEffect.three_way_effects, [IO, Msg, Mut]);

    // Nested branching
    assert_pure(Branch.Nested.nested_all_pure);
    assert_effectful(Branch.Nested.nested_one_effectful, IO);
    assert_effectful(Branch.Nested.nested_outer_effectful, IO);

    // Match branching
    assert_pure(Branch.Match.match_all_pure);
    assert_effectful(Branch.Match.match_one_effectful, IO);
    assert_effectful(Branch.Match.match_default_effectful, IO);
}
