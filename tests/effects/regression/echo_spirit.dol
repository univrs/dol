// Effect System Regression Test: Echo Spirit
// ===========================================
//
// What this test validates:
//   - Echo pattern correctly handles message effects
//   - Stateless spirits still have Msg effects from receiving
//   - Response patterns show correct effect composition
//   - No false purity for message-handling code
//
// Regression context:
//   - Bug #156: Stateless handlers marked pure despite @msg usage
//   - Bug #162: Echo response not showing Msg effect
//   - This test ensures message-based operations are always effectful
//
// Expected effect inference results:
//   - All message handlers: Effectful(Msg)
//   - Transform helpers: Pure (unless they log)
//   - Echo operations: Effectful(Msg)

spirit Echo @0.1.0 {
    """
    A simple echo spirit that responds to messages.
    Stateless but still effectful due to messaging.
    """

    // No mutable state - but still effectful!

    // REGRESSION CHECK: Even without state, recv/send = Effectful(Msg)
    // Bug #156 incorrectly marked stateless handlers as pure

    // Basic echo - receive and send back
    fn echo() -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        @msg.send(sender, msg)
    }

    // Echo with transformation
    fn echo_upper() -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        let response = @string.upper(msg);
        @msg.send(sender, response)
    }

    // Echo with prefix
    fn echo_prefix(prefix: String) -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        @msg.send(sender, prefix + msg)
    }

    // Echo with delay
    fn echo_delayed(delay_ms: Int) -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        @time.sleep(delay_ms);
        @msg.send(sender, msg)
    }

    // Echo N times
    fn echo_repeat(n: Int) -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        let mut i = 0;
        while i < n {
            @msg.send(sender, msg);
            i = i + 1
        }
    }

    // Echo to multiple targets
    fn echo_broadcast() -> Unit {
        let msg = @msg.recv();
        @msg.broadcast(msg)
    }

    // Conditional echo
    fn echo_if_valid() -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        if is_valid_message(msg) {
            @msg.send(sender, msg)
        } else {
            @msg.send(sender, { error: "invalid message" })
        }
    }

    // Pure validation helper - no effects
    fn is_valid_message(msg: Any) -> Bool {
        msg != null && msg.type != null
    }

    // Pure transformation helper - no effects
    fn transform_message(msg: Any) -> Any {
        {
            original: msg,
            transformed: true,
            timestamp_placeholder: 0
        }
    }

    // Echo with transformation (combines pure helper + msg)
    fn echo_transformed() -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        let transformed = transform_message(msg);
        @msg.send(sender, transformed)
    }

    // Request-response pattern
    fn request_response() -> Unit {
        loop {
            let request = @msg.recv();
            let sender = @msg.current_sender();

            let response = match request.type {
                "echo" => request.payload,
                "upper" => @string.upper(request.payload),
                "lower" => @string.lower(request.payload),
                "reverse" => @string.reverse(request.payload),
                _ => { error: "unknown type" }
            };

            @msg.send(sender, { id: request.id, response: response })
        }
    }

    // Main loop
    fn run() -> Never {
        @io.println("Echo spirit starting");
        loop {
            echo()
        }
    }

    // Logged echo (IO + Msg)
    fn echo_logged() -> Unit {
        let msg = @msg.recv();
        let sender = @msg.current_sender();
        @io.println("Echoing: " + @fmt.debug(msg));
        @msg.send(sender, msg)
    }

    // Selective echo
    fn echo_selective(msg_type: String) -> Unit {
        loop {
            let msg = @msg.recv();
            if msg.type == msg_type {
                let sender = @msg.current_sender();
                @msg.send(sender, msg);
                return
            }
            @msg.requeue(msg)
        }
    }
}

// Separate gene with only pure functions for comparison
gene EchoHelpers @0.1.0 {
    """
    Pure helper functions for echo operations.
    These should all be Pure since they don't use @msg.
    """

    fn uppercase(s: String) -> String {
        @string.upper(s)
    }

    fn lowercase(s: String) -> String {
        @string.lower(s)
    }

    fn reverse(s: String) -> String {
        @string.reverse(s)
    }

    fn wrap(s: String, prefix: String, suffix: String) -> String {
        prefix + s + suffix
    }

    fn validate(msg: Any) -> Bool {
        msg != null
    }

    fn format_response(id: Int, data: Any) -> Any {
        { request_id: id, response: data, success: true }
    }
}

// Regression test assertions
test regression_echo {
    // CRITICAL: All @msg operations must be Effectful(Msg)
    // Bug #156 marked these as pure

    // Basic echo operations - all Effectful(Msg)
    assert_effectful(Echo.echo, Msg);
    assert_effectful(Echo.echo_upper, Msg);
    assert_effectful(Echo.echo_prefix, Msg);
    assert_effectful(Echo.echo_repeat, Msg);
    assert_effectful(Echo.echo_broadcast, Msg);
    assert_effectful(Echo.echo_if_valid, Msg);
    assert_effectful(Echo.echo_transformed, Msg);
    assert_effectful(Echo.request_response, Msg);
    assert_effectful(Echo.echo_selective, Msg);

    // Combined effects
    assert_effectful(Echo.echo_delayed, [Msg, Time]);
    assert_effectful(Echo.echo_logged, [Msg, IO]);
    assert_effectful(Echo.run, [Msg, IO]);

    // Pure helpers within spirit
    assert_pure(Echo.is_valid_message);
    assert_pure(Echo.transform_message);

    // All EchoHelpers are pure (no @msg usage)
    assert_pure(EchoHelpers.uppercase);
    assert_pure(EchoHelpers.lowercase);
    assert_pure(EchoHelpers.reverse);
    assert_pure(EchoHelpers.wrap);
    assert_pure(EchoHelpers.validate);
    assert_pure(EchoHelpers.format_response);
}
