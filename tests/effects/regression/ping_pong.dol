// Effect System Regression Test: Ping/Pong Pattern
// =================================================
//
// What this test validates:
//   - Bidirectional messaging pattern effects
//   - Actor coordination with correct effect inference
//   - Recursive message passing shows consistent effects
//   - No effect loss in complex actor interactions
//
// Regression context:
//   - Bug #171: Mutual recursion between actors lost effects
//   - Bug #184: Ping.start showed incorrect effect when spawning
//   - This test validates complex multi-actor effect scenarios
//
// Expected effect inference results:
//   - All Ping operations: Effectful(Msg) minimum
//   - All Pong operations: Effectful(Msg) minimum
//   - Coordination functions: Effectful(Msg)

spirit Ping @0.1.0 {
    """
    The Ping side of a Ping/Pong exchange.
    Initiates the exchange and counts rounds.
    """

    mut count: Int = 0
    mut pong_actor: Option[ActorId] = None
    mut max_rounds: Int = 10

    // Initialize with Pong reference
    fn init_with_pong(pong: ActorId, rounds: Int) -> Unit {
        self.pong_actor = Some(pong);
        self.max_rounds = rounds;
        self.count = 0
    }

    // Start the ping-pong exchange
    // REGRESSION CHECK: spawn + send = Effectful(Msg)
    fn start() -> Unit {
        match self.pong_actor {
            Some(pong) => {
                @io.println("Ping: Starting exchange");
                @msg.send(pong, { type: "ping", count: 0 })
            },
            None => {
                @io.println("Ping: Error - no Pong actor set")
            }
        }
    }

    // Handle incoming pong message
    fn handle_pong(msg: Any) -> Unit {
        let new_count = msg.count + 1;
        self.count = new_count;
        @io.println("Ping: Received pong #" + @fmt.int(msg.count));

        if new_count < self.max_rounds {
            match self.pong_actor {
                Some(pong) => {
                    @time.sleep(100);  // Small delay
                    @msg.send(pong, { type: "ping", count: new_count })
                },
                None => ()
            }
        } else {
            @io.println("Ping: Exchange complete after " + @fmt.int(new_count) + " rounds")
        }
    }

    // Main loop
    fn run() -> Never {
        loop {
            let msg = @msg.recv();
            match msg.type {
                "pong" => handle_pong(msg),
                "start" => start(),
                "set_pong" => {
                    self.pong_actor = Some(msg.pong_id);
                    self.max_rounds = msg.rounds
                },
                _ => @io.println("Ping: Unknown message type")
            }
        }
    }

    // Get current count (for testing)
    fn get_count() -> Int {
        self.count
    }
}

spirit Pong @0.1.0 {
    """
    The Pong side of a Ping/Pong exchange.
    Responds to pings with pongs.
    """

    mut count: Int = 0
    mut ping_actor: Option[ActorId] = None

    // Initialize with Ping reference
    fn init_with_ping(ping: ActorId) -> Unit {
        self.ping_actor = Some(ping)
    }

    // Handle incoming ping message
    fn handle_ping(msg: Any) -> Unit {
        self.count = msg.count;
        @io.println("Pong: Received ping #" + @fmt.int(msg.count));

        let sender = @msg.current_sender();
        @time.sleep(100);  // Small delay
        @msg.send(sender, { type: "pong", count: msg.count })
    }

    // Main loop
    fn run() -> Never {
        loop {
            let msg = @msg.recv();
            match msg.type {
                "ping" => handle_ping(msg),
                "set_ping" => {
                    self.ping_actor = Some(msg.ping_id)
                },
                _ => @io.println("Pong: Unknown message type")
            }
        }
    }

    // Get current count (for testing)
    fn get_count() -> Int {
        self.count
    }
}

// Coordinator that sets up and manages the exchange
gene PingPongCoordinator @0.1.0 {
    """
    Coordinates the Ping/Pong exchange setup.
    """

    // Start a ping-pong exchange with N rounds
    // REGRESSION CHECK: Spawning and linking must show Msg effect
    fn start_exchange(rounds: Int) -> (ActorId, ActorId) {
        @io.println("Coordinator: Starting ping-pong exchange");

        // Spawn both actors
        let ping = @msg.spawn(Ping);
        let pong = @msg.spawn(Pong);

        // Link them together
        @msg.send(ping, { type: "set_pong", pong_id: pong, rounds: rounds });
        @msg.send(pong, { type: "set_ping", ping_id: ping });

        // Start the exchange
        @time.sleep(100);  // Let actors initialize
        @msg.send(ping, { type: "start" });

        (ping, pong)
    }

    // Monitor an exchange until completion
    fn monitor_exchange(ping: ActorId, pong: ActorId, timeout_ms: Int) -> Bool {
        let start = @time.now();
        let deadline = @time.timestamp_add(start, @time.duration_millis(timeout_ms));

        loop {
            if @time.now() > deadline {
                @io.println("Coordinator: Timeout waiting for exchange");
                return false
            }

            // Check if exchange is done (could query actors)
            @time.sleep(500);

            // For simplicity, just wait for timeout or completion signal
            let msg = @msg.try_recv();
            match msg {
                Some({ type: "exchange_complete" }) => {
                    @io.println("Coordinator: Exchange completed successfully");
                    return true
                },
                _ => ()
            }
        }
    }

    // Clean shutdown
    fn shutdown_exchange(ping: ActorId, pong: ActorId) -> Unit {
        @io.println("Coordinator: Shutting down exchange");
        @msg.send(ping, { type: "shutdown" });
        @msg.send(pong, { type: "shutdown" })
    }

    // Full orchestration
    fn run_exchange(rounds: Int, timeout_ms: Int) -> Bool {
        let (ping, pong) = start_exchange(rounds);
        let success = monitor_exchange(ping, pong, timeout_ms);
        shutdown_exchange(ping, pong);
        success
    }
}

// Pure helper functions (for comparison)
gene PingPongHelpers @0.1.0 {
    """
    Pure helper functions for ping-pong.
    """

    fn make_ping_message(count: Int) -> Any {
        { type: "ping", count: count }
    }

    fn make_pong_message(count: Int) -> Any {
        { type: "pong", count: count }
    }

    fn is_ping(msg: Any) -> Bool {
        msg.type == "ping"
    }

    fn is_pong(msg: Any) -> Bool {
        msg.type == "pong"
    }

    fn extract_count(msg: Any) -> Int {
        msg.count
    }

    fn should_continue(count: Int, max: Int) -> Bool {
        count < max
    }
}

// Regression test assertions
test regression_ping_pong {
    // Ping spirit - all operations involving state or messaging
    assert_effectful(Ping.init_with_pong, Mut);
    assert_effectful(Ping.start, [IO, Msg, Mut]);
    assert_effectful(Ping.handle_pong, [IO, Msg, Time, Mut]);
    assert_effectful(Ping.run, [IO, Msg, Time, Mut]);
    assert_effectful(Ping.get_count, Mut);

    // Pong spirit - all operations involving state or messaging
    assert_effectful(Pong.init_with_ping, Mut);
    assert_effectful(Pong.handle_ping, [IO, Msg, Time, Mut]);
    assert_effectful(Pong.run, [IO, Msg, Mut]);
    assert_effectful(Pong.get_count, Mut);

    // Coordinator - spawn/send/time operations
    assert_effectful(PingPongCoordinator.start_exchange, [IO, Msg, Time]);
    assert_effectful(PingPongCoordinator.monitor_exchange, [IO, Msg, Time]);
    assert_effectful(PingPongCoordinator.shutdown_exchange, [IO, Msg]);
    assert_effectful(PingPongCoordinator.run_exchange, [IO, Msg, Time]);

    // Pure helpers - no effects
    assert_pure(PingPongHelpers.make_ping_message);
    assert_pure(PingPongHelpers.make_pong_message);
    assert_pure(PingPongHelpers.is_ping);
    assert_pure(PingPongHelpers.is_pong);
    assert_pure(PingPongHelpers.extract_count);
    assert_pure(PingPongHelpers.should_continue);
}
